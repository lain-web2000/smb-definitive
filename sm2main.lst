                                .include "defines.inc"
                                
                                ;-------------------------------------------------------------------------------------
                                ;DEFINES
                                
                                ;NES specific hardware defines
                                
                                PPU_CTRL              = $2000
                                PPU_MASK              = $2001
                                PPU_STATUS            = $2002
                                PPU_SPR_ADDR          = $2003
                                PPU_SPR_DATA          = $2004
                                PPU_SCROLL            = $2005
                                PPU_ADDRESS           = $2006
                                PPU_DATA              = $2007
                                
                                SND_REGISTER          = $4000
                                SND_SQUARE1_REG       = $4000
                                SND_SQUARE2_REG       = $4004
                                SND_TRIANGLE_REG      = $4008
                                SND_NOISE_REG         = $400c
                                SND_DELTA_REG         = $4010
                                SND_MASTERCTRL_REG    = $4015
                                
                                SPR_DMA               = $4014
                                JOYPAD_PORT           = $4016
                                JOYPAD_PORT1          = $4016
                                JOYPAD_PORT2          = $4017
                                
                                ; GAME SPECIFIC DEFINES
                                
                                ObjectOffset          = $08
                                
                                FrameCounter          = $09
                                
                                SavedJoypadBits       = $06fc
                                SavedJoypad1Bits      = $06fc
                                SavedJoypad2Bits      = $06fd
                                JoypadBitMask         = $074a
                                JoypadOverride        = $0758
                                
                                IRQAckFlag			  = $077b
                                IRQUpdateFlag		  = $0722
                                
                                A_B_Buttons           = $0a
                                PreviousA_B_Buttons   = $0d
                                Up_Down_Buttons       = $0b
                                Left_Right_Buttons    = $0c
                                
                                GameEngineSubroutine  = $0e
                                
                                Mirror_PPU_CTRL       = $0778
                                Mirror_PPU_MASK       = $0779
                                Mirror_FDS_CTRL_REG   = $fa
                                NameTableSelect       = $077a
                                FileListNumber        = $07f7
                                
                                OperMode              = $0770
                                OperMode_Task         = $0772
                                ScreenRoutineTask     = $073c
                                
                                DiskIOTask            = $07fc
                                NotColdFlag           = $07fd
                                
                                GamePauseStatus       = $0776
                                GamePauseTimer        = $0777
                                
                                DemoAction            = $0717
                                DemoActionTimer       = $0718
                                
                                TimerControl          = $0747
                                IntervalTimerControl  = $077f
                                
                                Timers                = $0780
                                SelectTimer           = $0780
                                PlayerAnimTimer       = $0781
                                JumpSwimTimer         = $0782
                                RunningTimer          = $0783
                                BlockBounceTimer      = $0784
                                SideCollisionTimer    = $0785
                                JumpspringTimer       = $0786
                                GameTimerCtrlTimer    = $0787
                                ClimbSideTimer        = $0789
                                EnemyFrameTimer       = $078a
                                FrenzyEnemyTimer      = $078f
                                BowserFireBreathTimer = $0790
                                StompTimer            = $0791
                                AirBubbleTimer        = $0792
                                ScrollIntervalTimer   = $0795
                                EnemyIntervalTimer    = $0796
                                BrickCoinTimer        = $079d
                                InjuryTimer           = $079e
                                StarInvincibleTimer   = $079f
                                ScreenTimer           = $07a0
                                WorldEndTimer         = $07a1
                                DemoTimer             = $07a2
                                GameOverMsgFlag       = $07f5
                                
                                Sprite_Data           = $0200
                                
                                Sprite_Y_Position     = $0200
                                Sprite_Tilenumber     = $0201
                                Sprite_Attributes     = $0202
                                Sprite_X_Position     = $0203
                                
                                ScreenEdge_PageLoc    = $071a
                                ScreenEdge_X_Pos      = $071c
                                ScreenLeft_PageLoc    = $071a
                                ScreenRight_PageLoc   = $071b
                                ScreenLeft_X_Pos      = $071c
                                ScreenRight_X_Pos     = $071d
                                
                                PlayerFacingDir       = $33
                                DestinationPageLoc    = $34
                                VictoryWalkControl    = $35
                                ScrollFractional      = $0768
                                SecondaryMsgCounter   = $0749
                                MsgCounter            = $0719
                                MsgFractional         = $0749
                                
                                EndControlCntr        = $0761
                                BlueColorOfs          = $0762
                                BlueDelayFlag         = $0763
                                MushroomRetDelay      = $0764
                                MRetainerOffset       = $0762
                                CurrentFlashMRet      = $0763
                                
                                HorizontalScroll      = $073f
                                VerticalScroll        = $0740
                                ScrollLock            = $0723
                                ScrollThirtyTwo       = $073d
                                Player_X_Scroll       = $06ff
                                Player_Pos_ForScroll  = $0755
                                ScrollAmount          = $0775
                                
                                AreaData              = $e7
                                AreaDataLow           = $e7
                                AreaDataHigh          = $e8
                                EnemyData             = $e9
                                EnemyDataLow          = $e9
                                EnemyDataHigh         = $ea
                                AreaDataCopy          = $6010
                                EnemyDataCopy         = $6110
                                
                                AreaParserTaskNum     = $071f
                                ColumnSets            = $071e
                                CurrentPageLoc        = $0725
                                CurrentColumnPos      = $0726
                                BackloadingFlag       = $0728
                                BehindAreaParserFlag  = $0729
                                AreaObjectPageLoc     = $072a
                                AreaObjectPageSel     = $072b
                                AreaDataOffset        = $072c
                                AreaObjOffsetBuffer   = $072d
                                AreaObjectLength      = $0730
                                StaircaseControl      = $0734
                                AreaObjectHeight      = $0735
                                MushroomLedgeHalfLen  = $0736
                                EnemyDataOffset       = $0739
                                EnemyObjectPageLoc    = $073a
                                EnemyObjectPageSel    = $073b
                                MetatileBuffer        = $06a1
                                BlockBufferColumnPos  = $06a0
                                CurrentNTAddr_Low     = $0721
                                CurrentNTAddr_High    = $0720
                                AttributeBuffer       = $03f9
                                
                                LoopCommand           = $0745
                                
                                DisplayDigits         = $07d7
                                TopScoreDisplay       = $07d7
                                ScoreAndCoinDisplay   = $07dd
                                PlayerScoreDisplay    = $07dd
                                GameTimerDisplay      = $07ec
                                CoinDisplay           = $07e7
                                DigitModifier         = $0134
                                
                                VerticalFlipFlag      = $0109
                                FloateyNum_Control    = $0110
                                ShellChainCounter     = $0125
                                FloateyNum_Timer      = $012c
                                FloateyNum_X_Pos      = $0117
                                FloateyNum_Y_Pos      = $011e
                                FlagpoleFNum_Y_Pos    = $010d
                                FlagpoleFNum_YMFDummy = $010e
                                FlagpoleScore         = $010f
                                FlagpoleCollisionYPos = $070f
                                StompChainCounter     = $0484
                                FlagpoleMusicFlag     = $07f6
                                
                                VRAM_Buffer1_Offset   = $0300
                                VRAM_Buffer1          = $0301
                                VRAM_Buffer2_Offset   = $0340
                                VRAM_Buffer2          = $0341
                                VRAM_Buffer_AddrCtrl  = $0773
                                Sprite0HitDetectFlag  = $0722
                                DisableScreenFlag     = $0774
                                DisableIntermediate   = $0769
                                ColorRotateOffset     = $06d4
                                
                                TerrainControl        = $0727
                                AreaStyle             = $0733
                                ForegroundScenery     = $0741
                                BackgroundScenery     = $0742
                                CloudTypeOverride     = $0743
                                BackgroundColorCtrl   = $0744
                                AreaType              = $074e
                                AreaAddrsLOffset      = $074f
                                AreaPointer           = $0750
                                
                                PlayerEntranceCtrl    = $0710
                                GameTimerSetting      = $0715
                                AltEntranceControl    = $0752
                                EntrancePage          = $0751
                                WarpZoneControl       = $06d6
                                ChangeAreaTimer       = $06de
                                
                                MultiLoopCorrectCntr  = $06d9
                                MultiLoopPassCntr     = $06da
                                
                                FetchNewGameTimerFlag = $0757
                                GameTimerExpiredFlag  = $0759
                                
                                PrimaryHardMode       = $076a
                                SecondaryHardMode     = $06cc
                                WorldSelectNumber     = $076b
                                CompletedWorlds       = $07fa
                                HardWorldFlag         = $07fb
                                ContinueMenuSelect    = $07f8
                                
                                SelectedPlayer        = $0753
                                PlayerSize            = $0754
                                PlayerStatus          = $0756
                                
                                OnscreenPlayerInfo    = $075a
                                NumberofLives         = $075a ;used by current player
                                HalfwayPage           = $075b
                                LevelNumber           = $075c ;the actual dash number
                                Hidden1UpFlag         = $075d
                                CoinTally             = $075e
                                WorldNumber           = $075f
                                AreaNumber            = $0760 ;internal number used to find areas
                                
                                CoinTallyFor1Ups      = $0748
                                
                                BalPlatformAlignment  = $03a0
                                Platform_X_Scroll     = $03a1
                                PlatformCollisionFlag = $03a2
                                YPlatformTopYPos      = $0401
                                YPlatformCenterYPos   = $58
                                
                                BrickCoinTimerFlag    = $06bc
                                StarFlagTaskControl   = $0746
                                
                                PseudoRandomBitReg    = $07a7
                                WarmBootValidation    = $07ff
                                
                                SprShuffleAmtOffset   = $06e0
                                SprShuffleAmt         = $06e1
                                SprDataOffset         = $06e4
                                Player_SprDataOffset  = $06e4
                                Enemy_SprDataOffset   = $06e5
                                Block_SprDataOffset   = $06ec
                                Alt_SprDataOffset     = $06ec
                                Bubble_SprDataOffset  = $06ee
                                FBall_SprDataOffset   = $06f1
                                Misc_SprDataOffset    = $06f3
                                SprDataOffset_Ctrl    = $03ee
                                
                                Player_State          = $1d
                                Enemy_State           = $1e
                                Fireball_State        = $24
                                Block_State           = $26
                                Misc_State            = $2a
                                
                                Player_MovingDir      = $45
                                Enemy_MovingDir       = $46
                                
                                SprObject_X_Speed     = $57
                                Player_X_Speed        = $57
                                Enemy_X_Speed         = $58
                                Fireball_X_Speed      = $5e
                                Block_X_Speed         = $60
                                Misc_X_Speed          = $64
                                
                                Jumpspring_FixedYPos  = $58
                                JumpspringAnimCtrl    = $070e
                                JumpspringForce       = $06db
                                
                                SprObject_PageLoc     = $6d
                                Player_PageLoc        = $6d
                                Enemy_PageLoc         = $6e
                                Fireball_PageLoc      = $74
                                Block_PageLoc         = $76
                                Misc_PageLoc          = $7a
                                Bubble_PageLoc        = $83
                                
                                SprObject_X_Position  = $86
                                Player_X_Position     = $86
                                Enemy_X_Position      = $87
                                Fireball_X_Position   = $8d
                                Block_X_Position      = $8f
                                Misc_X_Position       = $93
                                Bubble_X_Position     = $9c
                                
                                SprObject_Y_Speed     = $9f
                                Player_Y_Speed        = $9f
                                Enemy_Y_Speed         = $a0
                                Fireball_Y_Speed      = $a6
                                Block_Y_Speed         = $a8
                                Misc_Y_Speed          = $ac
                                
                                SprObject_Y_HighPos   = $b5
                                Player_Y_HighPos      = $b5
                                Enemy_Y_HighPos       = $b6
                                Fireball_Y_HighPos    = $bc
                                Block_Y_HighPos       = $be
                                Misc_Y_HighPos        = $c2
                                Bubble_Y_HighPos      = $cb
                                
                                SprObject_Y_Position  = $ce
                                Player_Y_Position     = $ce
                                Enemy_Y_Position      = $cf
                                Fireball_Y_Position   = $d5
                                Block_Y_Position      = $d7
                                Misc_Y_Position       = $db
                                Bubble_Y_Position     = $e4
                                
                                SprObject_Rel_XPos    = $03ad
                                Player_Rel_XPos       = $03ad
                                Enemy_Rel_XPos        = $03ae
                                Fireball_Rel_XPos     = $03af
                                Bubble_Rel_XPos       = $03b0
                                Block_Rel_XPos        = $03b1
                                Misc_Rel_XPos         = $03b3
                                
                                SprObject_Rel_YPos    = $03b8
                                Player_Rel_YPos       = $03b8
                                Enemy_Rel_YPos        = $03b9
                                Fireball_Rel_YPos     = $03ba
                                Bubble_Rel_YPos       = $03bb
                                Block_Rel_YPos        = $03bc
                                Misc_Rel_YPos         = $03be
                                
                                SprObject_SprAttrib   = $03c4
                                Player_SprAttrib      = $03c4
                                Enemy_SprAttrib       = $03c5
                                
                                SprObject_X_MoveForce = $0400
                                Enemy_X_MoveForce     = $0401
                                
                                SprObject_YMF_Dummy   = $0416
                                Player_YMF_Dummy      = $0416
                                Enemy_YMF_Dummy       = $0417
                                Bubble_YMF_Dummy      = $042c
                                
                                SprObject_Y_MoveForce = $0433
                                Player_Y_MoveForce    = $0433
                                Enemy_Y_MoveForce     = $0434
                                Block_Y_MoveForce     = $043c
                                
                                DisableCollisionDet   = $0716
                                Player_CollisionBits  = $0490
                                Enemy_CollisionBits   = $0491
                                
                                SprObj_BoundBoxCtrl   = $0499
                                Player_BoundBoxCtrl   = $0499
                                Enemy_BoundBoxCtrl    = $049a
                                Fireball_BoundBoxCtrl = $04a0
                                Misc_BoundBoxCtrl     = $04a2
                                
                                EnemyFrenzyBuffer     = $06cb
                                EnemyFrenzyQueue      = $06cd
                                Enemy_Flag            = $0f
                                Enemy_ID              = $16
                                
                                PlayerGfxOffset       = $06d5
                                Player_XSpeedAbsolute = $0700
                                FrictionAdderHigh     = $0701
                                FrictionAdderLow      = $0702
                                RunningSpeed          = $0703
                                SwimmingFlag          = $0704
                                Player_X_MoveForce    = $0705
                                DiffToHaltJump        = $0706
                                JumpOrigin_Y_HighPos  = $0707
                                JumpOrigin_Y_Position = $0708
                                VerticalForce         = $0709
                                VerticalForceDown     = $070a
                                PlayerChangeSizeFlag  = $070b
                                PlayerAnimTimerSet    = $070c
                                PlayerAnimCtrl        = $070d
                                DeathMusicLoaded      = $0712
                                FlagpoleSoundQueue    = $0713
                                CrouchingFlag         = $0714
                                MaximumLeftSpeed      = $0450
                                MaximumRightSpeed     = $0456
                                
                                WindFlag              = $07f9
                                
                                SprObject_OffscrBits  = $03d0
                                Player_OffscreenBits  = $03d0
                                Enemy_OffscreenBits   = $03d1
                                FBall_OffscreenBits   = $03d2
                                Bubble_OffscreenBits  = $03d3
                                Block_OffscreenBits   = $03d4
                                Misc_OffscreenBits    = $03d6
                                EnemyOffscrBitsMasked = $03d8
                                
                                Cannon_Offset         = $046a
                                Cannon_PageLoc        = $046b
                                Cannon_X_Position     = $0471
                                Cannon_Y_Position     = $0477
                                Cannon_Timer          = $047d
                                
                                Whirlpool_Offset      = $046a
                                Whirlpool_PageLoc     = $046b
                                Whirlpool_LeftExtent  = $0471
                                Whirlpool_Length      = $0477
                                Whirlpool_Flag        = $047d
                                
                                VineFlagOffset        = $0398
                                VineHeight            = $0399
                                VineObjOffset         = $039a
                                VineStart_Y_Position  = $039d
                                
                                Block_Orig_YPos       = $03e4
                                Block_BBuf_Low        = $03e6
                                Block_Metatile        = $03e8
                                Block_PageLoc2        = $03ea
                                Block_RepFlag         = $03ec
                                Block_ResidualCounter = $03f0
                                Block_Orig_XPos       = $03f1
                                
                                BoundingBox_UL_XPos   = $04ac
                                BoundingBox_UL_YPos   = $04ad
                                BoundingBox_DR_XPos   = $04ae
                                BoundingBox_DR_YPos   = $04af
                                BoundingBox_UL_Corner = $04ac
                                BoundingBox_LR_Corner = $04ae
                                EnemyBoundingBoxCoord = $04b0
                                
                                PowerUpType           = $39
                                
                                FireballBouncingFlag  = $3a
                                FireballCounter       = $06ce
                                FireballThrowingTimer = $0711
                                
                                HammerEnemyOffset     = $06ae
                                JumpCoinMiscOffset    = $06b7
                                
                                Block_Buffer_1        = $0500
                                Block_Buffer_2        = $05d0
                                
                                HammerThrowingTimer   = $03a2
                                HammerBroJumpTimer    = $3c
                                Misc_Collision_Flag   = $06be
                                
                                RedPTroopaOrigXPos    = $0401
                                RedPTroopaCenterYPos  = $58
                                
                                XMovePrimaryCounter   = $a0
                                XMoveSecondaryCounter = $58
                                
                                CheepCheepMoveMFlag   = $58
                                CheepCheepOrigYPos    = $0434
                                BitMFilter            = $06dd
                                
                                LakituReappearTimer   = $06d1
                                LakituMoveSpeed       = $58
                                LakituMoveDirection   = $a0
                                
                                FirebarSpinState_Low  = $58
                                FirebarSpinState_High = $a0
                                FirebarSpinSpeed      = $0388
                                FirebarSpinDirection  = $34
                                
                                DuplicateObj_Offset   = $06cf
                                NumberofGroupEnemies  = $06d3
                                
                                BlooperMoveCounter    = $a0
                                BlooperMoveSpeed      = $58
                                
                                BowserBodyControls    = $0363
                                BowserFeetCounter     = $0364
                                BowserMovementSpeed   = $0365
                                BowserOrigXPos        = $0366
                                BowserFlameTimerCtrl  = $0367
                                BowserFront_Offset    = $0368
                                BridgeCollapseOffset  = $0369
                                BowserGfxFlag         = $036a
                                BowserHitPoints       = $0483
                                MaxRangeFromOrigin    = $06dc
                                
                                BowserFlamePRandomOfs = $0417
                                
                                PiranhaPlantUpYPos    = $0417
                                PiranhaPlantDownYPos  = $0434
                                PiranhaPlant_Y_Speed  = $58
                                PiranhaPlant_MoveFlag = $a0
                                
                                FireworksCounter      = $06d7
                                ExplosionGfxCounter   = $58
                                ExplosionTimerCounter = $a0
                                
                                LeavesXPosCopy        = $6210
                                LeavesYPosCopy        = $621c
                                
                                SaveDataHeader        = $6000
                                GamesBeatenCount      = $6007
                                
                                ;sound related defines
                                Squ2_NoteLenBuffer    = $07b3
                                Squ2_NoteLenCounter   = $07b4
                                Squ2_EnvelopeDataCtrl = $07b5
                                Squ1_NoteLenCounter   = $07b6
                                Squ1_EnvelopeDataCtrl = $07b7
                                Tri_NoteLenBuffer     = $07b8
                                Tri_NoteLenCounter    = $07b9
                                Noise_BeatLenCounter  = $07ba
                                Squ1_SfxLenCounter    = $07bb
                                Squ2_SfxLenCounter    = $07bd
                                Sfx_SecondaryCounter  = $07be
                                Noise_SfxLenCounter   = $07bf
                                
                                PauseSoundQueue       = $fa
                                Square1SoundQueue     = $ff
                                Square2SoundQueue     = $fe
                                NoiseSoundQueue       = $fd
                                AreaMusicQueue        = $fb
                                EventMusicQueue       = $fc
                                
                                Square1SoundBuffer    = $f1
                                Square2SoundBuffer    = $f2
                                NoiseSoundBuffer      = $f3
                                AreaMusicBuffer       = $f4
                                EventMusicBuffer      = $07b1
                                PauseSoundBuffer      = $07b2
                                
                                PatternNumber         = $061d
                                
                                MusicData             = $f5
                                MusicDataLow          = $f5
                                MusicDataHigh         = $f6
                                MusicOffset_Square2   = $f7
                                MusicOffset_Square1   = $f8
                                MusicOffset_Triangle  = $f9
                                MusicOffset_Noise     = $07b0
                                
                                NoteLenLookupTblOfs   = $f0
                                DAC_Counter           = $07c0
                                NoiseDataLoopbackOfs  = $07c1
                                NoteLengthTblAdder    = $07c4
                                AreaMusicBuffer_Alt   = $07c5
                                PauseModeFlag         = $07c6
                                GroundMusicHeaderOfs  = $07c7
                                AltRegContentFlag     = $07ca
                                
                                ;-------------------------------------------------------------------------------------
                                ;CONSTANTS
                                
                                ;sound effects constants
                                Sfx_SmallJump         = %10000000
                                Sfx_Flagpole          = %01000000
                                Sfx_Fireball          = %00100000
                                Sfx_PipeDown_Injury   = %00010000
                                Sfx_EnemySmack        = %00001000
                                Sfx_EnemyStomp        = %00000100
                                Sfx_Bump              = %00000010
                                Sfx_BigJump           = %00000001
                                
                                Sfx_BowserFall        = %10000000
                                Sfx_ExtraLife         = %01000000
                                Sfx_PowerUpGrab       = %00100000
                                Sfx_TimerTick         = %00010000
                                Sfx_Blast             = %00001000
                                Sfx_GrowVine          = %00000100
                                Sfx_GrowPowerUp       = %00000010
                                Sfx_CoinGrab          = %00000001
                                
                                Sfx_BowserFlame       = %00000010
                                Sfx_BrickShatter      = %00000001
                                
                                ;music constants
                                Silence               = %10000000
                                
                                StarPowerMusic        = %01000000
                                PipeIntroMusic        = %00100000
                                CloudMusic            = %00010000
                                CastleMusic           = %00001000
                                UndergroundMusic      = %00000100
                                WaterMusic            = %00000010
                                GroundMusic           = %00000001
                                
                                TimeRunningOutMusic   = %01000000
                                EndOfLevelMusic       = %00100000
                                AltGameOverMusic      = %00010000
                                EndOfCastleMusic      = %00001000
                                VictoryMusic          = %00000100
                                GameOverMusic         = %00000010
                                DeathMusic            = %00000001
                                
                                ;enemy object constants 
                                GreenKoopa            = $00
                                BuzzyBeetle           = $02
                                RedKoopa              = $03
                                HammerBro             = $05
                                Goomba                = $06
                                Bloober               = $07
                                BulletBill_FrenzyVar  = $08
                                GreyCheepCheep        = $0a
                                RedCheepCheep         = $0b
                                Podoboo               = $0c
                                PiranhaPlant          = $0d
                                GreenParatroopaJump   = $0e
                                RedParatroopa         = $0f
                                GreenParatroopaFly    = $10
                                Lakitu                = $11
                                Spiny                 = $12
                                FlyCheepCheepFrenzy   = $14
                                FlyingCheepCheep      = $14
                                BowserFlame           = $15
                                Fireworks             = $16
                                BBill_CCheep_Frenzy   = $17
                                Stop_Frenzy           = $18
                                Bowser                = $2d
                                PowerUpObject         = $2e
                                VineObject            = $2f
                                FlagpoleFlagObject    = $30
                                StarFlagObject        = $31
                                JumpspringObject      = $32
                                BulletBill_CannonVar  = $33
                                RetainerObject        = $35
                                TallEnemy             = $09
                                UpsideDownPiranhaP    = $04
                                
                                ;other constants
                                World1 = 0
                                World2 = 1
                                World3 = 2
                                World4 = 3
                                World5 = 4
                                World6 = 5
                                World7 = 6
                                World8 = 7
                                World9 = 8
                                WorldA = 9
                                WorldB = 10
                                WorldC = 11
                                WorldD = 12
                                Level1 = 0
                                Level2 = 1
                                Level3 = 2
                                Level4 = 3
                                
                                WarmBootOffset        = <$07d6
                                ColdBootOffset        = <$07fe
                                SoundMemory           = $07b0
                                SwimTileRepOffset     = PlayerGraphicsTable + $9e
                                MusicHeaderOffsetData = MusicHeaderData - 1
                                MHD                   = MusicHeaderData
                                
                                A_Button              = %10000000
                                B_Button              = %01000000
                                Select_Button         = %00100000
                                Start_Button          = %00010000
                                Up_Dir                = %00001000
                                Down_Dir              = %00000100
                                Left_Dir              = %00000010
                                Right_Dir             = %00000001
                                
                                AttractMode           = 0
                                GameMode              = 1
                                VictoryMode           = 2
                                GameOverMode          = 3
                                
                                SoundBank             = 0
                                LevelsBank            = 2
                                MainBank              = 4
                                FixedBank             = 6
                                
                                MMC3_BankSelect		  = $8000
                                MMC3_BankData		  = $8001
                                MMC3_Mirroring		  = $a000
                                MMC3_PRGRAMProtect    = $a001
                                
                                MMC3_IRQLatch		  = $c000
                                MMC3_IRQReload		  = $c001
                                MMC3_IRQDisable		  = $e000
                                MMC3_IRQEnable		  = $e001
                                
                                BG_MainBank           = 0
                                Spr_MainBank          = 4
                                BG_TitleBank          = 8
                                Spr_EndingBank        = 12                                
                                ;-------------------------------------------------------------------------------------
                                ;DIRECTIVES
                                
                                ;"INESHDR"
      4E 45 53 1A                 .db $4E,$45,$53,$1A                           ;  magic signature
      04                          .db 4                                         ;  PRG ROM size in 16384 byte units
      02                          .db 2                                         ;  CHR
      43                          .db $43                                       ;  mirroring type and mapper number lower nibble
      00                          .db $00                                       ;  mapper number upper nibble
      00 00 00 00 00 00 00 00     .db $00,$00,$00,$00,$00,$00,$00,$00
                                
                                .org $8000
08000                           .include "sound.asm"
08000                           ;-------------------------------------------------------------------------------------
08000                           SoundEngine:
08000 AD 70 07                           lda OperMode              ;are we in attract mode?
08003 D0 04                              bne SndOn
08005 8D 15 40                           sta SND_MASTERCTRL_REG    ;if so, disable sound and leave
08008 60                                 rts
08009 A9 FF                     SndOn:   lda #$ff
0800B 8D 17 40                           sta JOYPAD_PORT2          ;disable irqs from apu and set frame counter mode
0800E A9 0F                              lda #$0f
08010 8D 15 40                           sta SND_MASTERCTRL_REG    ;enable first four channels
08013 AD C6 07                           lda PauseModeFlag         ;is sound already in pause mode?
08016 D0 06                              bne InPause
08018 A5 FA                              lda PauseSoundQueue       ;if not, check pause sfx queue    
0801A C9 01                              cmp #$01
0801C D0 5D                              bne RunSoundSubroutines   ;if queue is empty, skip pause mode routine
0801E AD B2 07                  InPause: lda PauseSoundBuffer      ;check pause sfx buffer
08021 D0 23                              bne ContPau
08023 A5 FA                              lda PauseSoundQueue       ;check pause queue
08025 F0 66                              beq SkipSoundSubroutines
08027 8D B2 07                           sta PauseSoundBuffer      ;if queue full, store in buffer and activate
0802A 8D C6 07                           sta PauseModeFlag         ;pause mode to interrupt game sounds
0802D A9 00                              lda #$00                  ;disable sound and clear sfx buffers
0802F 8D 15 40                           sta SND_MASTERCTRL_REG
08032 85 F1                              sta Square1SoundBuffer
08034 85 F2                              sta Square2SoundBuffer
08036 85 F3                              sta NoiseSoundBuffer
08038 A9 0F                              lda #$0f
0803A 8D 15 40                           sta SND_MASTERCTRL_REG    ;enable sound again
0803D A9 2A                              lda #$2a                  ;store length of sound in pause counter
0803F 8D BB 07                           sta Squ1_SfxLenCounter
08042 A9 44                     PTone1F: lda #$44                  ;play first tone
08044 D0 11                              bne PTRegC                ;unconditional branch
08046 AD BB 07                  ContPau: lda Squ1_SfxLenCounter    ;check pause length left
08049 C9 24                              cmp #$24                  ;time to play second?
0804B F0 08                              beq PTone2F
0804D C9 1E                              cmp #$1e                  ;time to play first again?
0804F F0 F1                              beq PTone1F
08051 C9 18                              cmp #$18                  ;time to play second again?
08053 D0 09                              bne DecPauC               ;only load regs during times, otherwise skip
08055 A9 64                     PTone2F: lda #$64                  ;store reg contents and play the pause sfx
08057 A2 84                     PTRegC:  ldx #$84
08059 A0 7F                              ldy #$7f
0805B 20 B8 80                           jsr PlaySqu1Sfx
0805E CE BB 07                  DecPauC: dec Squ1_SfxLenCounter    ;decrement pause sfx counter
08061 D0 2A                              bne SkipSoundSubroutines
08063 A9 00                              lda #$00                  ;disable sound if in pause mode and
08065 8D 15 40                           sta SND_MASTERCTRL_REG    ;not currently playing the pause sfx
08068 AD B2 07                           lda PauseSoundBuffer      ;if no longer playing pause sfx, check to see
0806B C9 02                              cmp #$02                  ;if we need to be playing sound again
0806D D0 05                              bne SkipPIn
0806F A9 00                              lda #$00                  ;clear pause mode to allow game sounds again
08071 8D C6 07                           sta PauseModeFlag
08074 A9 00                     SkipPIn: lda #$00                  ;clear pause sfx buffer
08076 8D B2 07                           sta PauseSoundBuffer
08079 F0 12                              beq SkipSoundSubroutines
0807B                           
0807B                           RunSoundSubroutines:
0807B 20 4B 81                           jsr Square1SfxHandler  ;play sfx on square channel 1
0807E 20 AC 82                           jsr Square2SfxHandler  ; ''  ''  '' square channel 2
08081 20 D7 83                           jsr NoiseSfxHandler    ; ''  ''  '' noise channel
08084 20 30 84                           jsr MusicHandler       ;play music on all channels
08087 A9 00                              lda #$00               ;clear the music queues
08089 85 FB                              sta AreaMusicQueue
0808B 85 FC                              sta EventMusicQueue
0808D                           
0808D                           SkipSoundSubroutines:
0808D A9 00                               lda #$00               ;clear the sound effects queues
0808F 85 FF                               sta Square1SoundQueue
08091 85 FE                               sta Square2SoundQueue
08093 85 FD                               sta NoiseSoundQueue
08095 85 FA                               sta PauseSoundQueue
08097 AC C0 07                            ldy DAC_Counter        ;load some sort of counter 
0809A A5 F4                               lda AreaMusicBuffer
0809C 29 03                               and #%00000011         ;check for specific music
0809E F0 07                               beq NoIncDAC
080A0 EE C0 07                            inc DAC_Counter        ;increment and check counter
080A3 C0 30                               cpy #$30
080A5 90 06                               bcc StrWave            ;if not there yet, just store it
080A7 98                        NoIncDAC: tya
080A8 F0 03                               beq StrWave            ;if we are at zero, do not decrement 
080AA CE C0 07                            dec DAC_Counter        ;decrement counter
080AD 8C 11 40                  StrWave:  sty SND_DELTA_REG+1    ;store into DMC load register (??)
080B0 60                                  rts                    ;we are done here
080B1                           
080B1                           
080B1                           ;--------------------------------
080B1                           
080B1                           Dump_Squ1_Regs:
080B1 8C 01 40                        sty SND_SQUARE1_REG+1  ;dump the contents of X and Y into square 1's control regs
080B4 8E 00 40                        stx SND_SQUARE1_REG
080B7 60                              rts
080B8                                 
080B8                           PlaySqu1Sfx:
080B8 20 B1 80                        jsr Dump_Squ1_Regs     ;do sub to set ctrl regs for square 1, then set frequency regs
080BB                           
080BB                           SetFreq_Squ1:
080BB A2 00                           ldx #$00               ;set frequency reg offset for square 1 sound channel
080BD                           
080BD                           Dump_Freq_Regs:
080BD A8                                tay
080BE B9 E0 8D                          lda FreqRegLookupTbl+1,y  ;use previous contents of A for sound reg offset
080C1 F0 0B                             beq NoTone                ;if zero, then do not load
080C3 9D 02 40                          sta SND_REGISTER+2,x      ;first byte goes into LSB of frequency divider
080C6 B9 DF 8D                          lda FreqRegLookupTbl,y    ;second byte goes into 3 MSB plus extra bit for 
080C9 09 08                             ora #%00001000            ;length counter
080CB 9D 03 40                          sta SND_REGISTER+3,x
080CE 60                        NoTone: rts
080CF                           
080CF                           Dump_Sq2_Regs:
080CF 8E 04 40                        stx SND_SQUARE2_REG    ;dump the contents of X and Y into square 2's control regs
080D2 8C 05 40                        sty SND_SQUARE2_REG+1
080D5 60                              rts
080D6                           
080D6                           PlaySqu2Sfx:
080D6 20 CF 80                        jsr Dump_Sq2_Regs      ;do sub to set ctrl regs for square 2, then set frequency regs
080D9                           
080D9                           SetFreq_Squ2:
080D9 A2 04                           ldx #$04               ;set frequency reg offset for square 2 sound channel
080DB D0 E0                           bne Dump_Freq_Regs     ;unconditional branch
080DD                           
080DD                           SetFreq_Tri:
080DD A2 08                           ldx #$08               ;set frequency reg offset for triangle sound channel
080DF D0 DC                           bne Dump_Freq_Regs     ;unconditional branch
080E1                           
080E1                           ;--------------------------------
080E1                           
080E1                           SwimStompEnvelopeData:
080E1 9F 9B 98 96 95 94 92 90         .db $9f, $9b, $98, $96, $95, $94, $92, $90
080E9 90 9A 97 95 93 92               .db $90, $9a, $97, $95, $93, $92
080EF                           
080EF                           PlayFlagpoleSlide:
080EF A9 40                            lda #$40               ;store length of flagpole sound
080F1 8D BB 07                         sta Squ1_SfxLenCounter
080F4 A9 62                            lda #$62               ;load part of reg contents for flagpole sound
080F6 20 BB 80                         jsr SetFreq_Squ1
080F9 A2 99                            ldx #$99               ;now load the rest
080FB D0 25                            bne FPS2nd
080FD                           
080FD                           PlaySmallJump:
080FD A9 26                            lda #$26               ;branch here for small mario jumping sound
080FF D0 02                            bne JumpRegContents
08101                           
08101                           PlayBigJump:
08101 A9 18                            lda #$18               ;branch here for big mario jumping sound
08103                           
08103                           JumpRegContents:
08103 A2 82                            ldx #$82               ;note that small and big jump borrow each others' reg contents
08105 A0 A7                            ldy #$a7               ;anyway, this loads the first part of mario's jumping sound
08107 20 B8 80                         jsr PlaySqu1Sfx
0810A A9 28                            lda #$28               ;store length of sfx for both jumping sounds
0810C 8D BB 07                         sta Squ1_SfxLenCounter ;then continue on here
0810F                           
0810F                           ContinueSndJump:
0810F AD BB 07                            lda Squ1_SfxLenCounter ;jumping sounds seem to be composed of three parts
08112 C9 25                               cmp #$25               ;check for time to play second part yet
08114 D0 06                               bne N2Prt
08116 A2 5F                               ldx #$5f               ;load second part
08118 A0 F6                               ldy #$f6
0811A D0 08                               bne DmpJpFPS           ;unconditional branch
0811C C9 20                     N2Prt:    cmp #$20               ;check for third part
0811E D0 29                               bne DecJpFPS
08120 A2 48                               ldx #$48               ;load third part
08122 A0 BC                     FPS2nd:   ldy #$bc               ;the flagpole slide sound shares part of third part
08124 20 B1 80                  DmpJpFPS: jsr Dump_Squ1_Regs
08127 D0 20                               bne DecJpFPS           ;unconditional branch outta here
08129                           
08129                           PlayFireballThrow:
08129 A9 05                             lda #$05
0812B A0 99                             ldy #$99                 ;load reg contents for fireball throw sound
0812D D0 04                             bne Fthrow               ;unconditional branch
0812F                           
0812F                           PlayBump:
0812F A9 0A                               lda #$0a                ;load length of sfx and reg contents for bump sound
08131 A0 93                               ldy #$93
08133 A2 9E                     Fthrow:   ldx #$9e                ;the fireball sound shares reg contents with the bump sound
08135 8D BB 07                            sta Squ1_SfxLenCounter
08138 A9 0C                               lda #$0c                ;load offset for bump sound
0813A 20 B8 80                            jsr PlaySqu1Sfx
0813D                           
0813D                           ContinueBumpThrow:    
0813D AD BB 07                            lda Squ1_SfxLenCounter  ;check for second part of bump sound
08140 C9 06                               cmp #$06   
08142 D0 05                               bne DecJpFPS
08144 A9 BB                               lda #$bb                ;load second part directly
08146 8D 01 40                            sta SND_SQUARE1_REG+1
08149 D0 60                     DecJpFPS: bne BranchToDecLength1  ;unconditional branch
0814B                           
0814B                           
0814B                           Square1SfxHandler:
0814B A4 FF                            ldy Square1SoundQueue   ;check for sfx in queue
0814D F0 20                            beq CheckSfx1Buffer
0814F 84 F1                            sty Square1SoundBuffer  ;if found, put in buffer
08151 30 AA                            bmi PlaySmallJump       ;small jump
08153 46 FF                            lsr Square1SoundQueue
08155 B0 AA                            bcs PlayBigJump         ;big jump
08157 46 FF                            lsr Square1SoundQueue
08159 B0 D4                            bcs PlayBump            ;bump
0815B 46 FF                            lsr Square1SoundQueue
0815D B0 2C                            bcs PlaySwimStomp       ;swim/stomp
0815F 46 FF                            lsr Square1SoundQueue
08161 B0 4A                            bcs PlaySmackEnemy      ;smack enemy
08163 46 FF                            lsr Square1SoundQueue
08165 B0 7F                            bcs PlayPipeDownInj     ;pipedown/injury
08167 46 FF                            lsr Square1SoundQueue
08169 B0 BE                            bcs PlayFireballThrow   ;fireball throw
0816B 46 FF                            lsr Square1SoundQueue
0816D B0 80                            bcs PlayFlagpoleSlide   ;slide flagpole
0816F                           
0816F                           CheckSfx1Buffer:
0816F A5 F1                            lda Square1SoundBuffer   ;check for sfx in buffer 
08171 F0 17                            beq ExS1H                ;if not found, exit sub
08173 30 9A                            bmi ContinueSndJump      ;small mario jump 
08175 4A                               lsr
08176 B0 97                            bcs ContinueSndJump      ;big mario jump 
08178 4A                               lsr
08179 B0 C2                            bcs ContinueBumpThrow    ;bump
0817B 4A                               lsr
0817C B0 1B                            bcs ContinueSwimStomp    ;swim/stomp
0817E 4A                               lsr
0817F B0 3C                            bcs ContinueSmackEnemy   ;smack enemy
08181 4A                               lsr
08182 B0 67                            bcs ContinuePipeDownInj  ;pipedown/injury
08184 4A                               lsr
08185 B0 B6                            bcs ContinueBumpThrow    ;fireball throw
08187 4A                               lsr
08188 B0 48                            bcs DecrementSfx1Length  ;slide flagpole
0818A 60                        ExS1H: rts
0818B                           
0818B                           
0818B                           PlaySwimStomp:
0818B A9 0E                           lda #$0e               ;store length of swim/stomp sound
0818D 8D BB 07                        sta Squ1_SfxLenCounter
08190 A0 9C                           ldy #$9c               ;store reg contents for swim/stomp sound
08192 A2 9E                           ldx #$9e
08194 A9 26                           lda #$26
08196 20 B8 80                        jsr PlaySqu1Sfx
08199                           
08199                           ContinueSwimStomp: 
08199 AC BB 07                        ldy Squ1_SfxLenCounter        ;look up reg contents in data section based on
0819C B9 E0 80                        lda SwimStompEnvelopeData-1,y ;length of sound left, used to control sound's
0819F 8D 00 40                        sta SND_SQUARE1_REG           ;envelope
081A2 C0 06                           cpy #$06   
081A4 D0 05                           bne BranchToDecLength1
081A6 A9 9E                           lda #$9e                      ;when the length counts down to a certain point, put this
081A8 8D 02 40                        sta SND_SQUARE1_REG+2         ;directly into the LSB of square 1's frequency divider
081AB                           
081AB                           BranchToDecLength1: 
081AB D0 25                           bne DecrementSfx1Length  ;unconditional branch (regardless of how we got here)
081AD                           
081AD                           PlaySmackEnemy:
081AD A9 0E                           lda #$0e                 ;store length of smack enemy sound
081AF A0 CB                           ldy #$cb
081B1 A2 9F                           ldx #$9f
081B3 8D BB 07                        sta Squ1_SfxLenCounter
081B6 A9 28                           lda #$28                 ;store reg contents for smack enemy sound
081B8 20 B8 80                        jsr PlaySqu1Sfx
081BB D0 15                           bne DecrementSfx1Length  ;unconditional branch
081BD                           
081BD                           ContinueSmackEnemy:
081BD AC BB 07                          ldy Squ1_SfxLenCounter  ;check about halfway through
081C0 C0 08                             cpy #$08
081C2 D0 09                             bne SmSpc
081C4 A9 A0                             lda #$a0                ;if we're at the about-halfway point, make the second tone
081C6 8D 02 40                          sta SND_SQUARE1_REG+2   ;in the smack enemy sound
081C9 A9 9F                             lda #$9f
081CB D0 02                             bne SmTick
081CD A9 90                     SmSpc:  lda #$90                ;this creates spaces in the sound, giving it its distinct noise
081CF 8D 00 40                  SmTick: sta SND_SQUARE1_REG
081D2                           
081D2                           DecrementSfx1Length:
081D2 CE BB 07                        dec Squ1_SfxLenCounter    ;decrement length of sfx
081D5 D0 0E                           bne ExSfx1
081D7                           
081D7                           StopSquare1Sfx:
081D7 A2 00                             ldx #$00                ;if end of sfx reached, clear buffer
081D9 86 F1                             stx $f1                 ;and stop making the sfx
081DB A2 0E                             ldx #$0e
081DD 8E 15 40                          stx SND_MASTERCTRL_REG
081E0 A2 0F                             ldx #$0f
081E2 8E 15 40                          stx SND_MASTERCTRL_REG
081E5 60                        ExSfx1: rts
081E6                           
081E6                           PlayPipeDownInj:  
081E6 A9 2F                           lda #$2f                ;load length of pipedown sound
081E8 8D BB 07                        sta Squ1_SfxLenCounter
081EB                           
081EB                           ContinuePipeDownInj:
081EB AD BB 07                           lda Squ1_SfxLenCounter  ;some bitwise logic, forces the regs
081EE 4A                                 lsr                     ;to be written to only during six specific times
081EF B0 10                              bcs NoPDwnL             ;during which d3 must be set and d1-0 must be clear
081F1 4A                                 lsr
081F2 B0 0D                              bcs NoPDwnL
081F4 29 02                              and #%00000010
081F6 F0 09                              beq NoPDwnL
081F8 A0 91                              ldy #$91                ;and this is where it actually gets written in
081FA A2 9A                              ldx #$9a
081FC A9 44                              lda #$44
081FE 20 B8 80                           jsr PlaySqu1Sfx
08201 4C D2 81                  NoPDwnL: jmp DecrementSfx1Length
08204                           
08204                           ;--------------------------------
08204                           
08204                           ExtraLifeFreqData:
08204 58 02 54 56 4E 44               .db $58, $02, $54, $56, $4e, $44
0820A                           
0820A                           PowerUpGrabFreqData:
0820A 4C 52 4C 48 3E 36 3E 36..       .db $4c, $52, $4c, $48, $3e, $36, $3e, $36, $30
08213 28 4A 50 4A 64 3C 32 3C..       .db $28, $4a, $50, $4a, $64, $3c, $32, $3c, $32
0821C 2C 24 3A 64 3A 34 2C 22..       .db $2c, $24, $3a, $64, $3a, $34, $2c, $22, $2c
08225                           
08225                           ;residual frequency data
08225 22 1C 14                        .db $22, $1c, $14
08228                           
08228                           PUp_VGrow_FreqData:
08228 14 04 22 24 16 04 24 26         .db $14, $04, $22, $24, $16, $04, $24, $26 ;used by both
08230 18 04 26 28 1A 04 28 2A         .db $18, $04, $26, $28, $1a, $04, $28, $2a
08238 1C 04 2A 2C 1E 04 2C 2E         .db $1c, $04, $2a, $2c, $1e, $04, $2c, $2e ;used by vinegrow
08240 20 04 2E 30 22 04 30 32         .db $20, $04, $2e, $30, $22, $04, $30, $32
08248                           
08248                           PlayCoinGrab:
08248 A9 35                             lda #$35             ;load length of coin grab sound
0824A A2 8D                             ldx #$8d             ;and part of reg contents
0824C D0 04                             bne CGrab_TTickRegL
0824E                           
0824E                           PlayTimerTick:
0824E A9 06                             lda #$06             ;load length of timer tick sound
08250 A2 98                             ldx #$98             ;and part of reg contents
08252                           
08252                           CGrab_TTickRegL:
08252 8D BD 07                          sta Squ2_SfxLenCounter 
08255 A0 7F                             ldy #$7f                ;load the rest of reg contents 
08257 A9 42                             lda #$42                ;of coin grab and timer tick sound
08259 20 D6 80                          jsr PlaySqu2Sfx
0825C                           
0825C                           ContinueCGrabTTick:
0825C AD BD 07                          lda Squ2_SfxLenCounter  ;check for time to play second tone yet
0825F C9 30                             cmp #$30                ;timer tick sound also executes this, not sure why
08261 D0 05                             bne N2Tone
08263 A9 54                             lda #$54                ;if so, load the tone directly into the reg
08265 8D 06 40                          sta SND_SQUARE2_REG+2
08268 D0 2E                     N2Tone: bne DecrementSfx2Length
0826A                           
0826A                           PlayBlast:
0826A A9 20                             lda #$20                ;load length of fireworks/gunfire sound
0826C 8D BD 07                          sta Squ2_SfxLenCounter
0826F A0 94                             ldy #$94                ;load reg contents of fireworks/gunfire sound
08271 A9 5E                             lda #$5e
08273 D0 0B                             bne SBlasJ
08275                           
08275                           ContinueBlast:
08275 AD BD 07                          lda Squ2_SfxLenCounter  ;check for time to play second part
08278 C9 18                             cmp #$18
0827A D0 1C                             bne DecrementSfx2Length
0827C A0 93                             ldy #$93                ;load second part reg contents then
0827E A9 18                             lda #$18
08280 D0 7F                     SBlasJ: bne BlstSJp             ;unconditional branch to load rest of reg contents
08282                           
08282                           PlayPowerUpGrab:
08282 A9 36                             lda #$36                    ;load length of power-up grab sound
08284 8D BD 07                          sta Squ2_SfxLenCounter
08287                           
08287                           ContinuePowerUpGrab:   
08287 AD BD 07                          lda Squ2_SfxLenCounter      ;load frequency reg based on length left over
0828A 4A                                lsr                         ;divide by 2
0828B B0 0B                             bcs DecrementSfx2Length     ;alter frequency every other frame
0828D A8                                tay
0828E B9 09 82                          lda PowerUpGrabFreqData-1,y ;use length left over / 2 for frequency offset
08291 A2 5D                             ldx #$5d                    ;store reg contents of power-up grab sound
08293 A0 7F                             ldy #$7f
08295                           
08295                           LoadSqu2Regs:
08295 20 D6 80                          jsr PlaySqu2Sfx
08298                           
08298                           DecrementSfx2Length:
08298 CE BD 07                          dec Squ2_SfxLenCounter   ;decrement length of sfx
0829B D0 0E                             bne ExSfx2
0829D                           
0829D                           EmptySfx2Buffer:
0829D A2 00                             ldx #$00                ;initialize square 2's sound effects buffer
0829F 86 F2                             stx Square2SoundBuffer
082A1                           
082A1                           StopSquare2Sfx:
082A1 A2 0D                             ldx #$0d                ;stop playing the sfx
082A3 8E 15 40                          stx SND_MASTERCTRL_REG 
082A6 A2 0F                             ldx #$0f
082A8 8E 15 40                          stx SND_MASTERCTRL_REG
082AB 60                        ExSfx2: rts
082AC                           
082AC                           Square2SfxHandler:
082AC A5 F2                             lda Square2SoundBuffer ;special handling for the 1-up sound to keep it
082AE 29 40                             and #Sfx_ExtraLife     ;from being interrupted by other sounds on square 2
082B0 D0 65                             bne ContinueExtraLife
082B2 A4 FE                             ldy Square2SoundQueue  ;check for sfx in queue
082B4 F0 20                             beq CheckSfx2Buffer
082B6 84 F2                             sty Square2SoundBuffer ;if found, put in buffer and check for the following
082B8 30 3E                             bmi PlayBowserFall     ;bowser fall
082BA 46 FE                             lsr Square2SoundQueue
082BC B0 8A                             bcs PlayCoinGrab       ;coin grab
082BE 46 FE                             lsr Square2SoundQueue
082C0 B0 6A                             bcs PlayGrowPowerUp    ;power-up reveal
082C2 46 FE                             lsr Square2SoundQueue
082C4 B0 6A                             bcs PlayGrowVine       ;vine grow
082C6 46 FE                             lsr Square2SoundQueue
082C8 B0 A0                             bcs PlayBlast          ;fireworks/gunfire
082CA 46 FE                             lsr Square2SoundQueue
082CC B0 80                             bcs PlayTimerTick      ;timer tick
082CE 46 FE                             lsr Square2SoundQueue
082D0 B0 B0                             bcs PlayPowerUpGrab    ;power-up grab
082D2 46 FE                             lsr Square2SoundQueue
082D4 B0 3C                             bcs PlayExtraLife      ;1-up
082D6                           
082D6                           CheckSfx2Buffer:
082D6 A5 F2                             lda Square2SoundBuffer   ;check for sfx in buffer
082D8 F0 17                             beq ExS2H                ;if not found, exit sub
082DA 30 27                             bmi ContinueBowserFall   ;bowser fall
082DC 4A                                lsr
082DD B0 13                             bcs Cont_CGrab_TTick     ;coin grab
082DF 4A                                lsr
082E0 B0 5D                             bcs ContinueGrowItems    ;power-up reveal
082E2 4A                                lsr
082E3 B0 5A                             bcs ContinueGrowItems    ;vine grow
082E5 4A                                lsr
082E6 B0 8D                             bcs ContinueBlast        ;fireworks/gunfire
082E8 4A                                lsr
082E9 B0 07                             bcs Cont_CGrab_TTick     ;timer tick
082EB 4A                                lsr
082EC B0 99                             bcs ContinuePowerUpGrab  ;power-up grab
082EE 4A                                lsr
082EF B0 26                             bcs ContinueExtraLife    ;1-up
082F1 60                        ExS2H:  rts
082F2                           
082F2                           Cont_CGrab_TTick:
082F2 4C 5C 82                          jmp ContinueCGrabTTick
082F5                           
082F5                           JumpToDecLength2:
082F5 4C 98 82                          jmp DecrementSfx2Length
082F8                           
082F8                           PlayBowserFall:    
082F8 A9 38                              lda #$38                ;load length of bowser defeat sound
082FA 8D BD 07                           sta Squ2_SfxLenCounter
082FD A0 C4                              ldy #$c4                ;load contents of reg for bowser defeat sound
082FF A9 18                              lda #$18
08301 D0 0B                     BlstSJp: bne PBFRegs
08303                           
08303                           ContinueBowserFall:
08303 AD BD 07                            lda Squ2_SfxLenCounter   ;check for almost near the end
08306 C9 08                               cmp #$08
08308 D0 8E                               bne DecrementSfx2Length
0830A A0 A4                               ldy #$a4                 ;if so, load the rest of reg contents for bowser defeat sound
0830C A9 5A                               lda #$5a
0830E A2 9F                     PBFRegs:  ldx #$9f                 ;the fireworks/gunfire sound shares part of reg contents here
08310 D0 83                     EL_LRegs: bne LoadSqu2Regs         ;this is an unconditional branch outta here
08312                           
08312                           PlayExtraLife:
08312 A9 30                             lda #$30                  ;load length of 1-up sound
08314 8D BD 07                          sta Squ2_SfxLenCounter
08317                           
08317                           ContinueExtraLife:
08317 AD BD 07                            lda Squ2_SfxLenCounter   
0831A A2 03                               ldx #$03                  ;load new tones only every eight frames
0831C 4A                        DivLLoop: lsr
0831D B0 D6                               bcs JumpToDecLength2      ;if any bits set here, branch to dec the length
0831F CA                                  dex
08320 D0 FA                               bne DivLLoop              ;do this until all bits checked, if none set, continue
08322 A8                                  tay
08323 B9 03 82                            lda ExtraLifeFreqData-1,y ;load our reg contents
08326 A2 82                               ldx #$82
08328 A0 7F                               ldy #$7f
0832A D0 E4                               bne EL_LRegs              ;unconditional branch
0832C                           
0832C                           PlayGrowPowerUp:
0832C A9 10                             lda #$10                ;load length of power-up reveal sound
0832E D0 02                             bne GrowItemRegs
08330                           
08330                           PlayGrowVine:
08330 A9 20                             lda #$20                ;load length of vine grow sound
08332                           
08332                           GrowItemRegs:
08332 8D BD 07                          sta Squ2_SfxLenCounter   
08335 A9 7F                             lda #$7f                  ;load contents of reg for both sounds directly
08337 8D 05 40                          sta SND_SQUARE2_REG+1
0833A A9 00                             lda #$00                  ;start secondary counter for both sounds
0833C 8D BE 07                          sta Sfx_SecondaryCounter
0833F                           
0833F                           ContinueGrowItems:
0833F EE BE 07                          inc Sfx_SecondaryCounter  ;increment secondary counter for both sounds
08342 AD BE 07                          lda Sfx_SecondaryCounter  ;this sound doesn't decrement the usual counter
08345 4A                                lsr                       ;divide by 2 to get the offset
08346 A8                                tay
08347 CC BD 07                          cpy Squ2_SfxLenCounter    ;have we reached the end yet?
0834A F0 0C                             beq StopGrowItems         ;if so, branch to jump, and stop playing sounds
0834C A9 9D                             lda #$9d                  ;load contents of other reg directly
0834E 8D 04 40                          sta SND_SQUARE2_REG
08351 B9 28 82                          lda PUp_VGrow_FreqData,y  ;use secondary counter / 2 as offset for frequency regs
08354 20 D9 80                          jsr SetFreq_Squ2
08357 60                                rts
08358                           
08358                           StopGrowItems:
08358 4C 9D 82                          jmp EmptySfx2Buffer       ;branch to stop playing sounds
0835B                           
0835B                           WindFreqEnvData:
0835B 37 46 55 64 74 83 93 A2           .db $37, $46, $55, $64, $74, $83, $93, $a2
08363 B1 C0 D0 E0 F1 F1 F2 E2           .db $b1, $c0, $d0, $e0, $f1, $f1, $f2, $e2
0836B E2 C3 A3 84 64 44 35 25           .db $e2, $c3, $a3, $84, $64, $44, $35, $25
08373                           
08373                           BrickShatterFreqData:
08373 01 0E 0E 0D 0B 06 0C 0F           .db $01, $0e, $0e, $0d, $0b, $06, $0c, $0f
0837B 0A 09 03 0D 08 0D 06 0C           .db $0a, $09, $03, $0d, $08, $0d, $06, $0c
08383                           
08383                           SkidSfxFreqData:
08383 47 49 42 4A 43 4B                 .db $47, $49, $42, $4a, $43, $4b
08389                           
08389                           PlaySkidSfx:
08389 84 F3                             sty NoiseSoundBuffer
0838B A9 06                             lda #$06
0838D 8D BF 07                          sta Noise_SfxLenCounter
08390                           
08390                           ContinueSkidSfx:
08390 AD BF 07                          lda Noise_SfxLenCounter
08393 A8                                tay
08394 B9 82 83                          lda SkidSfxFreqData-1,y
08397 8D 0A 40                          sta SND_TRIANGLE_REG+2
0839A A9 18                             lda #$18
0839C 8D 08 40                          sta SND_TRIANGLE_REG
0839F 8D 0B 40                          sta SND_TRIANGLE_REG+3
083A2 D0 1F                             bne DecrementSfx3Length
083A4                           
083A4                           PlayBrickShatter:
083A4 84 F3                             sty NoiseSoundBuffer
083A6 A9 20                             lda #$20                 ;load length of brick shatter sound
083A8 8D BF 07                          sta Noise_SfxLenCounter
083AB                           
083AB                           ContinueBrickShatter:
083AB AD BF 07                          lda Noise_SfxLenCounter  
083AE 4A                                lsr                         ;divide by 2 and check for bit set to use offset
083AF 90 12                             bcc DecrementSfx3Length
083B1 A8                                tay
083B2 BE 73 83                          ldx BrickShatterFreqData,y  ;load reg contents of brick shatter sound
083B5 B9 EA 8E                          lda BrickShatterEnvData,y
083B8                           
083B8                           PlayNoiseSfx:
083B8 8D 0C 40                          sta SND_NOISE_REG        ;play the sfx
083BB 8E 0E 40                          stx SND_NOISE_REG+2
083BE A9 18                             lda #$18
083C0 8D 0F 40                          sta SND_NOISE_REG+3
083C3                           
083C3                           DecrementSfx3Length:
083C3 CE BF 07                          dec Noise_SfxLenCounter  ;decrement length of sfx
083C6 D0 0E                             bne ExSfx3
083C8 A9 F0                             lda #$f0                 ;if done, stop playing the sfx
083CA 8D 0C 40                          sta SND_NOISE_REG
083CD A9 00                             lda #$00
083CF 8D 08 40                          sta SND_TRIANGLE_REG
083D2 A9 00                             lda #$00
083D4 85 F3                             sta NoiseSoundBuffer
083D6 60                        ExSfx3: rts
083D7                           
083D7                           NoiseSfxHandler:
083D7 A5 F3                             lda NoiseSoundBuffer
083D9 30 B5                             bmi ContinueSkidSfx
083DB A4 FD                             ldy NoiseSoundQueue
083DD 30 AA                             bmi PlaySkidSfx
083DF 46 FD                             lsr NoiseSoundQueue
083E1 B0 C1                             bcs PlayBrickShatter
083E3 4A                                lsr
083E4 B0 C5                             bcs ContinueBrickShatter
083E6 46 FD                             lsr NoiseSoundQueue
083E8 B0 0B                             bcs PlayBowserFlame
083EA 4A                                lsr
083EB B0 0F                             bcs ContinueBowserFlame
083ED 4A                                lsr
083EE B0 1F                             bcs ContinueWindSfx
083F0 46 FD                             lsr NoiseSoundQueue
083F2 B0 14                             bcs PlayWindSfx
083F4 60                                rts
083F5                           
083F5                           PlayBowserFlame:
083F5 84 F3                             sty NoiseSoundBuffer
083F7 A9 40                             lda #$40                    ;load length of bowser flame sound
083F9 8D BF 07                          sta Noise_SfxLenCounter
083FC                           
083FC                           ContinueBowserFlame:
083FC AD BF 07                          lda Noise_SfxLenCounter
083FF 4A                                lsr
08400 A8                                tay
08401 A2 0F                             ldx #$0f                    ;load reg contents of bowser flame sound
08403 B9 C9 8E                          lda BowserFlameEnvData-1,y
08406                           WindBranch:
08406 D0 B0                             bne PlayNoiseSfx            ;unconditional branch here
08408                           
08408                           PlayWindSfx:
08408 84 F3                             sty NoiseSoundBuffer
0840A A9 C0                             lda #$c0
0840C 8D BF 07                          sta Noise_SfxLenCounter
0840F                           ContinueWindSfx:
0840F 46 FD                             lsr NoiseSoundQueue         ;get bit for the wind sfx, note that it must
08411 90 C3                             bcc ExSfx3                  ;be continuously set in order for it to play
08413 AD BF 07                          lda Noise_SfxLenCounter
08416 4A                                lsr
08417 4A                                lsr                         ;divide length counter by 8
08418 4A                                lsr
08419 A8                                tay
0841A B9 5B 83                          lda WindFreqEnvData,y
0841D 29 0F                             and #$0f                    ;use lower nybble as frequency data
0841F 09 10                             ora #$10
08421 AA                                tax
08422 B9 5B 83                          lda WindFreqEnvData,y       ;use upper nybble as envelope data
08425 4A                                lsr
08426 4A                                lsr
08427 4A                                lsr
08428 4A                                lsr
08429 09 10                             ora #$10
0842B D0 D9                             bne WindBranch              ;unconditional branch
0842D                           
0842D                           ;--------------------------------
0842D                           
0842D                           ContinueMusic:
0842D 4C DB 84                          jmp HandleSquare2Music  ;if we have music, start with square 2 channel
08430                           
08430                           MusicHandler:
08430 A5 FC                             lda EventMusicQueue     ;check event music queue
08432 D0 0C                             bne LoadEventMusic
08434 A5 FB                             lda AreaMusicQueue      ;check area music queue
08436 D0 31                             bne LoadAreaMusic
08438 AD B1 07                          lda EventMusicBuffer    ;check both buffers
0843B 05 F4                             ora AreaMusicBuffer
0843D D0 EE                             bne ContinueMusic 
0843F 60                                rts                     ;no music, then leave
08440                           
08440                           LoadEventMusic:
08440 8D B1 07                             sta EventMusicBuffer      ;copy event music queue contents to buffer
08443 C9 01                                cmp #DeathMusic           ;is it death music?
08445 D0 06                                bne NoStopSfx             ;if not, jump elsewhere
08447 20 D7 81                             jsr StopSquare1Sfx        ;stop sfx in square 1 and 2
0844A 20 A1 82                             jsr StopSquare2Sfx        ;but clear only square 1's sfx buffer
0844D A0 32                     NoStopSfx: ldy #$32                  ;start counter used only by victory music
0844F 8C 1D 06                             sty PatternNumber
08452 A6 F4                                ldx AreaMusicBuffer
08454 8E C5 07                             stx AreaMusicBuffer_Alt   ;save current area music buffer to be re-obtained later
08457 A0 00                                ldy #$00
08459 8C C4 07                             sty NoteLengthTblAdder    ;default value for additional length byte offset
0845C 84 F4                                sty AreaMusicBuffer       ;clear area music buffer
0845E C9 40                                cmp #TimeRunningOutMusic  ;is it time running out music?
08460 D0 30                                bne FindEventMusicHeader
08462 A2 08                                ldx #$08                  ;load offset to be added to length byte of header
08464 8E C4 07                             stx NoteLengthTblAdder
08467 D0 29                                bne FindEventMusicHeader  ;unconditional branch
08469                           
08469                           LoadAreaMusic:
08469 C9 04                              cmp #$04                  ;is it underground music?
0846B D0 03                              bne NoStop1               ;no, do not stop square 1 sfx
0846D 20 D7 81                           jsr StopSquare1Sfx
08470 A0 10                     NoStop1: ldy #$10                  ;start counter used only by ground level music
08472 8C C7 07                  GMLoopB: sty GroundMusicHeaderOfs
08475                           
08475                           HandleAreaMusicLoopB:
08475 A0 00                              ldy #$00                  ;clear event music buffer
08477 8C B1 07                           sty EventMusicBuffer
0847A 85 F4                              sta AreaMusicBuffer       ;copy area music queue contents to buffer
0847C C9 01                              cmp #$01                  ;is it ground level music?
0847E D0 0E                              bne FindAreaMusicHeader
08480 EE C7 07                           inc GroundMusicHeaderOfs  ;increment but only if playing ground level music
08483 AC C7 07                           ldy GroundMusicHeaderOfs  ;is it time to loopback ground level music?
08486 C0 32                              cpy #$32
08488 D0 0C                              bne LoadHeader            ;branch ahead with alternate offset
0848A A0 11                              ldy #$11
0848C D0 E4                              bne GMLoopB               ;unconditional branch
0848E                           
0848E                           FindAreaMusicHeader:
0848E A0 08                             ldy #$08                   ;load Y for offset of area music
08490 84 F7                             sty MusicOffset_Square2    ;residual instruction here
08492                           
08492                           FindEventMusicHeader:
08492 C8                                iny                       ;increment Y pointer based on previously loaded queue contents
08493 4A                                lsr                       ;bit shift and increment until we find a set bit for music
08494 90 FC                             bcc FindEventMusicHeader
08496                           
08496                           LoadHeader:
08496 B9 D6 86                          lda MusicHeaderOffsetData,y  ;load offset for header
08499 A8                                tay
0849A B9 D7 86                          lda MusicHeaderData,y        ;now load the header
0849D 85 F0                             sta NoteLenLookupTblOfs
0849F B9 D8 86                          lda MusicHeaderData+1,y
084A2 85 F5                             sta MusicDataLow
084A4 B9 D9 86                          lda MusicHeaderData+2,y
084A7 85 F6                             sta MusicDataHigh
084A9 B9 DA 86                          lda MusicHeaderData+3,y
084AC 85 F9                             sta MusicOffset_Triangle
084AE B9 DB 86                          lda MusicHeaderData+4,y
084B1 85 F8                             sta MusicOffset_Square1
084B3 B9 DC 86                          lda MusicHeaderData+5,y
084B6 8D B0 07                          sta MusicOffset_Noise
084B9 8D C1 07                          sta NoiseDataLoopbackOfs
084BC A9 01                             lda #$01                     ;initialize music note counters
084BE 8D B4 07                          sta Squ2_NoteLenCounter
084C1 8D B6 07                          sta Squ1_NoteLenCounter
084C4 8D B9 07                          sta Tri_NoteLenCounter
084C7 8D BA 07                          sta Noise_BeatLenCounter
084CA A9 00                             lda #$00                     ;initialize music data offset for square 2
084CC 85 F7                             sta MusicOffset_Square2
084CE 8D CA 07                          sta AltRegContentFlag        ;initialize alternate control reg data used by square 1
084D1 A9 0B                             lda #$0b                     ;disable triangle channel and reenable it
084D3 8D 15 40                          sta SND_MASTERCTRL_REG
084D6 A9 0F                             lda #$0f
084D8 8D 15 40                          sta SND_MASTERCTRL_REG
084DB                           
084DB                           HandleSquare2Music:
084DB CE B4 07                          dec Squ2_NoteLenCounter  ;decrement square 2 note length
084DE D0 69                             bne MiscSqu2MusicTasks   ;is it time for more data?  if not, branch to end tasks
084E0 A4 F7                             ldy MusicOffset_Square2  ;increment square 2 music offset and fetch data
084E2 E6 F7                             inc MusicOffset_Square2
084E4 B1 F5                             lda (MusicData),y
084E6 F0 04                             beq EndOfMusicData       ;if zero, the data is a null terminator
084E8 10 47                             bpl Squ2NoteHandler      ;if non-negative, data is a note
084EA D0 39                             bne Squ2LengthHandler    ;otherwise it is length data
084EC                           
084EC                           EndOfMusicData:
084EC AD B1 07                          lda EventMusicBuffer     ;check secondary buffer for time running out music
084EF C9 40                             cmp #TimeRunningOutMusic
084F1 D0 05                             bne NotTRO
084F3 AD C5 07                          lda AreaMusicBuffer_Alt  ;load previously saved contents of primary buffer
084F6 D0 1D                             bne MusicLoopBack        ;and start playing the song again if there is one
084F8 29 04                     NotTRO: and #VictoryMusic        ;check for victory music (the only secondary that loops)
084FA D0 1C                             bne VictoryMLoopBack
084FC A5 F4                             lda AreaMusicBuffer      ;check primary buffer for any music except pipe intro
084FE 29 5F                             and #%01011111
08500 D0 13                             bne MusicLoopBack        ;if any area music except pipe intro, music loops
08502                           StopMusic:
08502 A9 00                             lda #$00                 ;clear primary and secondary buffers and initialize
08504 85 F4                             sta AreaMusicBuffer      ;control regs of square and triangle channels
08506 8D B1 07                          sta EventMusicBuffer
08509 8D 08 40                          sta SND_TRIANGLE_REG
0850C A9 90                             lda #$90    
0850E 8D 00 40                          sta SND_SQUARE1_REG
08511 8D 04 40                          sta SND_SQUARE2_REG
08514 60                                rts
08515                           
08515                           MusicLoopBack:
08515 4C 75 84                          jmp HandleAreaMusicLoopB
08518                           
08518                           VictoryMLoopBack:
08518 EE 1D 06                          inc PatternNumber   ;increment counter for next part of victory music
0851B AC 1D 06                          ldy PatternNumber
0851E C0 3D                             cpy #$3d            ;if counter reached a certain point, end song
08520 F0 E0                             beq StopMusic
08522 4C 96 84                          jmp LoadHeader      ;otherwise play the next part of the song
08525                           
08525                           Squ2LengthHandler:
08525 20 85 86                          jsr ProcessLengthData    ;store length of note
08528 8D B3 07                          sta Squ2_NoteLenBuffer
0852B A4 F7                             ldy MusicOffset_Square2  ;fetch another byte (MUST NOT BE LENGTH BYTE!)
0852D E6 F7                             inc MusicOffset_Square2
0852F B1 F5                             lda (MusicData),y
08531                           
08531                           Squ2NoteHandler:
08531 A6 F2                               ldx Square2SoundBuffer     ;is there a sound playing on this channel?
08533 D0 0E                               bne SkipFqL1
08535 20 D9 80                            jsr SetFreq_Squ2           ;no, then play the note
08538 F0 03                               beq Rest                   ;check to see if note is rest
0853A 20 92 86                            jsr LoadControlRegs        ;if not, load control regs for square 2
0853D 8D B5 07                  Rest:     sta Squ2_EnvelopeDataCtrl  ;save contents of A
08540 20 CF 80                            jsr Dump_Sq2_Regs          ;dump X and Y into square 2 control regs
08543 AD B3 07                  SkipFqL1: lda Squ2_NoteLenBuffer     ;save length in square 2 note counter
08546 8D B4 07                            sta Squ2_NoteLenCounter
08549                           
08549                           MiscSqu2MusicTasks:
08549 A5 F2                                lda Square2SoundBuffer     ;is there a sound playing on square 2?
0854B D0 1A                                bne HandleSquare1Music
0854D AD B1 07                             lda EventMusicBuffer       ;check for death music or d4 set on secondary buffer
08550 29 91                                and #%10010001             ;note that regs for death music or d4 are loaded by default
08552 D0 13                                bne HandleSquare1Music
08554 AC B5 07                             ldy Squ2_EnvelopeDataCtrl  ;check for contents saved from LoadControlRegs
08557 F0 03                                beq NoDecEnv1
08559 CE B5 07                             dec Squ2_EnvelopeDataCtrl  ;decrement unless already zero
0855C 20 B6 86                  NoDecEnv1: jsr LoadEnvelopeData       ;do a load of envelope data to replace default
0855F 8D 04 40                             sta SND_SQUARE2_REG        ;based on offset set by first load unless playing
08562 A2 7F                                ldx #$7f                   ;death music or d4 set on secondary buffer
08564 8E 05 40                             stx SND_SQUARE2_REG+1
08567                           
08567                           HandleSquare1Music:
08567 A4 F8                             ldy MusicOffset_Square1    ;is there a nonzero offset here?
08569 F0 5A                             beq HandleTriangleMusic    ;if not, skip ahead to the triangle channel
0856B CE B6 07                          dec Squ1_NoteLenCounter    ;decrement square 1 note length
0856E D0 32                             bne MiscSqu1MusicTasks     ;is it time for more data?
08570                           
08570                           FetchSqu1MusicData:
08570 A4 F8                             ldy MusicOffset_Square1    ;increment square 1 music offset and fetch data
08572 E6 F8                             inc MusicOffset_Square1
08574 B1 F5                             lda (MusicData),y
08576 D0 0F                             bne Squ1NoteHandler        ;if nonzero, then skip this part
08578 A9 83                             lda #$83
0857A 8D 00 40                          sta SND_SQUARE1_REG        ;store some data into control regs for square 1
0857D A9 94                             lda #$94                   ;and fetch another byte of data, used to give
0857F 8D 01 40                          sta SND_SQUARE1_REG+1      ;death music its unique sound
08582 8D CA 07                          sta AltRegContentFlag
08585 D0 E9                             bne FetchSqu1MusicData     ;unconditional branch
08587                           
08587                           Squ1NoteHandler:
08587 20 7F 86                             jsr AlternateLengthHandler
0858A 8D B6 07                             sta Squ1_NoteLenCounter    ;save contents of A in square 1 note counter
0858D A4 F1                                ldy Square1SoundBuffer     ;is there a sound playing on square 1?
0858F D0 34                                bne HandleTriangleMusic
08591 8A                                   txa
08592 29 3E                                and #%00111110             ;change saved data to appropriate note format
08594 20 BB 80                             jsr SetFreq_Squ1           ;play the note
08597 F0 03                                beq SkipCtrlL
08599 20 92 86                             jsr LoadControlRegs
0859C 8D B7 07                  SkipCtrlL: sta Squ1_EnvelopeDataCtrl  ;save envelope offset
0859F 20 B1 80                             jsr Dump_Squ1_Regs
085A2                           
085A2                           MiscSqu1MusicTasks:
085A2 A5 F1                                   lda Square1SoundBuffer     ;is there a sound playing on square 1?
085A4 D0 1F                                   bne HandleTriangleMusic
085A6 AD B1 07                                lda EventMusicBuffer       ;check for death music or d4 set on secondary buffer
085A9 29 91                                   and #%10010001
085AB D0 0E                                   bne DeathMAltReg
085AD AC B7 07                                ldy Squ1_EnvelopeDataCtrl  ;check saved envelope offset
085B0 F0 03                                   beq NoDecEnv2
085B2 CE B7 07                                dec Squ1_EnvelopeDataCtrl  ;decrement unless already zero
085B5 20 B6 86                  NoDecEnv2:    jsr LoadEnvelopeData       ;do a load of envelope data
085B8 8D 00 40                                sta SND_SQUARE1_REG        ;based on offset set by first load
085BB AD CA 07                  DeathMAltReg: lda AltRegContentFlag      ;check for alternate control reg data
085BE D0 02                                   bne DoAltLoad
085C0 A9 7F                                   lda #$7f                   ;load this value if zero, the alternate value
085C2 8D 01 40                  DoAltLoad:    sta SND_SQUARE1_REG+1      ;if nonzero, and let's move on
085C5                           
085C5                           HandleTriangleMusic:
085C5 A5 F9                             lda MusicOffset_Triangle
085C7 CE B9 07                          dec Tri_NoteLenCounter    ;decrement triangle note length
085CA D0 54                             bne HandleNoiseMusic      ;is it time for more data?
085CC A4 F9                             ldy MusicOffset_Triangle  ;increment triangle music offset and fetch data
085CE E6 F9                             inc MusicOffset_Triangle
085D0 B1 F5                             lda (MusicData),y
085D2 F0 49                             beq LoadTriCtrlReg        ;if zero, skip all this and move on to noise 
085D4 10 13                             bpl TriNoteHandler        ;if non-negative, data is note
085D6 20 85 86                          jsr ProcessLengthData     ;otherwise, it is length data
085D9 8D B8 07                          sta Tri_NoteLenBuffer     ;save contents of A
085DC A9 1F                             lda #$1f
085DE 8D 08 40                          sta SND_TRIANGLE_REG      ;load some default data for triangle control reg
085E1 A4 F9                             ldy MusicOffset_Triangle  ;fetch another byte
085E3 E6 F9                             inc MusicOffset_Triangle
085E5 B1 F5                             lda (MusicData),y
085E7 F0 34                             beq LoadTriCtrlReg        ;check once more for nonzero data
085E9                           
085E9                           TriNoteHandler:
085E9 20 DD 80                            jsr SetFreq_Tri
085EC AE B8 07                            ldx Tri_NoteLenBuffer   ;save length in triangle note counter
085EF 8E B9 07                            stx Tri_NoteLenCounter
085F2 AD B1 07                            lda EventMusicBuffer
085F5 29 6E                               and #%01101110          ;check for death music or d4 set on secondary buffer
085F7 D0 06                               bne NotDOrD4            ;if playing any other secondary, skip primary buffer check
085F9 A5 F4                               lda AreaMusicBuffer     ;check primary buffer for water or castle level music
085FB 29 0A                               and #%00001010
085FD F0 21                               beq HandleNoiseMusic    ;if playing any other primary, or death or d4, go on to noise routine
085FF 8A                        NotDOrD4: txa                     ;if playing water or castle music or any secondary
08600 C9 12                               cmp #$12                ;besides death music or d4 set, check length of note
08602 B0 17                               bcs LongN
08604 AD B1 07                            lda EventMusicBuffer    ;check for victory music if not playing a long note
08607 C9 04                               cmp #VictoryMusic
08609 D0 04                               bne NotVictoryMusic     ;go to check for win castle music if not
0860B A9 18                               lda #$18                ;otherwise load value $18 for victory music
0860D D0 0E                               bne LoadTriCtrlReg
0860F                           NotVictoryMusic:
0860F 29 08                               and #EndOfCastleMusic   ;check for win castle music again if not playing a long note
08611 F0 04                               beq MediN
08613 A9 0F                               lda #$0f                ;load value $0f if playing the win castle music and playing a short
08615 D0 06                               bne LoadTriCtrlReg      ;note, load value $1f if playing water or castle level music or any
08617 A9 1F                     MediN:    lda #$1f                ;secondary besides death and d4 except win castle or win castle and playing
08619 D0 02                               bne LoadTriCtrlReg      ;a short note, and load value $ff if playing a long note on water, castle
0861B A9 FF                     LongN:    lda #$ff                ;or any secondary (including win castle) except death and d4
0861D                           
0861D                           LoadTriCtrlReg:           
0861D 8D 08 40                          sta SND_TRIANGLE_REG      ;save final contents of A into control reg for triangle
08620                           
08620                           HandleNoiseMusic:
08620 AD B1 07                          lda EventMusicBuffer      ;check if playing victory music
08623 C9 04                             cmp #VictoryMusic
08625 F0 06                             beq PlayNoiseMusic        ;if so, play noise
08627 A5 F4                             lda AreaMusicBuffer       ;check if playing underground or castle music
08629 29 F3                             and #%11110011
0862B F0 51                             beq ExitMusicHandler      ;if so, skip the noise routine
0862D                           PlayNoiseMusic:
0862D CE BA 07                          dec Noise_BeatLenCounter  ;decrement noise beat length
08630 D0 4C                             bne ExitMusicHandler      ;is it time for more data?
08632                           
08632                           FetchNoiseBeatData:
08632 AC B0 07                          ldy MusicOffset_Noise       ;increment noise beat offset and fetch data
08635 EE B0 07                          inc MusicOffset_Noise
08638 B1 F5                             lda (MusicData),y           ;get noise beat data, if nonzero, branch to handle
0863A D0 08                             bne NoiseBeatHandler
0863C AD C1 07                          lda NoiseDataLoopbackOfs    ;if data is zero, reload original noise beat offset
0863F 8D B0 07                          sta MusicOffset_Noise       ;and loopback next time around
08642 D0 EE                             bne FetchNoiseBeatData      ;unconditional branch
08644                           
08644                           NoiseBeatHandler:
08644 20 7F 86                          jsr AlternateLengthHandler
08647 8D BA 07                          sta Noise_BeatLenCounter    ;store length in noise beat counter
0864A 8A                                txa
0864B 29 3E                             and #%00111110              ;reload data and erase length bits
0864D F0 24                             beq SilentBeat              ;if no beat data, silence
0864F C9 30                             cmp #$30                    ;check the beat data and play the appropriate
08651 F0 18                             beq LongBeat                ;noise accordingly
08653 C9 20                             cmp #$20
08655 F0 0C                             beq StrongBeat
08657 29 10                             and #%00010000  
08659 F0 18                             beq SilentBeat
0865B A9 1C                             lda #$1c        ;short beat data
0865D A2 03                             ldx #$03
0865F A0 18                             ldy #$18
08661 D0 12                             bne PlayBeat
08663                           
08663                           StrongBeat:
08663 A9 1C                             lda #$1c        ;strong beat data
08665 A2 0C                             ldx #$0c
08667 A0 18                             ldy #$18
08669 D0 0A                             bne PlayBeat
0866B                           
0866B                           LongBeat:
0866B A9 1C                             lda #$1c        ;long beat data
0866D A2 03                             ldx #$03
0866F A0 58                             ldy #$58
08671 D0 02                             bne PlayBeat
08673                           
08673                           SilentBeat:
08673 A9 10                             lda #$10        ;silence
08675                           
08675                           PlayBeat:
08675 8D 0C 40                          sta SND_NOISE_REG    ;load beat data into noise regs
08678 8E 0E 40                          stx SND_NOISE_REG+2
0867B 8C 0F 40                          sty SND_NOISE_REG+3
0867E                           
0867E                           ExitMusicHandler:
0867E 60                                rts
0867F                           
0867F                           AlternateLengthHandler:
0867F AA                                tax            ;save a copy of original byte into X
08680 6A                                ror            ;save LSB from original byte into carry
08681 8A                                txa            ;reload original byte and rotate three times
08682 2A                                rol            ;turning xx00000x into 00000xxx, with the
08683 2A                                rol            ;bit in carry as the MSB here
08684 2A                                rol
08685                           
08685                           ProcessLengthData:
08685 29 07                             and #%00000111              ;clear all but the three LSBs
08687 18                                clc
08688 65 F0                             adc NoteLenLookupTblOfs     ;add offset loaded from first header byte
0868A 6D C4 07                          adc NoteLengthTblAdder      ;add extra if time running out music
0868D A8                                tay
0868E B9 45 8E                          lda MusicLengthLookupTbl,y  ;load length
08691 60                                rts
08692                           
08692                           LoadControlRegs:
08692 AD B1 07                             lda EventMusicBuffer  ;check secondary buffer for victory music
08695 C9 04                                cmp #VictoryMusic
08697 D0 04                                bne NotVctryM
08699 A9 10                                lda #$10              ;this value is only used for victory music
0869B D0 14                                bne AllMus            ;unconditional branch
0869D 29 08                     NotVctryM: and #EndOfCastleMusic ;check secondary buffer for win castle music
0869F F0 04                                beq NotECstlM
086A1 A9 04                                lda #$04              ;this value is only used for win castle music
086A3 D0 0C                                bne AllMus            ;unconditional branch
086A5 A5 F4                     NotECstlM: lda AreaMusicBuffer
086A7 29 7D                                and #%01111101        ;check primary buffer for water music
086A9 F0 04                                beq WaterMus
086AB A9 08                                lda #$08              ;this is the default value for all other music
086AD D0 02                                bne AllMus
086AF A9 28                     WaterMus:  lda #$28              ;this value is used for water music and all other event music
086B1 A2 82                     AllMus:    ldx #$82              ;load contents of other sound regs for square 2
086B3 A0 7F                                ldy #$7f
086B5 60                                   rts
086B6                           
086B6                           LoadEnvelopeData:
086B6 AD B1 07                          lda EventMusicBuffer           ;check secondary buffer for victory music
086B9 C9 04                             cmp #VictoryMusic
086BB D0 04                             bne LoadEndOfCastleMusEnvData
086BD B9 85 8E                          lda VictoryMusEnvData,y        ;load data from offset for victory music
086C0 60                                rts
086C1                           
086C1                           LoadEndOfCastleMusEnvData:
086C1 29 08                             and #EndOfCastleMusic          ;check secondary buffer for win castle music
086C3 F0 04                             beq LoadUsualEnvData
086C5 B9 96 8E                          lda EndOfCastleMusicEnvData,y  ;load data from offset for win castle music
086C8 60                                rts
086C9                           
086C9                           LoadUsualEnvData:
086C9 A5 F4                             lda AreaMusicBuffer            ;check primary buffer for water music
086CB 29 7D                             and #%01111101
086CD F0 04                             beq LoadWaterEventMusEnvData
086CF B9 9A 8E                          lda AreaMusicEnvData,y         ;load default data from offset for all other music
086D2 60                                rts
086D3                           
086D3                           LoadWaterEventMusEnvData:
086D3 B9 A2 8E                          lda WaterEventMusEnvData,y     ;load data from offset for water music and all other event music
086D6 60                                rts
086D7                           
086D7                           MusicHeaderData:
086D7 CF                          .db DeathMusHdr-MHD
086D8 83                          .db GameOverMusHdr-MHD
086D9 5F                          .db VictoryPart1AHdr-MHD
086DA 8E                          .db WinCastleMusHdr-MHD
086DB 83                          .db GameOverMusHdr-MHD
086DC 47                          .db EndOfLevelMusHdr-MHD
086DD 3C                          .db TimeRunningOutHdr-MHD
086DE 56                          .db SilenceHdr-MHD
086DF                           
086DF 93                          .db GroundLevelPart1Hdr-MHD   ;area music
086E0 88                          .db WaterMusHdr-MHD
086E1 51                          .db UndergroundMusHdr-MHD
086E2 5A                          .db CastleMusHdr-MHD
086E3 41                          .db Star_CloudHdr-MHD
086E4 B7                          .db GroundLevelLeadInHdr-MHD
086E5 41                          .db Star_CloudHdr-MHD
086E6 56                          .db SilenceHdr-MHD
086E7                           
086E7 B7                          .db GroundLevelLeadInHdr-MHD  ;ground level music layout
086E8 93 93                       .db GroundLevelPart1Hdr-MHD, GroundLevelPart1Hdr-MHD
086EA 99 9F 99 A5                 .db GroundLevelPart2AHdr-MHD, GroundLevelPart2BHdr-MHD, GroundLevelPart2AHdr-MHD, GroundLevelPart2CHdr-MHD
086EE 99 9F 99 A5                 .db GroundLevelPart2AHdr-MHD, GroundLevelPart2BHdr-MHD, GroundLevelPart2AHdr-MHD, GroundLevelPart2CHdr-MHD
086F2 AB B1 AB B7                 .db GroundLevelPart3AHdr-MHD, GroundLevelPart3BHdr-MHD, GroundLevelPart3AHdr-MHD, GroundLevelLeadInHdr-MHD
086F6 93 93                       .db GroundLevelPart1Hdr-MHD, GroundLevelPart1Hdr-MHD
086F8 BD C3 BD C9                 .db GroundLevelPart4AHdr-MHD, GroundLevelPart4BHdr-MHD, GroundLevelPart4AHdr-MHD, GroundLevelPart4CHdr-MHD
086FC BD C3 BD C9                 .db GroundLevelPart4AHdr-MHD, GroundLevelPart4BHdr-MHD, GroundLevelPart4AHdr-MHD, GroundLevelPart4CHdr-MHD
08700 AB B1 AB B7                 .db GroundLevelPart3AHdr-MHD, GroundLevelPart3BHdr-MHD, GroundLevelPart3AHdr-MHD, GroundLevelLeadInHdr-MHD
08704 BD C3 BD C9                 .db GroundLevelPart4AHdr-MHD, GroundLevelPart4BHdr-MHD, GroundLevelPart4AHdr-MHD, GroundLevelPart4CHdr-MHD
08708                           
08708 5F 5F 65 5F                 .db VictoryPart1AHdr-MHD, VictoryPart1AHdr-MHD, VictoryPart1BHdr-MHD, VictoryPart1AHdr-MHD ;victory music layout
0870C 6B 7D 6B 7D                 .db VictoryPart2AHdr-MHD, VictoryPart2BHdr-MHD, VictoryPart2AHdr-MHD, VictoryPart2BHdr-MHD
08710 71 6B 77                    .db VictoryPart2CHdr-MHD, VictoryPart2AHdr-MHD, VictoryPart2DHdr-MHD
08713                           
08713                           ;music headers
08713                           ;header format is as follows: 
08713                           ;1 byte - length byte offset
08713                           ;2 bytes -  music data address
08713                           ;1 byte - triangle data offset
08713                           ;1 byte - square 1 data offset
08713                           ;1 byte - noise data offset (not used by secondary music)
08713                             
08713 08 66 8A 27 18            TimeRunningOutHdr:     .db $08, <TimeRunOutMusData, >TimeRunOutMusData, $27, $18
08718 20 AC 87 2E 1A 40         Star_CloudHdr:         .db $20, <Star_CloudMData, >Star_CloudMData, $2e, $1a, $40
0871E 20 A4 8A 3D 21            EndOfLevelMusHdr:      .db $20, <WinLevelMusData, >WinLevelMusData, $3d, $21
08723 20 FB DC 3F 1D            ResidualHeaderData:    .db $20, $fb, $dc, $3f, $1d
08728 18 05 8B 00 00            UndergroundMusHdr:     .db $18, <UndergroundMusData, >UndergroundMusData, $00, $00
0872D 08 10 88 00               SilenceHdr:            .db $08, <SilenceData, >SilenceData, $00
08731 00 98 89 93 62            CastleMusHdr:          .db $00, <CastleMusData, >CastleMusData, $93, $62
08736 30 BC 8C 24 14 77         VictoryPart1AHdr:      .db $30, <VictoryM_P1AData, >VictoryM_P1AData, $24, $14, $77
0873C 30 F1 8C 31 21 42         VictoryPart1BHdr:      .db $30, <VictoryM_P1BData, >VictoryM_P1BData, $31, $21, $42
08742 30 3A 8D 29 1C 7C         VictoryPart2AHdr:      .db $30, <VictoryM_P2AData, >VictoryM_P2AData, $29, $1c, $7c
08748 30 74 8D 31 20 42         VictoryPart2CHdr:      .db $30, <VictoryM_P2CData, >VictoryM_P2CData, $31, $20, $42
0874E 38 BD 8D 06 04 1B         VictoryPart2DHdr:      .db $38, <VictoryM_P2DData, >VictoryM_P2DData, $06, $04, $1b
08754 38 51 8D 20 10 65         VictoryPart2BHdr:      .db $38, <VictoryM_P2BData, >VictoryM_P2BData, $20, $10, $65
0875A 18 39 8A 1E 14            GameOverMusHdr:        .db $18, <GameOverMusData, >GameOverMusData, $1e, $14
0875F 08 46 8B A0 70 68         WaterMusHdr:           .db $08, <WaterMusData, >WaterMusData, $a0, $70, $68
08765 08 45 8C 4C 24            WinCastleMusHdr:       .db $08, <EndOfCastleMusData, >EndOfCastleMusData, $4c, $24
0876A 18 F5 87 2D 1C B8         GroundLevelPart1Hdr:   .db $18, <GroundM_P1Data, >GroundM_P1Data, $2d, $1c, $b8
08770 18 3D 88 20 12 70         GroundLevelPart2AHdr:  .db $18, <GroundM_P2AData, >GroundM_P2AData, $20, $12, $70
08776 18 69 88 1B 10 44         GroundLevelPart2BHdr:  .db $18, <GroundM_P2BData, >GroundM_P2BData, $1b, $10, $44
0877C 18 91 88 11 0A 1C         GroundLevelPart2CHdr:  .db $18, <GroundM_P2CData, >GroundM_P2CData, $11, $0a, $1c
08782 18 B6 88 2D 10 58         GroundLevelPart3AHdr:  .db $18, <GroundM_P3AData, >GroundM_P3AData, $2d, $10, $58
08788 18 CF 88 14 0D 3F         GroundLevelPart3BHdr:  .db $18, <GroundM_P3BData, >GroundM_P3BData, $14, $0d, $3f
0878E 18 ED 88 15 0D 21         GroundLevelLeadInHdr:  .db $18, <GroundMLdInData, >GroundMLdInData, $15, $0d, $21
08794 18 19 89 18 10 7A         GroundLevelPart4AHdr:  .db $18, <GroundM_P4AData, >GroundM_P4AData, $18, $10, $7a
0879A 18 3F 89 19 0F 54         GroundLevelPart4BHdr:  .db $18, <GroundM_P4BData, >GroundM_P4BData, $19, $0f, $54
087A0 18 68 89 1E 12 2B         GroundLevelPart4CHdr:  .db $18, <GroundM_P4CData, >GroundM_P4CData, $1e, $12, $2b
087A6 18 66 89 1E 0F 2D         DeathMusHdr:           .db $18, <DeathMusData, >DeathMusData, $1e, $0f, $2d
087AC                           
087AC                           ;--------------------------------
087AC                           
087AC                           ;MUSIC DATA
087AC                           ;square 2/triangle format
087AC                           ;d7 - length byte flag (0-note, 1-length)
087AC                           ;if d7 is set to 0 and d6-d0 is nonzero:
087AC                           ;d6-d0 - note offset in frequency look-up table (must be even)
087AC                           ;if d7 is set to 1:
087AC                           ;d6-d3 - unused
087AC                           ;d2-d0 - length offset in length look-up table
087AC                           ;value of $00 in square 2 data is used as null terminator, affects all sound channels
087AC                           ;value of $00 in triangle data causes routine to skip note
087AC                           
087AC                           ;square 1 format
087AC                           ;d7-d6, d0 - length offset in length look-up table (bit order is d0,d7,d6)
087AC                           ;d5-d1 - note offset in frequency look-up table
087AC                           ;value of $00 in square 1 data is flag alternate control reg data to be loaded
087AC                           
087AC                           ;noise format
087AC                           ;d7-d6, d0 - length offset in length look-up table (bit order is d0,d7,d6)
087AC                           ;d5-d4 - beat type (0 - rest, 1 - short, 2 - strong, 3 - long)
087AC                           ;d3-d1 - unused
087AC                           ;value of $00 in noise data is used as null terminator, affects only noise
087AC                           
087AC                           ;all music data is organized into sections (unless otherwise stated):
087AC                           ;square 2, square 1, triangle, noise
087AC                           
087AC                           Star_CloudMData:
087AC 84 2C 2C 2C 82 04 2C 04..       .db $84, $2c, $2c, $2c, $82, $04, $2c, $04, $85, $2c, $84, $2c, $2c
087B9 2A 2A 2A 82 04 2A 04 85..       .db $2a, $2a, $2a, $82, $04, $2a, $04, $85, $2a, $84, $2a, $2a, $00
087C6                           
087C6 1F 1F 1F 98 1F 1F 98 9E..       .db $1f, $1f, $1f, $98, $1f, $1f, $98, $9e, $98, $1f
087D0 1D 1D 1D 94 1D 1D 94 9C..       .db $1d, $1d, $1d, $94, $1d, $1d, $94, $9c, $94, $1d
087DA                           
087DA 86 18 85 26 30 84 04 26..       .db $86, $18, $85, $26, $30, $84, $04, $26, $30
087E3 86 14 85 22 2C 84 04 22..       .db $86, $14, $85, $22, $2c, $84, $04, $22, $2c
087EC                           
087EC 21 D0 C4 D0 31 D0 C4 D0..       .db $21, $d0, $c4, $d0, $31, $d0, $c4, $d0, $00
087F5                           
087F5                           GroundM_P1Data:
087F5 85 2C 22 1C 84 26 2A 82..       .db $85, $2c, $22, $1c, $84, $26, $2a, $82, $28, $26, $04
08800 87 22 34 3A 82 40 04 36..       .db $87, $22, $34, $3a, $82, $40, $04, $36, $84, $3a, $34
0880B 82 2C 30 85 2A                  .db $82, $2c, $30, $85, $2a
08810                           
08810                           SilenceData:
08810 00                              .db $00
08811                           
08811 5D 55 4D 15 19 96 15 D5..       .db $5d, $55, $4d, $15, $19, $96, $15, $d5, $e3, $eb
0881B 2D A6 2B 27 9C 9E 59            .db $2d, $a6, $2b, $27, $9c, $9e, $59
08822                           
08822 85 22 1C 14 84 1E 22 82..       .db $85, $22, $1c, $14, $84, $1e, $22, $82, $20, $1e, $04, $87
0882E 1C 2C 34 82 36 04 30 34..       .db $1c, $2c, $34, $82, $36, $04, $30, $34, $04, $2c, $04, $26
0883A 2A 85 22                        .db $2a, $85, $22
0883D                           
0883D                           GroundM_P2AData:
0883D 84 04 82 3A 38 36 32 04..       .db $84, $04, $82, $3a, $38, $36, $32, $04, $34
08846 04 24 26 2C 04 26 2C 30..       .db $04, $24, $26, $2c, $04, $26, $2c, $30, $00
0884F                           
0884F 05 B4 B2 B0 2B AC 84            .db $05, $b4, $b2, $b0, $2b, $ac, $84
08856 9C 9E A2 84 94 9C 9E            .db $9c, $9e, $a2, $84, $94, $9c, $9e
0885D                           
0885D 85 14 22 84 2C 85 1E            .db $85, $14, $22, $84, $2c, $85, $1e
08864 82 2C 84 2C 1E                  .db $82, $2c, $84, $2c, $1e
08869                           
08869                           GroundM_P2BData:
08869 84 04 82 3A 38 36 32 04..       .db $84, $04, $82, $3a, $38, $36, $32, $04, $34
08872 04 64 04 64 86 64 00            .db $04, $64, $04, $64, $86, $64, $00
08879                           
08879 05 B4 B2 B0 2B AC 84            .db $05, $b4, $b2, $b0, $2b, $ac, $84
08880 37 B6 B6 45                     .db $37, $b6, $b6, $45
08884                           
08884 85 14 1C 82 22 84 2C            .db $85, $14, $1c, $82, $22, $84, $2c
0888B 4E 82 4E 84 4E 22               .db $4e, $82, $4e, $84, $4e, $22
08891                           
08891                           GroundM_P2CData:
08891 84 04 85 32 85 30 86 2C..       .db $84, $04, $85, $32, $85, $30, $86, $2c, $04, $00
0889B                           
0889B 05 A4 05 9E 05 9D 85            .db $05, $a4, $05, $9e, $05, $9d, $85
088A2                                 
088A2 84 14 85 24 28 2C 82            .db $84, $14, $85, $24, $28, $2c, $82
088A9 22 84 22 14                     .db $22, $84, $22, $14
088AD                           
088AD 21 D0 C4 D0 31 D0 C4 D0..       .db $21, $d0, $c4, $d0, $31, $d0, $c4, $d0, $00
088B6                           
088B6                           GroundM_P3AData:
088B6 82 2C 84 2C 2C 82 2C 30         .db $82, $2c, $84, $2c, $2c, $82, $2c, $30
088BE 04 34 2C 04 26 86 22 00         .db $04, $34, $2c, $04, $26, $86, $22, $00
088C6                           
088C6 A4 25 25 A4 29 A2 1D 9C..       .db $a4, $25, $25, $a4, $29, $a2, $1d, $9c, $95
088CF                           
088CF                           GroundM_P3BData:
088CF 82 2C 2C 04 2C 04 2C 30..       .db $82, $2c, $2c, $04, $2c, $04, $2c, $30, $85, $34, $04, $04, $00
088DC                           
088DC A4 25 25 A4 A8 63 04            .db $a4, $25, $25, $a4, $a8, $63, $04
088E3                           
088E3                           ;triangle data used by both sections of third part
088E3 85 0E 1A 84 24 85 22 14..       .db $85, $0e, $1a, $84, $24, $85, $22, $14, $84, $0c
088ED                           
088ED                           GroundMLdInData:
088ED 82 34 84 34 34 82 2C 84..       .db $82, $34, $84, $34, $34, $82, $2c, $84, $34, $86, $3a, $04, $00
088FA                           
088FA A0 21 21 A0 21 2B 05 A3         .db $a0, $21, $21, $a0, $21, $2b, $05, $a3
08902                           
08902 82 18 84 18 18 82 18 18..       .db $82, $18, $84, $18, $18, $82, $18, $18, $04, $86, $3a, $22
0890E                           
0890E                           ;noise data used by lead-in and third part sections
0890E 31 90 31 90 31 71 31 90..       .db $31, $90, $31, $90, $31, $71, $31, $90, $90, $90, $00
08919                           
08919                           GroundM_P4AData:
08919 82 34 84 2C 85 22 84 24         .db $82, $34, $84, $2c, $85, $22, $84, $24
08921 82 26 36 04 36 86 26 00         .db $82, $26, $36, $04, $36, $86, $26, $00
08929                           
08929 AC 27 5D 1D 9E 2D AC 9F         .db $ac, $27, $5d, $1d, $9e, $2d, $ac, $9f
08931                           
08931 85 14 82 20 84 22 2C            .db $85, $14, $82, $20, $84, $22, $2c
08938 1E 1E 82 2C 2C 1E 04            .db $1e, $1e, $82, $2c, $2c, $1e, $04
0893F                           
0893F                           GroundM_P4BData:
0893F 87 2A 40 40 40 3A 36            .db $87, $2a, $40, $40, $40, $3a, $36 
08946 82 34 2C 04 26 86 22 00         .db $82, $34, $2c, $04, $26, $86, $22, $00
0894E                           
0894E E3 F7 F7 F7 F5 F1 AC 27..       .db $e3, $f7, $f7, $f7, $f5, $f1, $ac, $27, $9e, $9d
08958                           
08958 85 18 82 1E 84 22 2A            .db $85, $18, $82, $1e, $84, $22, $2a
0895F 22 22 82 2C 2C 22 04            .db $22, $22, $82, $2c, $2c, $22, $04
08966                           
08966                           DeathMusData:
08966 86 04                           .db $86, $04 ;death music share data with fourth part c of ground level music 
08968                           
08968                           GroundM_P4CData:
08968 82 2A 36 04 36 87 36 34..       .db $82, $2a, $36, $04, $36, $87, $36, $34, $30, $86, $2c, $04, $00
08975                                 
08975 00 68 6A 6C 45                  .db $00, $68, $6a, $6c, $45 ;death music only
0897A                           
0897A A2 31 B0 F1 ED EB A2 1D..       .db $a2, $31, $b0, $f1, $ed, $eb, $a2, $1d, $9c, $95
08984                           
08984 86 04                           .db $86, $04 ;death music only
08986                           
08986 85 22 82 22 87 22 26 2A..       .db $85, $22, $82, $22, $87, $22, $26, $2a, $84, $2c, $22, $86, $14
08993                           
08993                           ;noise data used by fourth part sections
08993 51 90 31 11 00                  .db $51, $90, $31, $11, $00
08998                           
08998                           CastleMusData:
08998 80 22 28 22 26 22 24 22..       .db $80, $22, $28, $22, $26, $22, $24, $22, $26
089A1 22 28 22 2A 22 28 22 26         .db $22, $28, $22, $2a, $22, $28, $22, $26
089A9 22 28 22 26 22 24 22 26         .db $22, $28, $22, $26, $22, $24, $22, $26
089B1 22 28 22 2A 22 28 22 26         .db $22, $28, $22, $2a, $22, $28, $22, $26
089B9 20 26 20 24 20 26 20 28         .db $20, $26, $20, $24, $20, $26, $20, $28
089C1 20 26 20 28 20 26 20 24         .db $20, $26, $20, $28, $20, $26, $20, $24
089C9 20 26 20 24 20 26 20 28         .db $20, $26, $20, $24, $20, $26, $20, $28
089D1 20 26 20 28 20 26 20 24         .db $20, $26, $20, $28, $20, $26, $20, $24
089D9 28 30 28 32 28 30 28 2E         .db $28, $30, $28, $32, $28, $30, $28, $2e
089E1 28 30 28 2E 28 2C 28 2E         .db $28, $30, $28, $2e, $28, $2c, $28, $2e
089E9 28 30 28 32 28 30 28 2E         .db $28, $30, $28, $32, $28, $30, $28, $2e
089F1 28 30 28 2E 28 2C 28 2E..       .db $28, $30, $28, $2e, $28, $2c, $28, $2e, $00
089FA                           
089FA 04 70 6E 6C 6E 70 72 70..       .db $04, $70, $6e, $6c, $6e, $70, $72, $70, $6e
08A03 70 6E 6C 6E 70 72 70 6E         .db $70, $6e, $6c, $6e, $70, $72, $70, $6e
08A0B 6E 6C 6E 70 6E 70 6E 6C         .db $6e, $6c, $6e, $70, $6e, $70, $6e, $6c
08A13 6E 6C 6E 70 6E 70 6E 6C         .db $6e, $6c, $6e, $70, $6e, $70, $6e, $6c
08A1B 76 78 76 74 76 74 72 74         .db $76, $78, $76, $74, $76, $74, $72, $74
08A23 76 78 76 74 76 74 72 74         .db $76, $78, $76, $74, $76, $74, $72, $74
08A2B                           
08A2B 84 1A 83 18 20 84 1E 83..       .db $84, $1a, $83, $18, $20, $84, $1e, $83, $1c, $28
08A35 26 1C 1A 1C                     .db $26, $1c, $1a, $1c
08A39                           
08A39                           GameOverMusData:
08A39 82 2C 04 04 22 04 04 84..       .db $82, $2c, $04, $04, $22, $04, $04, $84, $1c, $87
08A43 26 2A 26 84 24 28 24 80..       .db $26, $2a, $26, $84, $24, $28, $24, $80, $22, $00
08A4D                           
08A4D 9C 05 94 05 0D 9F 1E 9C..       .db $9c, $05, $94, $05, $0d, $9f, $1e, $9c, $98, $9d
08A57                           
08A57 82 22 04 04 1C 04 04 84..       .db $82, $22, $04, $04, $1c, $04, $04, $84, $14
08A60 86 1E 80 16 80 14               .db $86, $1e, $80, $16, $80, $14
08A66                           
08A66                           TimeRunOutMusData:
08A66 81 1C 30 04 30 30 04 1E..       .db $81, $1c, $30, $04, $30, $30, $04, $1e, $32, $04, $32, $32
08A72 04 20 34 04 34 34 04 36..       .db $04, $20, $34, $04, $34, $34, $04, $36, $04, $84, $36, $00
08A7E                           
08A7E 46 A4 64 A4 48 A6 66 A6..       .db $46, $a4, $64, $a4, $48, $a6, $66, $a6, $4a, $a8, $68, $a8
08A8A 6A 44 2B                        .db $6a, $44, $2b
08A8D                           
08A8D 81 2A 42 04 42 42 04 2C..       .db $81, $2a, $42, $04, $42, $42, $04, $2c, $64, $04, $64, $64
08A99 04 2E 46 04 46 46 04 22..       .db $04, $2e, $46, $04, $46, $46, $04, $22, $04, $84, $22
08AA4                           
08AA4                           WinLevelMusData:
08AA4 87 04 06 0C 14 1C 22 86..       .db $87, $04, $06, $0c, $14, $1c, $22, $86, $2c, $22
08AAE 87 04 60 0E 14 1A 24 86..       .db $87, $04, $60, $0e, $14, $1a, $24, $86, $2c, $24
08AB8 87 04 08 10 18 1E 28 86..       .db $87, $04, $08, $10, $18, $1e, $28, $86, $30, $30
08AC2 80 64 00                        .db $80, $64, $00
08AC5                           
08AC5 CD D5 DD E3 ED F5 BB B5..       .db $cd, $d5, $dd, $e3, $ed, $f5, $bb, $b5, $cf, $d5
08ACF DB E5 ED F3 BD B3 D1 D9..       .db $db, $e5, $ed, $f3, $bd, $b3, $d1, $d9, $df, $e9
08AD9 F1 F7 BF FF FF FF 34            .db $f1, $f7, $bf, $ff, $ff, $ff, $34
08AE0 00                              .db $00 ;unused byte
08AE1                           
08AE1 86 04 87 14 1C 22 86 34..       .db $86, $04, $87, $14, $1c, $22, $86, $34, $84, $2c
08AEB 04 04 04 87 14 1A 24 86..       .db $04, $04, $04, $87, $14, $1a, $24, $86, $32, $84
08AF5 2C 04 86 04 87 18 1E 28..       .db $2c, $04, $86, $04, $87, $18, $1e, $28, $86, $36
08AFF 87 30 30 30 80 2C               .db $87, $30, $30, $30, $80, $2c
08B05                           
08B05                           ;square 2 and triangle use the same data, square 1 is unused
08B05                           UndergroundMusData:
08B05 82 14 2C 62 26 10 28 80..       .db $82, $14, $2c, $62, $26, $10, $28, $80, $04
08B0E 82 14 2C 62 26 10 28 80..       .db $82, $14, $2c, $62, $26, $10, $28, $80, $04
08B17 82 08 1E 5E 18 60 1A 80..       .db $82, $08, $1e, $5e, $18, $60, $1a, $80, $04
08B20 82 08 1E 5E 18 60 1A 86..       .db $82, $08, $1e, $5e, $18, $60, $1a, $86, $04
08B29 83 1A 18 16 84 14 1A 18..       .db $83, $1a, $18, $16, $84, $14, $1a, $18, $0e, $0c
08B33 16 83 14 20 1E 1C 28 26..       .db $16, $83, $14, $20, $1e, $1c, $28, $26, $87
08B3C 24 1A 12 10 62 0E 80 04..       .db $24, $1a, $12, $10, $62, $0e, $80, $04, $04
08B45 00                              .db $00
08B46                           
08B46                           ;noise data directly follows square 2 here unlike in other songs
08B46                           WaterMusData:
08B46 82 18 1C 20 22 26 28            .db $82, $18, $1c, $20, $22, $26, $28 
08B4D 81 2A 2A 2A 04 2A 04 83..       .db $81, $2a, $2a, $2a, $04, $2a, $04, $83, $2a, $82, $22
08B58 86 34 32 34 81 04 22 26..       .db $86, $34, $32, $34, $81, $04, $22, $26, $2a, $2c, $30
08B63 86 34 83 32 82 36 84 34..       .db $86, $34, $83, $32, $82, $36, $84, $34, $85, $04, $81, $22
08B6F 86 30 2E 30 81 04 22 26..       .db $86, $30, $2e, $30, $81, $04, $22, $26, $2a, $2c, $2e
08B7A 86 30 83 22 82 36 84 34..       .db $86, $30, $83, $22, $82, $36, $84, $34, $85, $04, $81, $22
08B86 86 3A 3A 3A 82 3A 81 40..       .db $86, $3a, $3a, $3a, $82, $3a, $81, $40, $82, $04, $81, $3a
08B92 86 36 36 36 82 36 81 3A..       .db $86, $36, $36, $36, $82, $36, $81, $3a, $82, $04, $81, $36
08B9E 86 34 82 26 2A 36               .db $86, $34, $82, $26, $2a, $36
08BA4 81 34 34 85 34 81 2A 86..       .db $81, $34, $34, $85, $34, $81, $2a, $86, $2c, $00
08BAE                           
08BAE 84 90 B0 84 50 50 B0 00         .db $84, $90, $b0, $84, $50, $50, $b0, $00
08BB6                           
08BB6 98 96 94 92 94 96 58 58..       .db $98, $96, $94, $92, $94, $96, $58, $58, $58, $44
08BC0 5C 44 9F A3 A1 A3 85 A3..       .db $5c, $44, $9f, $a3, $a1, $a3, $85, $a3, $e0, $a6
08BCA 23 C4 9F 9D 9F 85 9F D2..       .db $23, $c4, $9f, $9d, $9f, $85, $9f, $d2, $a6, $23
08BD4 C4 B5 B1 AF 85 B1 AF AD..       .db $c4, $b5, $b1, $af, $85, $b1, $af, $ad, $85, $95
08BDE 9E A2 AA 6A 6A 6B 5E 9D         .db $9e, $a2, $aa, $6a, $6a, $6b, $5e, $9d
08BE6                           
08BE6 84 04 04 82 22 86 22            .db $84, $04, $04, $82, $22, $86, $22
08BED 82 14 22 2C 12 22 2A 14..       .db $82, $14, $22, $2c, $12, $22, $2a, $14, $22, $2c
08BF7 1C 22 2C 14 22 2C 12 22..       .db $1c, $22, $2c, $14, $22, $2c, $12, $22, $2a, $14
08C01 22 2C 1C 22 2C 18 22 2A..       .db $22, $2c, $1c, $22, $2c, $18, $22, $2a, $16, $20
08C0B 28 18 22 2A 12 22 2A 18..       .db $28, $18, $22, $2a, $12, $22, $2a, $18, $22, $2a
08C15 12 22 2A 14 22 2C 0C 22..       .db $12, $22, $2a, $14, $22, $2c, $0c, $22, $2c, $14, $22, $34, $12
08C22 22 30 10 22 2E 16 22 34..       .db $22, $30, $10, $22, $2e, $16, $22, $34, $18, $26
08C2C 36 16 26 36 14 26 36 12..       .db $36, $16, $26, $36, $14, $26, $36, $12, $22, $36
08C36 5C 22 34 0C 22 22 81 1E..       .db $5c, $22, $34, $0c, $22, $22, $81, $1e, $1e, $85, $1e
08C41 81 12 86 14                     .db $81, $12, $86, $14
08C45                           
08C45                           EndOfCastleMusData:
08C45 81 2C 22 1C 2C 22 1C 85..       .db $81, $2c, $22, $1c, $2c, $22, $1c, $85, $2c, $04
08C4F 81 2E 24 1E 2E 24 1E 85..       .db $81, $2e, $24, $1e, $2e, $24, $1e, $85, $2e, $04
08C59 81 32 28 22 32 28 22 85..       .db $81, $32, $28, $22, $32, $28, $22, $85, $32
08C62 87 36 36 36 84 3A 00            .db $87, $36, $36, $36, $84, $3a, $00
08C69                           
08C69 5C 54 4C 5C 54 4C               .db $5c, $54, $4c, $5c, $54, $4c
08C6F 5C 1C 1C 5C 5C 5C 5C            .db $5c, $1c, $1c, $5c, $5c, $5c, $5c
08C76 5E 56 4E 5E 56 4E               .db $5e, $56, $4e, $5e, $56, $4e
08C7C 5E 1E 1E 5E 5E 5E 5E            .db $5e, $1e, $1e, $5e, $5e, $5e, $5e
08C83 62 5A 50 62 5A 50               .db $62, $5a, $50, $62, $5a, $50
08C89 62 22 22 62 E7 E7 E7 2B         .db $62, $22, $22, $62, $e7, $e7, $e7, $2b
08C91                           
08C91 86 14 81 14 80 14 14 81..       .db $86, $14, $81, $14, $80, $14, $14, $81, $14, $14, $14, $14
08C9D 86 16 81 16 80 16 16 81..       .db $86, $16, $81, $16, $80, $16, $16, $81, $16, $16, $16, $16
08CA9 81 28 22 1A 28 22 1A 28..       .db $81, $28, $22, $1a, $28, $22, $1a, $28, $80, $28, $28
08CB4 81 28 87 2C 2C 2C 84 30         .db $81, $28, $87, $2c, $2c, $2c, $84, $30
08CBC                           
08CBC                           VictoryM_P1AData:
08CBC                           ;square 2
08CBC 84 12 86 0C 84 62 10 86       .db $84, $12, $86, $0c, $84, $62, $10, $86
08CC4 12 84 1C 22 1E 22 26 18       .db $12, $84, $1c, $22, $1e, $22, $26, $18
08CCC 1E 04 1C 00                   .db $1e, $04, $1c, $00
08CD0                           ;square 1
08CD0 E2 E0 E2 9D 1F 21 A3 2D       .db $e2, $e0, $e2, $9d, $1f, $21, $a3, $2d
08CD8 74 F4 31 35 37 2B B1 2D       .db $74, $f4, $31, $35, $37, $2b, $b1, $2d
08CE0                           ;triangle
08CE0 84 12 14 04 18 1A 1C 14       .db $84, $12, $14, $04, $18, $1a, $1c, $14
08CE8 26 22 1E 1C 18 1E 22 0C       .db $26, $22, $1e, $1c, $18, $1e, $22, $0c
08CF0 14                            .db $14
08CF1                           
08CF1                           VictoryM_P1BData:
08CF1                           ;square 2
08CF1 81 22 83 22 86 24 85 18       .db $81, $22, $83, $22, $86, $24, $85, $18
08CF9 82 1E 80 1E 83 1C 83 18       .db $82, $1e, $80, $1e, $83, $1c, $83, $18
08D01 84 1C 81 26 83 26 86 26       .db $84, $1c, $81, $26, $83, $26, $86, $26
08D09 85 1E 82 24 86 22 84 1E       .db $85, $1e, $82, $24, $86, $22, $84, $1e
08D11 00                            .db $00
08D12                           ;square 1
08D12 74 F4 B5 6B B0 30 EC EA       .db $74, $f4, $b5, $6b, $b0, $30, $ec, $ea
08D1A 2D 76 F6 B7 6D B0 B5 31       .db $2d, $76, $f6, $b7, $6d, $b0, $b5, $31
08D22                           ;triangle
08D22 84 12 1C 20 24 2A 26 24       .db $84, $12, $1c, $20, $24, $2a, $26, $24
08D2A 26 22 1E 22 24 1E 22 0C       .db $26, $22, $1e, $22, $24, $1e, $22, $0c
08D32 1E                            .db $1e
08D33                           ;noise (also used by part 1A)
08D33 11 11 D0 D0 D0 11 00          .db $11, $11, $d0, $d0, $d0, $11, $00
08D3A                           
08D3A                           VictoryM_P2AData:
08D3A                           ;square 2
08D3A 83 2C 2A 2C 86 26 84 28       .db $83, $2c, $2a, $2c, $86, $26, $84, $28
08D42 2A 86 2C 84 36 81 40 83       .db $2a, $86, $2c, $84, $36, $81, $40, $83
08D4A 40 84 3A 40 3E 34 00          .db $40, $84, $3a, $40, $3e, $34, $00
08D51                           
08D51                           VictoryM_P2BData:
08D51                           ;square 2
08D51 86 3A 84 36 00                .db $86, $3a, $84, $36, $00
08D56                           ;square 1 of part 2A
08D56 1D 95 19 1B 9D 27 2D 29       .db $1d, $95, $19, $1b, $9d, $27, $2d, $29
08D5E 2D 31 23                      .db $2d, $31, $23
08D61                           ;square 1 of part 2B
08D61 A9 27                         .db $a9, $27
08D63                           ;triangle of part 2A
08D63 84 1C 1E 04 22 24 26 1E       .db $84, $1c, $1e, $04, $22, $24, $26, $1e
08D6B 30 2C 28 26 22 28             .db $30, $2c, $28, $26, $22, $28
08D71                           ;triangle of part 2B
08D71 2C 14 1E                      .db $2c, $14, $1e
08D74                           
08D74                           VictoryM_P2CData:
08D74                           ;square 2
08D74 81 40 83 40 86 40 85 34       .db $81, $40, $83, $40, $86, $40, $85, $34
08D7C 82 3A 80 3A 83 36 34 84       .db $82, $3a, $80, $3a, $83, $36, $34, $84
08D84 36 81 3E 83 3E 86 3E 85       .db $36, $81, $3e, $83, $3e, $86, $3e, $85
08D8C 36 82 3A 86 40 84 3A 00       .db $36, $82, $3a, $86, $40, $84, $3a, $00
08D94                           ;square 1
08D94 6C EC AF 63 A8 29 C4 E6       .db $6c, $ec, $af, $63, $a8, $29, $c4, $e6
08D9C E2 27 70 F0 B1 69 AE AD       .db $e2, $27, $70, $f0, $b1, $69, $ae, $ad
08DA4 29                            .db $29
08DA5                           ;triangle
08DA5 84 1C 26 2A 2E 34 30 2E       .db $84, $1c, $26, $2a, $2e, $34, $30, $2e
08DAD 30 2C 28 2C 2E 28 2C 14       .db $30, $2c, $28, $2c, $2e, $28, $2c, $14
08DB5 28                            .db $28
08DB6                           ;noise of part 2A, 2B and 2C
08DB6 11 11 D0 D0 D0 11 00          .db $11, $11, $d0, $d0, $d0, $11, $00
08DBD                           
08DBD                           VictoryM_P2DData:
08DBD                           ;square 2
08DBD 87 3A 36 00                   .db $87, $3a, $36, $00
08DC1                           ;square 1
08DC1 E9 E7                         .db $e9, $e7
08DC3                           ;triangle
08DC3 83 16 1C 22 28 2E 34 84       .db $83, $16, $1c, $22, $28, $2e, $34, $84
08DCB 3A 83 34 22 34 84 36 83       .db $3a, $83, $34, $22, $34, $84, $36, $83
08DD3 1E 1E 1E 86 1E                .db $1e, $1e, $1e, $86, $1e
08DD8                           ;noise of part 2D
08DD8 11 11 D0 D0 D0 11 00          .db $11, $11, $d0, $d0, $d0, $11, $00
08DDF                           
08DDF                           FreqRegLookupTbl:
08DDF 00 88 00 2F 00 00               .db $00, $88, $00, $2f, $00, $00
08DE5 02 A6 02 80 02 5C 02 3A         .db $02, $a6, $02, $80, $02, $5c, $02, $3a
08DED 02 1A 01 DF 01 C4 01 AB         .db $02, $1a, $01, $df, $01, $c4, $01, $ab
08DF5 01 93 01 7C 01 67 01 53         .db $01, $93, $01, $7c, $01, $67, $01, $53
08DFD 01 40 01 2E 01 1D 01 0D         .db $01, $40, $01, $2e, $01, $1d, $01, $0d
08E05 00 FE 00 EF 00 E2 00 D5         .db $00, $fe, $00, $ef, $00, $e2, $00, $d5
08E0D 00 C9 00 BE 00 B3 00 A9         .db $00, $c9, $00, $be, $00, $b3, $00, $a9
08E15 00 A0 00 97 00 8E 00 86         .db $00, $a0, $00, $97, $00, $8e, $00, $86
08E1D 00 77 00 7E 00 71 00 54         .db $00, $77, $00, $7e, $00, $71, $00, $54
08E25 00 64 00 5F 00 59 00 50         .db $00, $64, $00, $5f, $00, $59, $00, $50
08E2D 00 47 00 43 00 3B 00 35         .db $00, $47, $00, $43, $00, $3b, $00, $35
08E35 00 2A 00 23 04 75 03 57         .db $00, $2a, $00, $23, $04, $75, $03, $57
08E3D 02 F9 02 CF 01 FC 00 6A         .db $02, $f9, $02, $cf, $01, $fc, $00, $6a
08E45                           
08E45                           MusicLengthLookupTbl:
08E45 05 0A 14 28 50 1E 3C 02         .db $05, $0a, $14, $28, $50, $1e, $3c, $02
08E4D 04 08 10 20 40 18 30 0C         .db $04, $08, $10, $20, $40, $18, $30, $0c
08E55 03 06 0C 18 30 12 24 08         .db $03, $06, $0c, $18, $30, $12, $24, $08
08E5D 36 03 09 06 12 1B 24 0C         .db $36, $03, $09, $06, $12, $1b, $24, $0c
08E65 24 02 06 04 0C 12 18 08         .db $24, $02, $06, $04, $0c, $12, $18, $08
08E6D 12 01 03 02 06 09 0C 04         .db $12, $01, $03, $02, $06, $09, $0c, $04
08E75 24 12 0D 09 1B 28 36 12         .db $24, $12, $0d, $09, $1b, $28, $36, $12 ;these two used in victory music only
08E7D 24 12 0D 09 1B 28 36 6C         .db $24, $12, $0d, $09, $1b, $28, $36, $6c
08E85                           
08E85                           VictoryMusEnvData:
08E85 97 98 9A 9B 9B 9A 9A 99         .db $97, $98, $9a, $9b, $9b, $9a, $9a, $99
08E8D 99 98 98 97 97 96 96 95         .db $99, $98, $98, $97, $97, $96, $96, $95
08E95 02                              .db $02 ;needed to produce correct sound
08E96                           
08E96                           EndOfCastleMusicEnvData:
08E96 98 99 9A 9B                     .db $98, $99, $9a, $9b
08E9A                           
08E9A                           AreaMusicEnvData:
08E9A 90 94 94 95 95 96 97 98         .db $90, $94, $94, $95, $95, $96, $97, $98
08EA2                           
08EA2                           WaterEventMusEnvData:
08EA2 90 91 92 92 93 93 93 94         .db $90, $91, $92, $92, $93, $93, $93, $94
08EAA 94 94 94 94 94 95 95 95         .db $94, $94, $94, $94, $94, $95, $95, $95
08EB2 95 95 95 96 96 96 96 96         .db $95, $95, $95, $96, $96, $96, $96, $96
08EBA 96 96 96 96 96 96 96 96         .db $96, $96, $96, $96, $96, $96, $96, $96
08EC2 96 96 96 96 95 95 94 93         .db $96, $96, $96, $96, $95, $95, $94, $93
08ECA                           
08ECA                           BowserFlameEnvData:
08ECA 15 16 16 17 17 18 19 19         .db $15, $16, $16, $17, $17, $18, $19, $19
08ED2 1A 1A 1C 1D 1D 1E 1E 1F         .db $1a, $1a, $1c, $1d, $1d, $1e, $1e, $1f
08EDA 1F 1F 1F 1E 1D 1C 1E 1F         .db $1f, $1f, $1f, $1e, $1d, $1c, $1e, $1f
08EE2 1F 1E 1D 1C 1A 18 16 14         .db $1f, $1e, $1d, $1c, $1a, $18, $16, $14
08EEA                           
08EEA                           BrickShatterEnvData:
08EEA 15 16 16 17 17 18 19 19         .db $15, $16, $16, $17, $17, $18, $19, $19
08EF2 1A 1A 1C 1D 1D 1E 1E 1F         .db $1a, $1a, $1c, $1d, $1d, $1e, $1e, $1f
08EFA                           
08EFA                           ;-------------------------------------------------------------------------------------
08EFA FF FF FF FF FF FF FF FF.. .pad $c000,$ff
0C000                           
0C000                           .base $8000
08000                           .include "levels.asm"
08000                           ;-------------------------------------------------------------------------------------
08000                           
08000                           LoadAreaPointer:
08000 20 10 80                               jsr FindAreaPointer  ;find it and store it here
08003 8D 50 07                               sta AreaPointer
08006 29 60                     GetAreaType: and #%01100000       ;mask out all but d6 and d5
08008 0A                                     asl
08009 2A                                     rol
0800A 2A                                     rol
0800B 2A                                     rol                  ;make %0xx00000 into %000000xx
0800C 8D 4E 07                               sta AreaType         ;save 2 MSB as area type
0800F 60                                     rts
08010                           
08010                           FindAreaPointer:
08010 AD 5F 07                        lda WorldNumber        ;load offset from world variable
08013 A8                              tay
08014 AD FB 07                        lda HardWorldFlag      ;are we playing 2J levels?
08017 D0 0C                           bne FindAreaPointerJ   ;yes, use 2J offsets instead
08019 B9 64 81                        lda WorldAddrOffsets,y
0801C 18                        	    clc
0801D 6D 60 07                        adc AreaNumber         ;add area number used to find data
08020 A8                              tay
08021 B9 6D 81                        lda AreaAddrOffsets,y  ;from there we have our area pointer
08024 60                              rts
08025                           FindAreaPointerJ:
08025 B9 35 82                        lda WorldAddrOffsetsJ,y
08028 18                        	    clc
08029 6D 60 07                        adc AreaNumber         ;add area number used to find data
0802C A8                              tay
0802D B9 42 82                        lda AreaAddrOffsetsJ,y  ;from there we have our area pointer
08030 60                              rts
08031                           
08031                           GetAreaPointer:
08031 AD FB 07                       lda HardWorldFlag         ;are we playing 2J levels?
08034 D0 07                          bne GetAreaPointerJ       ;yes, use 2J offsets instead
08036 BE 64 81                       ldx WorldAddrOffsets,y    ;get offset to where this world's area offsets are
08039 BC 6D 81                       ldy AreaAddrOffsets,x     ;get area offset based on world offset
0803C 60                             rts
0803D                           GetAreaPointerJ:
0803D BE 35 82                       ldx WorldAddrOffsetsJ,y    ;get offset to where this world's area offsets are
08040 BC 42 82                       ldy AreaAddrOffsetsJ,x     ;get area offset based on world offset
08043 60                             rts
08044                           
08044                           GetAreaDataAddrs:
08044 AD 50 07                              lda AreaPointer          ;use 2 MSB for Y
08047 20 06 80                              jsr GetAreaType
0804A A8                                    tay
0804B AD 50 07                              lda AreaPointer            ;mask out all but 5 LSB
0804E 29 1F                                 and #%00011111
08050 8D 4F 07                              sta AreaAddrsLOffset       ;save as low offset
08053 AD FB 07                              lda HardWorldFlag          ;check if playing 2J levels
08056 D0 2C                                 bne GetAreaDataAddrsJ      ;if so, refer to alternate offsets
08058 B9 95 81                              lda EnemyAddrHOffsets,y    ;load base value with 2 altered MSB,
0805B 18                                    clc                        ;then add base value to 5 LSB, result
0805C 6D 4F 07                              adc AreaAddrsLOffset       ;becomes offset for level data
0805F 0A                                    asl
08060 A8                                    tay
08061 B9 9A 81                              lda EnemyDataAddrs+1,y     ;use offset to load pointer
08064 85 EA                                 sta EnemyDataHigh
08066 B9 99 81                              lda EnemyDataAddrs,y
08069 85 E9                                 sta EnemyDataLow
0806B AC 4E 07                              ldy AreaType               ;use area type as offset
0806E B9 E5 81                              lda AreaDataHOffsets,y     ;do the same thing but with different base value
08071 18                                    clc
08072 6D 4F 07                              adc AreaAddrsLOffset
08075 0A                                    asl
08076 A8                                    tay
08077 B9 EA 81                              lda AreaDataAddrs+1,y      ;use this offset to load another pointer
0807A 85 E8                                 sta AreaDataHigh
0807C B9 E9 81                              lda AreaDataAddrs,y
0807F 85 E7                                 sta AreaDataLow
08081 4C E0 80                              jmp ContinueAreaDataAddrs
08084                           GetAreaDataAddrsJ:
08084 AD 5F 07                              lda WorldNumber           ;playing 2J letter worlds?
08087 C9 09                                 cmp #WorldA
08089 B0 2C                                 bcs GetAreaDataAddrsL     ;yes, alternate offsets
0808B B9 7C 82                              lda EnemyAddrHOffsetsJ,y  ;load base value with 2 altered MSB,
0808E 18                                    clc                        ;then add base value to 5 LSB, result
0808F 6D 4F 07                              adc AreaAddrsLOffset       ;becomes offset for level data
08092 0A                                    asl
08093 A8                                    tay
08094 B9 81 82                              lda EnemyDataAddrsJ+1,y   ;use offset to load pointer
08097 85 EA                                 sta EnemyDataHigh
08099 B9 80 82                              lda EnemyDataAddrsJ,y
0809C 85 E9                                 sta EnemyDataLow
0809E AC 4E 07                              ldy AreaType               ;use area type as offset
080A1 B9 E8 82                              lda AreaDataHOffsetsJ,y   ;do the same thing but with different base value
080A4 18                                    clc
080A5 6D 4F 07                              adc AreaAddrsLOffset
080A8 0A                                    asl
080A9 A8                                    tay
080AA B9 ED 82                              lda AreaDataAddrsJ+1,y    ;use this offset to load another pointer
080AD 85 E8                                 sta AreaDataHigh
080AF B9 EC 82                              lda AreaDataAddrsJ,y
080B2 85 E7                                 sta AreaDataLow
080B4 4C E0 80                              jmp ContinueAreaDataAddrs
080B7                           GetAreaDataAddrsL:
080B7 B9 54 83                              lda EnemyAddrHOffsetsL,y  ;load base value with 2 altered MSB,
080BA 18                                    clc                        ;then add base value to 5 LSB, result
080BB 6D 4F 07                              adc AreaAddrsLOffset       ;becomes offset for level data
080BE 0A                                    asl
080BF A8                                    tay
080C0 B9 59 83                              lda EnemyDataAddrsL+1,y   ;use offset to load pointer
080C3 85 EA                                 sta EnemyDataHigh
080C5 B9 58 83                              lda EnemyDataAddrsL,y
080C8 85 E9                                 sta EnemyDataLow
080CA AC 4E 07                              ldy AreaType               ;use area type as offset
080CD B9 82 83                              lda AreaDataHOffsetsL,y   ;do the same thing but with different base value
080D0 18                                    clc
080D1 6D 4F 07                              adc AreaAddrsLOffset
080D4 0A                                    asl
080D5 A8                                    tay
080D6 B9 87 83                              lda AreaDataAddrsL+1,y    ;use this offset to load another pointer
080D9 85 E8                                 sta AreaDataHigh
080DB B9 86 83                              lda AreaDataAddrsL,y
080DE 85 E7                                 sta AreaDataLow
080E0                           ContinueAreaDataAddrs:
080E0 A0 00                                 ldy #$00                 ;load first byte of header
080E2 B1 E7                                 lda (AreaData),y     
080E4 48                                    pha                      ;save it to the stack for now
080E5 29 07                                 and #%00000111           ;save 3 LSB for foreground scenery or bg color control
080E7 C9 04                                 cmp #$04
080E9 90 05                                 bcc StoreFore
080EB 8D 44 07                              sta BackgroundColorCtrl  ;if 4 or greater, save value here as bg color control
080EE A9 00                                 lda #$00
080F0 8D 41 07                  StoreFore:  sta ForegroundScenery    ;if less, save value here as foreground scenery
080F3 68                                    pla                      ;pull byte from stack and push it back
080F4 48                                    pha
080F5 29 38                                 and #%00111000           ;save player entrance control bits
080F7 4A                                    lsr                      ;shift bits over to LSBs
080F8 4A                                    lsr
080F9 4A                                    lsr
080FA 8D 10 07                              sta PlayerEntranceCtrl   ;save value here as player entrance control
080FD 68                                    pla                      ;pull byte again but do not push it back
080FE 29 C0                                 and #%11000000           ;save 2 MSB for game timer setting
08100 18                                    clc
08101 2A                                    rol                      ;rotate bits over to LSBs
08102 2A                                    rol
08103 2A                                    rol
08104 8D 15 07                              sta GameTimerSetting     ;save value here as game timer setting
08107 C8                                    iny
08108 B1 E7                                 lda (AreaData),y         ;load second byte of header
0810A 48                                    pha                      ;save to stack
0810B 29 0F                                 and #%00001111           ;mask out all but lower nybble
0810D 8D 27 07                              sta TerrainControl
08110 68                                    pla                      ;pull and push byte to copy it to A
08111 48                                    pha
08112 29 30                                 and #%00110000           ;save 2 MSB for background scenery type
08114 4A                                    lsr
08115 4A                                    lsr                      ;shift bits to LSBs
08116 4A                                    lsr
08117 4A                                    lsr
08118 8D 42 07                              sta BackgroundScenery    ;save as background scenery
0811B 68                                    pla           
0811C 29 C0                                 and #%11000000
0811E 18                                    clc
0811F 2A                                    rol                      ;rotate bits over to LSBs
08120 2A                                    rol
08121 2A                                    rol
08122 C9 03                                 cmp #%00000011           ;if set to 3, store here
08124 D0 05                                 bne StoreStyle           ;and nullify other value
08126 8D 43 07                              sta CloudTypeOverride    ;otherwise store value in other place
08129 A9 00                                 lda #$00
0812B 8D 33 07                  StoreStyle: sta AreaStyle
0812E A0 00                                 ldy #$00                 ;init counter
08130 B1 E7                     ADataLoop:  lda (AreaData),y         ;store area data into region of RAM
08132 99 10 60                              sta AreaDataCopy,y
08135 C8                                    iny                      ;increment Y for next byte
08136 C9 FD                                 cmp #$fd                 ;did we just store a $fd byte?
08138 D0 F6                                 bne ADataLoop            ;if not, we aren't done storing area data yet
0813A A9 60                                 lda #>AreaDataCopy       ;now move area data pointers to RAM
0813C 85 E8                                 sta AreaDataHigh
0813E A9 10                                 lda #<AreaDataCopy
08140 85 E7                                 sta AreaDataLow
08142 A0 00                                 ldy #$00                 ;init counter
08144 B1 E9                     EDataLoop:  lda (EnemyData),y        ;store enemy data into region of RAM
08146 99 10 61                              sta EnemyDataCopy,y
08149 C8                                    iny                      ;increment Y for next byte
0814A C9 FF                                 cmp #$ff                 ;did we just store a $ff byte?
0814C D0 F6                                 bne EDataLoop            ;if not, we aren't done storing enemy data yet
0814E A9 61                                 lda #>EnemyDataCopy      ;now move enemy data pointers to RAM
08150 85 EA                                 sta EnemyDataHigh
08152 A9 10                                 lda #<EnemyDataCopy
08154 85 E9                                 sta EnemyDataLow         ;(credit to threecreepio for this code)
08156 A5 E7                                 lda AreaDataLow          ;increment area data address by 2 bytes
08158 18                                    clc
08159 69 02                                 adc #$02
0815B 85 E7                                 sta AreaDataLow
0815D A5 E8                                 lda AreaDataHigh
0815F 69 00                                 adc #$00
08161 85 E8                                 sta AreaDataHigh
08163 60                                    rts
08164                           
08164                           ;-------------------------------------------------------------------------------------
08164                           
08164                           WorldAddrOffsets:
08164 00 05                           .db World1Areas-AreaAddrOffsets, World2Areas-AreaAddrOffsets
08166 0A 0E                           .db World3Areas-AreaAddrOffsets, World4Areas-AreaAddrOffsets
08168 13 17                           .db World5Areas-AreaAddrOffsets, World6Areas-AreaAddrOffsets
0816A 1B 20                           .db World7Areas-AreaAddrOffsets, World8Areas-AreaAddrOffsets
0816C 24                              .db World9Areas-AreaAddrOffsets
0816D                           
0816D                           AreaAddrOffsets:
0816D 25 29 C0 26 60            World1Areas: .db $25, $29, $c0, $26, $60
08172 28 29 01 27 62            World2Areas: .db $28, $29, $01, $27, $62
08177 24 35 20 63               World3Areas: .db $24, $35, $20, $63
0817B 22 29 41 2C 61            World4Areas: .db $22, $29, $41, $2c, $61
08180 2A 31 26 62               World5Areas: .db $2a, $31, $26, $62
08184 2E 23 2D 60               World6Areas: .db $2e, $23, $2d, $60
08188 33 29 01 27 64            World7Areas: .db $33, $29, $01, $27, $64
0818D 30 32 21 65               World8Areas: .db $30, $32, $21, $65
08191 03 04 05 43               World9Areas: .db $03, $04, $05, $43
08195                           
08195                           ;bonus area data offsets, included here for comparison purposes
08195                           ;underground bonus area  - c2
08195                           ;cloud area 1 (day)      - 2b
08195                           ;cloud area 2 (night)    - 34
08195                           ;water area (5-2/6-2)    - 00
08195                           ;water area (8-4)        - 02
08195                           ;warp zone area (4-2)    - 2f
08195                           
08195                           EnemyAddrHOffsets:
08195 00 06 1C 20                     .db $00, $06, $1c, $20
08199                           
08199                           EnemyDataAddrs:
08199 C8 87 D9 87 03 88 17 88..       .dw E_WaterArea1_, E_WaterArea2_, E_WaterArea3_, E_WaterArea4_, E_WaterArea5_, E_WaterArea6_
081A5 99 84 BE 84 DB 84               .dw E_GroundArea1_, E_GroundArea2_, E_GroundArea3_
081AB E9 84 10 85 41 85 5F 85..       .dw E_GroundArea4_, E_GroundArea5_, E_GroundArea6_, E_GroundArea7_, E_GroundArea8_, E_GroundArea9_
081B7 BC 85 BD 85 E1 85 EA 85..       .dw E_GroundArea10_, E_GroundArea11_, E_GroundArea12_, E_GroundArea13_, E_GroundArea14_, E_GroundArea15_
081C3 3B 86 3C 86 76 86 A1 86..       .dw E_GroundArea16_, E_GroundArea17_, E_GroundArea18_, E_GroundArea19_, E_GroundArea20_, E_GroundArea21_
081CF F4 86 19 87 46 87 74 87..       .dw E_GroundArea22_, E_UndergroundArea1_, E_UndergroundArea2_, E_UndergroundArea3_, E_UndergroundArea4_
081D9 B0 83 D7 83 F0 83 1F 84..       .dw E_CastleArea1_, E_CastleArea2_, E_CastleArea3_, E_CastleArea4_, E_CastleArea5_, E_CastleArea6_
081E5                           
081E5                           AreaDataHOffsets:
081E5 00 06 1C 20                     .db $00, $06, $1c, $20
081E9                           
081E9                           AreaDataAddrs:
081E9 7C 95 BB 95 36 96 51 96..       .dw L_WaterArea1_, L_WaterArea2_, L_WaterArea3_, L_WaterArea4_, L_WaterArea5_, L_WaterArea6_
081F5 4A 8B AF 8B 18 8C               .dw L_GroundArea1_, L_GroundArea2_, L_GroundArea3_
081FB 6D 8C FC 8C 69 8D CE 8D..       .dw L_GroundArea4_, L_GroundArea5_, L_GroundArea6_, L_GroundArea7_, L_GroundArea8_, L_GroundArea9_
08207 15 8F 1E 8F 5F 8F 74 8F..       .dw L_GroundArea10_, L_GroundArea11_, L_GroundArea12_, L_GroundArea13_, L_GroundArea14_, L_GroundArea15_
08213 B9 90 EA 90 7D 91 F2 91..       .dw L_GroundArea16_, L_GroundArea17_, L_GroundArea18_, L_GroundArea19_, L_GroundArea20_, L_GroundArea21_
0821F F1 92 26 93 C7 93 64 94..       .dw L_GroundArea22_, L_UndergroundArea1_, L_UndergroundArea2_, L_UndergroundArea3_, L_UndergroundArea4_
08229 90 88 F1 88 70 89 E3 89..       .dw L_CastleArea1_, L_CastleArea2_, L_CastleArea3_, L_CastleArea4_, L_CastleArea5_, L_CastleArea6_
08235                           
08235                           ;-------------------------------------------------------------------------------------
08235                           
08235                           WorldAddrOffsetsJ:
08235 00 05                       .db World1JAreas-AreaAddrOffsetsJ, World2JAreas-AreaAddrOffsetsJ
08237 09 0E                       .db World3JAreas-AreaAddrOffsetsJ, World4JAreas-AreaAddrOffsetsJ
08239 12 17                       .db World5JAreas-AreaAddrOffsetsJ, World6JAreas-AreaAddrOffsetsJ
0823B 1C 20                       .db World7JAreas-AreaAddrOffsetsJ, World8JAreas-AreaAddrOffsetsJ
0823D 24                          .db World9JAreas-AreaAddrOffsetsJ
0823E 28 2D                       .db WorldAAreas-AreaAddrOffsetsJ, WorldBAreas-AreaAddrOffsetsJ
08240 32 36                       .db WorldCAreas-AreaAddrOffsetsJ, WorldDAreas-AreaAddrOffsetsJ
08242                           
08242                           AreaAddrOffsetsJ:
08242 20 29 40 21 60            World1JAreas: .db $20, $29, $40, $21, $60
08247 22 23 24 61               World2JAreas: .db $22, $23, $24, $61
0824B 25 29 00 26 62            World3JAreas: .db $25, $29, $00, $26, $62
08250 27 28 2A 63               World4JAreas: .db $27, $28, $2a, $63
08254 2B 29 43 2C 64            World5JAreas: .db $2b, $29, $43, $2c, $64
08259 2D 29 01 2E 65            World6JAreas: .db $2d, $29, $01, $2e, $65
0825E 2F 30 31 66               World7JAreas: .db $2f, $30, $31, $66
08262 32 35 36 67               World8JAreas: .db $32, $35, $36, $67
08266 38 06 68 07               World9JAreas: .db $38, $06, $68, $07
0826A                           
0826A 20 2C 40 21 60            WorldAAreas: .db $20, $2c, $40, $21, $60
0826F 22 2C 00 23 61            WorldBAreas: .db $22, $2c, $00, $23, $61
08274 24 25 26 62               WorldCAreas: .db $24, $25, $26, $62
08278 27 28 29 63               WorldDAreas: .db $27, $28, $29, $63
0827C                           
0827C                           EnemyAddrHOffsetsJ:
0827C 2C 0A 27 00                 .db $2c, $0a, $27, $00
08280                           
08280                           EnemyDataAddrsJ:
08280 9E 97 BD 97 E4 97 F7 97..   .dw E_CastleArea1, E_CastleArea2, E_CastleArea3, E_CastleArea4, E_CastleArea5, E_CastleArea6
0828C 8C 98 CB 98 0B 99 15 99..   .dw E_CastleArea7, E_CastleArea8, E_CastleArea9, E_CastleArea10, E_GroundArea1, E_GroundArea2
08298 20 9A 49 9A 7F 9A 96 9A..   .dw E_GroundArea3, E_GroundArea4, E_GroundArea5, E_GroundArea6, E_GroundArea7, E_GroundArea8
082A4 FC 9A 1D 9B 1E 9B 41 9B..   .dw E_GroundArea9, E_GroundArea10, E_GroundArea11, E_GroundArea12, E_GroundArea13, E_GroundArea14
082B0 BE 9B DB 9B 0C 9C 38 9C..   .dw E_GroundArea15, E_GroundArea16, E_GroundArea17, E_GroundArea18, E_GroundArea19, E_GroundArea20
082BC 1D 9B 85 9C A8 9C CF 9C..   .dw E_GroundArea21, E_GroundArea22, E_GroundArea23, E_GroundArea24, E_GroundArea25, E_GroundArea26
082C8 8E 9F 1D 9B D4 9C 52 9E..   .dw E_GroundArea27, E_GroundArea28, E_GroundArea29, E_UndergroundArea1, E_UndergroundArea2
082D2 82 9E 9C 9E BD 9E 05 9F..   .dw E_UndergroundArea3, E_UndergroundArea4, E_UndergroundArea5, E_WaterArea1, E_WaterArea2
082DC 5B 9F 6B 9F 79 9F 8E 9F..   .dw E_WaterArea3, E_WaterArea4, E_WaterArea5, E_WaterArea6, E_WaterArea7, E_WaterArea8
082E8                           
082E8                           AreaDataHOffsetsJ:
082E8 2C 0A 27 00                 .db $2c, $0a, $27, $00
082EC                           
082EC                           AreaDataAddrsJ:
082EC E9 9F 48 A0 D3 A0 6A A1..   .dw L_CastleArea1, L_CastleArea2, L_CastleArea3, L_CastleArea4, L_CastleArea5, L_CastleArea6
082F8 3B A3 CE A3 A5 A4 08 A5..   .dw L_CastleArea7, L_CastleArea8, L_CastleArea9, L_CastleArea10, L_GroundArea1, L_GroundArea2
08304 DF A7 58 A8 D5 A8 38 A9..   .dw L_GroundArea3, L_GroundArea4, L_GroundArea5, L_GroundArea6, L_GroundArea7, L_GroundArea8
08310 8D AA EE AA F7 AA 40 AB..   .dw L_GroundArea9, L_GroundArea10, L_GroundArea11, L_GroundArea12, L_GroundArea13, L_GroundArea14
0831C BF AC 30 AD B3 AD 10 AE..   .dw L_GroundArea15, L_GroundArea16, L_GroundArea17, L_GroundArea18, L_GroundArea19, L_GroundArea20
08328 19 AF 40 AF AB AF 0F B0..   .dw L_GroundArea21, L_GroundArea22, L_GroundArea23, L_GroundArea24, L_GroundArea25, L_GroundArea26
08334 0F B0 1F B0 32 B0 09 B5..   .dw L_GroundArea27, L_GroundArea28, L_GroundArea29, L_UndergroundArea1, L_UndergroundArea2
0833E 05 B6 50 B6 1D B7 32 B8..   .dw L_UndergroundArea3, L_UndergroundArea4, L_UndergroundArea5, L_WaterArea1, L_WaterArea2
08348 AE B9 DF B9 F8 B9 39 BA..   .dw L_WaterArea3, L_WaterArea4, L_WaterArea5, L_WaterArea6, L_WaterArea7, L_WaterArea8
08354                           
08354                           EnemyAddrHOffsetsL:
08354 14 04 12 00                    .db $14, $04, $12, $00
08358                           
08358                           EnemyDataAddrsL:
08358 1B 99 40 99 67 99 A8 99..      .dw E_CastleArea11, E_CastleArea12, E_CastleArea13, E_CastleArea14, E_GroundArea30, E_GroundArea31
08364 27 9D 55 9D 7A 9D 9D 9D..      .dw E_GroundArea32, E_GroundArea33, E_GroundArea34, E_GroundArea35, E_GroundArea36, E_GroundArea37
08370 FB 9D 1C 9E 33 9E 43 9E..      .dw E_GroundArea38, E_GroundArea39, E_GroundArea40, E_GroundArea41, E_GroundArea10, E_GroundArea28
0837C D7 9E F1 9E C5 9F              .dw E_UndergroundArea6, E_UndergroundArea7, E_WaterArea9
08382                           
08382                           AreaDataHOffsetsL:
08382 14 04 12 00                    .db $14, $04, $12, $00
08386                           
08386                           AreaDataAddrsL:
08386 19 A5 8C A5 09 A6 A4 A6..      .dw L_CastleArea11, L_CastleArea12, L_CastleArea13, L_CastleArea14, L_GroundArea30, L_GroundArea31
08392 53 B1 E4 B1 43 B2 BA B2..      .dw L_GroundArea32, L_GroundArea33, L_GroundArea34, L_GroundArea35, L_GroundArea36, L_GroundArea37
0839E 13 B4 5E B4 C9 B4 EC B4..      .dw L_GroundArea38, L_GroundArea39, L_GroundArea40, L_GroundArea41, L_GroundArea10, L_GroundArea28
083AA 5E B7 D3 B7 14 BB              .dw L_UndergroundArea6, L_UndergroundArea7, L_WaterArea9
083B0                           
083B0                           ;-------------------------------------------------------------------------------------
083B0                           
083B0                           ;ENEMY OBJECT DATA
083B0                           
083B0                           ;level 1-4/6-4
083B0                           E_CastleArea1_:
083B0 76 DD BB 4C EA 1D 1B CC..       .incbin "levels/E_1-4_6-4.bin"
083D7                           
083D7                           ;level 4-4
083D7                           E_CastleArea2_:
083D7 0F 03 56 1B C9 1B 0F 07..       .incbin "levels/E_4-4.bin"
083F0                           
083F0                           ;level 2-4/5-4
083F0                           E_CastleArea3_:
083F0 0B 8C 4B 4C 77 5F EB 0C..       .incbin "levels/E_2-4_5-4.bin"
0841F                           
0841F                           ;level 3-4
0841F                           E_CastleArea4_:
0841F 0B 8C 3B 1D 8B 1D AB 0C..       .incbin "levels/E_3-4.bin"
0844A                           
0844A                           ;level 7-4
0844A                           E_CastleArea5_:
0844A 27 A9 4B 0C 68 29 0F 06..       .incbin "levels/E_7-4.bin"
0845F                           
0845F                           ;level 8-4
0845F                           E_CastleArea6_:
0845F 0F 03 8E 65 E1 BB 38 6D..       .incbin "levels/E_8-4.bin"
08499                           
08499                           ;level 3-3
08499                           E_GroundArea1_:
08499 A5 86 E4 28 18 A8 45 83..       .incbin "levels/E_3-3.bin"
084BE                           
084BE                           ;level 8-3
084BE                           E_GroundArea2_:
084BE EB 8E 0F 03 FB 05 17 85..       .incbin "levels/E_8-3.bin"
084DB                           
084DB                           ;level 4-1
084DB                           E_GroundArea3_:
084DB 2E C2 66 E2 11 0F 07 02..       .incbin "levels/E_4-1.bin"
084E9                           
084E9                           ;level 6-2
084E9                           E_GroundArea4_:
084E9 0E C2 A8 AB 00 BB 8E 6B..       .incbin "levels/E_6-2.bin"
08510                           
08510                           ;level 3-1
08510                           E_GroundArea5_:
08510 9B 8E CA 0E EE 42 44 5B..       .incbin "levels/E_3-1.bin"
08541                           
08541                           ;level 1-1
08541                           E_GroundArea6_:
08541 1E C2 00 6B 06 8B 86 63..       .incbin "levels/E_1-1.bin"
0855F                           
0855F                           ;level 1-3/5-3
0855F                           E_GroundArea7_:
0855F 2B D7 E3 03 C2 86 E2 06..       .incbin "levels/E_1-3_5-3.bin"
0857C                           
0857C                           ;level 2-3/7-3
0857C                           E_GroundArea8_:
0857C 0F 02 78 40 48 CE F8 C3..       .incbin "levels/E_2-3_7-3.bin"
08591                           
08591                           ;level 2-1
08591                           E_GroundArea9_:
08591 85 86 0B 80 1B 00 DB 37..       .incbin "levels/E_2-1.bin"
085BC                           ;end of data terminator here is also used by pipe intro area
085BC                           E_GroundArea10_:
085BC FF                              .db $ff
085BD                           
085BD                           ;level 5-1
085BD                           E_GroundArea11_:
085BD 0B 80 60 38 10 B8 C0 3B..       .incbin "levels/E_5-1.bin"
085E1                           
085E1                           ;cloud level used in levels 2-1 and 5-2
085E1                           E_GroundArea12_:
085E1 0A AA 0E 28 2A 0E 31 88..       .incbin "levels/E_CLOUD1.bin"
085EA                           
085EA                           ;level 4-3
085EA                           E_GroundArea13_:
085EA C7 83 D7 03 42 8F 7A 03..       .incbin "levels/E_4-3.bin"
0860F                           
0860F                           ;level 6-3
0860F                           E_GroundArea14_:
0860F CD A5 B5 A8 07 A8 76 28..       .incbin "levels/E_6-3.bin"
08632                           
08632                           ;level 6-1
08632                           E_GroundArea15_:
08632 0F 02 02 11 0F 07 02 11..       .incbin "levels/E_6-1.bin"
0863B                           
0863B                           ;warp zone area used in level 4-2
0863B                           E_GroundArea16_:
0863B FF                              .db $ff
0863C                           
0863C                           ;level 8-1
0863C                           E_GroundArea17_:
0863C 2B 82 AB 38 DE 42 E2 1B..       .incbin "levels/E_8-1.bin"
08676                           
08676                           ;level 5-2
08676                           E_GroundArea18_:
08676 7B 80 AE 00 80 8B 8E E8..       .incbin "levels/E_5-2.bin"
086A1                           
086A1                           ;level 8-2
086A1                           E_GroundArea19_:
086A1 29 8E 52 11 83 0E 0F 03..       .incbin "levels/E_8-2.bin"
086CF                           
086CF                           ;level 7-1
086CF                           E_GroundArea20_:
086CF AB CE DE 42 C0 CB CE 5B..       .incbin "levels/E_7-1.bin"
086EB                           
086EB                           ;cloud level used in levels 3-1 and 6-2
086EB                           E_GroundArea21_:
086EB 0A AA 0E 24 4A 1E 23 AA..       .incbin "levels/E_CLOUD2.bin"
086F4                           
086F4                           ;level 3-2
086F4                           E_GroundArea22_:
086F4 1B 80 BB 38 4B BC EB 3B..       .incbin "levels/E_3-2.bin"
08719                           
08719                           ;level 1-2
08719                           E_UndergroundArea1_:
08719 0B 86 1A 06 DB 06 DE C2..       .incbin "levels/E_1-2.bin"
08746                           
08746                           ;level 4-2
08746                           E_UndergroundArea2_:
08746 0F 02 1E 2F 60 E0 3A A5..       .incbin "levels/E_4-2.bin"
08774                           
08774                           ;underground bonus rooms area used in many levels
08774                           E_UndergroundArea3_:
08774 1E A5 0A 2E 28 27 2E 33..       .incbin "levels/E_BONUS.bin"
087A1                           
087A1                           ;level 9-4
087A1                           E_UndergroundArea4_:
087A1 27 A9 4B 07 68 29 C6 07..       .incbin "levels/E_9-4.bin"
087C8                           
087C8                           ;water area used in levels 5-2 and 6-2
087C8                           E_WaterArea1_:
087C8 3B 87 66 27 CC 27 EE 31..       .incbin "levels/E_WATER.bin"
087D9                           
087D9                           ;level 2-2/7-2
087D9                           E_WaterArea2_:
087D9 0F 01 2E 25 2B 2E 25 4B..       .incbin "levels/E_2-2_7-2.bin"
08803                           
08803                           ;water area used in level 8-4
08803                           E_WaterArea3_:
08803 47 9B CB 07 FA 1D 86 9B..       .incbin "levels/E_8-4WATER.bin"
08817                           
08817                           ;level 9-1
08817                           E_WaterArea4_:
08817 0E C2 A8 A6 0F B6 90 67..       .incbin "levels/E_9-1.bin"
08852                           
08852                           ;level 9-2
08852                           E_WaterArea5_:
08852 2B D7 C2 86 36 97 A7 07..       .incbin "levels/E_9-2.bin"
0886B                           
0886B                           ;level 9-3
0886B                           E_WaterArea6_:
0886B 95 87 DA 07 88 87 D7 06..       .incbin "levels/E_9-3.bin"
08890                           
08890                           ;AREA OBJECT DATA
08890                           
08890                           ;level 1-4/6-4
08890                           L_CastleArea1_:
08890 9B 07 05 32 06 33 07 34..       .incbin "levels/L_1-4_6-4.bin"
088F1                           
088F1                           ;level 4-4
088F1                           L_CastleArea2_:
088F1 5B 07 05 32 06 33 07 34..       .incbin "levels/L_4-4.bin"
08970                           
08970                           ;level 2-4/5-4
08970                           L_CastleArea3_:
08970 9B 07 05 32 06 33 07 34..       .incbin "levels/L_2-4_5-4.bin"
089E3                           
089E3                           ;level 3-4
089E3                           L_CastleArea4_:
089E3 9B 07 05 32 06 33 07 34..       .incbin "levels/L_3-4.bin"
08A4E                           
08A4E                           ;level 7-4
08A4E                           L_CastleArea5_:
08A4E 5B 07 05 32 06 33 07 34..       .incbin "levels/L_7-4.bin"
08AD9                           
08AD9                           ;level 8-4
08AD9                           L_CastleArea6_:
08AD9 5B 06 05 32 06 33 07 34..       .incbin "levels/L_8-4.bin"
08B4A                           
08B4A                           ;level 3-3
08B4A                           L_GroundArea1_:
08B4A 96 11 0F 26 FE 10 28 94..       .incbin "levels/L_3-3.bin"
08BAF                           
08BAF                           ;level 8-3
08BAF                           L_GroundArea2_:
08BAF 90 B1 0F 26 29 91 7E 42..       .incbin "levels/L_8-3.bin"
08C18                           
08C18                           ;level 4-1
08C18                           L_GroundArea3_:
08C18 52 21 0F 20 6E 40 58 F2..       .incbin "levels/L_4-1.bin"
08C6D                           
08C6D                           ;level 6-2
08C6D                           L_GroundArea4_:
08C6D 54 21 0F 26 A7 22 37 FB..       .incbin "levels/L_6-2.bin"
08CFC                           
08CFC                           ;level 3-1
08CFC                           L_GroundArea5_:
08CFC 52 31 0F 20 6E 66 07 82..       .incbin "levels/L_3-1.bin"
08D69                           
08D69                           ;level 1-1
08D69                           L_GroundArea6_:
08D69 50 21 07 82 47 24 57 00..       .incbin "levels/L_1-1.bin"
08DCE                           
08DCE                           ;level 1-3/5-3
08DCE                           L_GroundArea7_:
08DCE 90 11 0F 26 FE 10 2A 93..       .incbin "levels/L_1-3_5-3.bin"
08E25                           
08E25                           ;level 2-3/7-3
08E25                           L_GroundArea8_:
08E25 90 11 0F 26 6E 10 8B 17..       .incbin "levels/L_2-3_7-3.bin"
08EB0                           
08EB0                           ;level 2-1
08EB0                           L_GroundArea9_:
08EB0 52 31 0F 20 6E 40 F7 22..       .incbin "levels/L_2-1.bin"
08F15                           
08F15                           ;pipe intro area
08F15                           L_GroundArea10_:
08F15 38 11 0F 26 AD 40 3D C7..       .incbin "levels/L_PIPE.bin"
08F1E                           
08F1E                           ;level 5-1
08F1E                           L_GroundArea11_:
08F1E 92 B1 0F 20 6E 45 0D 02..       .incbin "levels/L_5-1.bin"
08F5F                           
08F5F                           ;cloud level used in levels 2-1 and 5-2
08F5F                           L_GroundArea12_:
08F5F 00 C1 4C 00 F4 4F 0D 02..       .incbin "levels/L_CLOUD1.bin"
08F74                           
08F74                           ;level 4-3
08F74                           L_GroundArea13_:
08F74 90 51 0F 26 EE 10 0B 94..       .incbin "levels/L_4-3.bin"
08FDD                           
08FDD                           ;level 6-3
08FDD                           L_GroundArea14_:
08FDD 97 11 0F 26 FE 10 2B 92..       .incbin "levels/L_6-3.bin"
09044                           
09044                           ;level 6-1
09044                           L_GroundArea15_:
09044 52 21 0F 20 6E 44 0C F1..       .incbin "levels/L_6-1.bin"
090B9                           
090B9                           ;warp zone area used in level 4-2
090B9                           L_GroundArea16_:
090B9 10 51 4C 00 C7 12 C6 42..       .incbin "levels/L_WARP.bin"
090EA                           
090EA                           ;level 8-1
090EA                           L_GroundArea17_:
090EA 92 31 0F 20 6E 40 0D 02..       .incbin "levels/L_8-1.bin"
0917D                           
0917D                           ;level 5-2
0917D                           L_GroundArea18_:
0917D 55 B1 0F 26 CF 33 07 B2..       .incbin "levels/L_5-2.bin"
091F2                           
091F2                           ;level 8-2
091F2                           L_GroundArea19_:
091F2 50 B1 0F 26 FC 00 1F B3..       .incbin "levels/L_8-2.bin"
0926D                           
0926D                           ;level 7-1
0926D                           L_GroundArea20_:
0926D 52 B1 0F 20 6E 45 39 91..       .incbin "levels/L_7-1.bin"
092C6                           
092C6                           ;cloud level used in levels 3-1 and 6-2
092C6                           L_GroundArea21_:
092C6 06 C1 4C 00 F4 4F 0D 02..       .incbin "levels/L_CLOUD2.bin"
092F1                           
092F1                           ;level 3-2
092F1                           L_GroundArea22_:
092F1 96 31 0F 26 0D 03 1A 60..       .incbin "levels/L_3-2.bin"
09326                           
09326                           ;level 1-2
09326                           L_UndergroundArea1_:
09326 48 0F 0E 01 5E 02 A7 00..       .incbin "levels/L_1-2.bin"
093C7                           
093C7                           ;level 4-2
093C7                           L_UndergroundArea2_:
093C7 48 0F 0E 01 5E 02 BC 01..       .incbin "levels/L_4-2.bin"
09464                           
09464                           ;underground bonus rooms area used in many levels
09464                           L_UndergroundArea3_:
09464 48 01 0E 01 00 5A 3E 06..       .incbin "levels/L_BONUS.bin"
094F1                           
094F1                           ;level 9-4
094F1                           L_UndergroundArea4_:
094F1 5B 07 05 32 06 33 07 34..       .incbin "levels/L_9-4.bin"
0957C                           
0957C                           ;water area used in levels 5-2 and 6-2
0957C                           L_WaterArea1_:
0957C 41 01 B4 34 C8 52 F2 51..       .incbin "levels/L_WATER.bin"
095BB                           
095BB                           ;level 2-2/7-2
095BB                           L_WaterArea2_:
095BB 41 01 B8 52 EA 41 27 B2..       .incbin "levels/L_2-2_7-2.bin"
09636                           
09636                           ;water area used in level 8-4
09636                           L_WaterArea3_:
09636 4F 0F 1E 02 39 73 5E 07..       .incbin "levels/L_8-4WATER.bin"
09651                           
09651                           ;level 9-1
09651                           L_WaterArea4_:
09651 54 21 0F 26 A7 22 37 F3..       .incbin "levels/L_9-1.bin"
096E0                           
096E0                           ;level 9-2
096E0                           L_WaterArea5_:
096E0 90 11 0F 26 FE 10 2A 93..       .incbin "levels/L_9-2.bin"
09735                           
09735                           ;level 9-3
09735                           L_WaterArea6_:
09735 90 51 0F 26 EE 10 0B 94..       .incbin "levels/L_9-3.bin"
0979E                           
0979E                           ;-------------------------------------------------------------------------------------
0979E                           
0979E                           ;GAME LEVELS DATA
0979E                           
0979E                           ;level 1-4
0979E                           E_CastleArea1:
0979E 35 9D 55 9B C9 1B 59 9D..   .db $35, $9d, $55, $9b, $c9, $1b, $59, $9d, $45, $9b, $c5, $1b, $26, $80, $45, $1b
097AE B9 1D F0 15 59 9D 0F 08..   .db $b9, $1d, $f0, $15, $59, $9d, $0f, $08, $78, $2d, $96, $28, $90, $b5, $ff
097BD                           
097BD                           ;level 2-4
097BD                           E_CastleArea2:
097BD 74 80 F0 38 A0 BB 40 BC..   .db $74, $80, $f0, $38, $a0, $bb, $40, $bc, $8c, $1d, $c9, $9d, $05, $9b, $1c, $0c
097CD 59 1B B5 1D 2C 8C 40 15..   .db $59, $1b, $b5, $1d, $2c, $8c, $40, $15, $7c, $1b, $dc, $1d, $6c, $8c, $bc, $0c
097DD 78 AD A5 28 90 B5 FF        .db $78, $ad, $a5, $28, $90, $b5, $ff
097E4                           
097E4                           ;level 3-4
097E4                           E_CastleArea3:
097E4 0F 04 9C 0C 0F 07 C5 1B..   .db $0f, $04, $9c, $0c, $0f, $07, $c5, $1b, $65, $9d, $49, $9d, $5c, $8c, $78, $2d
097F4 90 B5 FF                    .db $90, $b5, $ff
097F7                           
097F7                           ;level 4-4
097F7                           E_CastleArea4:
097F7 49 9F 67 03 79 9D A0 3A..   .db $49, $9f, $67, $03, $79, $9d, $a0, $3a, $57, $9f, $bb, $1d, $d5, $25, $0f, $05
09807 18 1D 74 00 84 00 94 00..   .db $18, $1d, $74, $00, $84, $00, $94, $00, $c6, $29, $49, $9d, $db, $05, $0f, $08
09817 05 9B 09 1D B0 38 80 95..   .db $05, $9b, $09, $1d, $b0, $38, $80, $95, $c0, $3c, $ec, $a8, $cc, $8c, $4a, $9b
09827 78 2D 90 B5 FF              .db $78, $2d, $90, $b5, $ff
0982C                           
0982C                           ;level 5-4
0982C                           E_CastleArea5:
0982C 2A A9 6B 0C CB 0C 15 9C..   .db $2a, $a9, $6b, $0c, $cb, $0c, $15, $9c, $89, $1c, $cc, $1d, $09, $9d, $f5, $1c
0983C 6B A9 AB 0C DB 29 48 9D..   .db $6b, $a9, $ab, $0c, $db, $29, $48, $9d, $9b, $0c, $5b, $8c, $a5, $1c, $49, $9d
0984C 79 1D 09 9D 6B 0C C9 1F..   .db $79, $1d, $09, $9d, $6b, $0c, $c9, $1f, $3b, $8c, $88, $95, $b9, $1c, $19, $9d
0985C 30 CC 78 2D A6 28 90 B5..   .db $30, $cc, $78, $2d, $a6, $28, $90, $b5, $ff
09865                           
09865                           ;level 6-4
09865                           E_CastleArea6:
09865 0F 02 09 1F 8B 85 2B 8C..   .db $0f, $02, $09, $1f, $8b, $85, $2b, $8c, $e9, $1b, $25, $9d, $0f, $07, $09, $1d
09875 6D 28 99 1B B5 2C 4B 8C..   .db $6d, $28, $99, $1b, $b5, $2c, $4b, $8c, $09, $9f, $fb, $15, $9d, $a8, $0f, $0c
09885 2B 0C 78 2D 90 B5 FF        .db $2b, $0c, $78, $2d, $90, $b5, $ff
0988C                           
0988C                           ;level 7-4
0988C                           E_CastleArea7:
0988C 05 9D 0D A8 DD 1D 07 AC..   .db $05, $9d, $0d, $a8, $dd, $1d, $07, $ac, $54, $2c, $a2, $2c, $f4, $2c, $42, $ac
0989C 26 9D D4 03 24 83 64 03..   .db $26, $9d, $d4, $03, $24, $83, $64, $03, $2b, $82, $4b, $02, $7b, $02, $9b, $02
098AC 5B 82 7B 02 0B 82 2B 02..   .db $5b, $82, $7b, $02, $0b, $82, $2b, $02, $c6, $1b, $28, $82, $48, $02, $a6, $1b
098BC 7B 95 85 0C 9D 9B 0F 0E..   .db $7b, $95, $85, $0c, $9d, $9b, $0f, $0e, $78, $2d, $7a, $1d, $90, $b5, $ff
098CB                           
098CB                           ;level 8-4
098CB                           E_CastleArea8:
098CB 19 9B 99 1B 2C 8C 59 1B..   .db $19, $9b, $99, $1b, $2c, $8c, $59, $1b, $c5, $0f, $0e, $83, $e0, $0f, $06, $2e
098DB 67 E7 0F 08 9B 07 0E 83..   .db $67, $e7, $0f, $08, $9b, $07, $0e, $83, $e0, $39, $0e, $87, $10, $bd, $28, $59
098EB 9F 0F 0F 34 0F 77 10 9E..   .db $9f, $0f, $0f, $34, $0f, $77, $10, $9e, $67, $f1, $0f, $12, $0e, $67, $e3, $78
098FB 2D 0F 15 3B 29 57 82 0F..   .db $2d, $0f, $15, $3b, $29, $57, $82, $0f, $18, $55, $1d, $78, $2d, $90, $b5, $ff
0990B                           
0990B                           ;level 9-3
0990B                           E_CastleArea9:
0990B 1F 01 0E 69 00 1F 0B 78..     .db $1f, $01, $0e, $69, $00, $1f, $0b, $78, $2d, $ff
09915                           
09915                           ;cloud level used in level 9-3
09915                           E_CastleArea10:
09915 1F 01 1E 68 06 FF             .db $1f, $01, $1e, $68, $06, $ff
0991B                           
0991B                           ;level A-4
0991B                           E_CastleArea11:
0991B 2A 9E 6B 0C 8D 1C EA 1F..   .db $2a, $9e, $6b, $0c, $8d, $1c, $ea, $1f, $1b, $8c, $e6, $1c, $8c, $9c, $bb, $0c
0992B F3 83 9B 8C DB 0C 1B 8C..   .db $f3, $83, $9b, $8c, $db, $0c, $1b, $8c, $6b, $0c, $bb, $0c, $0f, $09, $40, $15
0993B 78 AD 90 B5 FF              .db $78, $ad, $90, $b5, $ff
09940                           
09940                           ;level B-4
09940                           E_CastleArea12:
09940 0F 02 38 1D D9 1B 6E E1..   .db $0f, $02, $38, $1d, $d9, $1b, $6e, $e1, $21, $3a, $a8, $18, $9d, $0f, $07, $18
09950 1D 0F 09 18 1D 0F 0B 18..   .db $1d, $0f, $09, $18, $1d, $0f, $0b, $18, $1d, $7b, $15, $8e, $21, $2e, $b9, $9d
09960 0F 0E 78 2D 90 B5 FF        .db $0f, $0e, $78, $2d, $90, $b5, $ff
09967                           
09967                           ;level C-4
09967                           E_CastleArea13:
09967 05 9D 65 1D 0D A8 DD 1D..   .db $05, $9d, $65, $1d, $0d, $a8, $dd, $1d, $07, $ac, $54, $2c, $a2, $2c, $f4, $2c
09977 42 AC 26 9D D4 03 24 83..   .db $42, $ac, $26, $9d, $d4, $03, $24, $83, $64, $03, $2b, $82, $4b, $02, $7b, $02
09987 9B 02 5B 82 7B 02 0B 82..   .db $9b, $02, $5b, $82, $7b, $02, $0b, $82, $2b, $02, $c6, $1b, $28, $82, $48, $02
09997 A6 1B 7B 95 85 0C 9D 9B..   .db $a6, $1b, $7b, $95, $85, $0c, $9d, $9b, $0f, $0e, $78, $2d, $7a, $1d, $90, $b5
099A7 FF                          .db $ff
099A8                           
099A8                           ;level D-4
099A8                           E_CastleArea14:
099A8 19 9F 99 1B 2C 8C 59 1B..   .db $19, $9f, $99, $1b, $2c, $8c, $59, $1b, $c5, $0f, $0f, $04, $09, $29, $bd, $1d
099B8 0F 06 6E 2A 61 0F 09 48..   .db $0f, $06, $6e, $2a, $61, $0f, $09, $48, $2d, $46, $87, $79, $07, $8e, $63, $60
099C8 A5 07 B8 85 57 A5 8C 8C..   .db $a5, $07, $b8, $85, $57, $a5, $8c, $8c, $76, $9d, $78, $2d, $90, $b5, $ff
099D7                           
099D7                           ;level 1-1
099D7                           E_GroundArea1:
099D7 07 8E 47 03 0F 03 10 38..   .db $07, $8e, $47, $03, $0f, $03, $10, $38, $1b, $80, $53, $06, $77, $0e, $83, $83
099E7 A0 3D 90 3B 90 B7 60 BC..   .db $a0, $3d, $90, $3b, $90, $b7, $60, $bc, $b7, $0e, $ee, $42, $00, $f7, $80, $6b
099F7 83 1B 83 AB 06 FF           .db $83, $1b, $83, $ab, $06, $ff
099FD                           
099FD                           ;level 1-3
099FD                           E_GroundArea2:
099FD 96 A4 F9 24 D3 83 3A 83..   .db $96, $a4, $f9, $24, $d3, $83, $3a, $83, $5a, $03, $95, $07, $f4, $0f, $69, $a8
09A0D 33 87 86 24 C9 24 4B 83..   .db $33, $87, $86, $24, $c9, $24, $4b, $83, $67, $83, $17, $83, $56, $28, $95, $24
09A1D 0A A4 FF                    .db $0a, $a4, $ff
09A20                           
09A20                           ;level 2-1
09A20                           E_GroundArea3:
09A20 0F 02 47 0E 87 0E C7 0E..   .db $0f, $02, $47, $0e, $87, $0e, $c7, $0e, $f7, $0e, $27, $8e, $ee, $42, $25, $0f
09A30 06 AC 28 8C A8 4E B3 20..   .db $06, $ac, $28, $8c, $a8, $4e, $b3, $20, $8b, $8e, $f7, $90, $36, $90, $e5, $8e
09A40 32 8E C2 06 D2 06 E2 06..   .db $32, $8e, $c2, $06, $d2, $06, $e2, $06, $ff
09A49                           
09A49                           ;level 2-2
09A49                           E_GroundArea4:
09A49 15 8E 9B 06 E0 37 80 BC..   .db $15, $8e, $9b, $06, $e0, $37, $80, $bc, $0f, $04, $2b, $3b, $ab, $0e, $eb, $0e
09A59 0F 06 F0 37 4B 8E 6B 80..   .db $0f, $06, $f0, $37, $4b, $8e, $6b, $80, $bb, $3c, $4b, $bb, $ee, $42, $20, $1b
09A69 BC CB 00 AB 83 EB BB 0F..   .db $bc, $cb, $00, $ab, $83, $eb, $bb, $0f, $0e, $1b, $03, $9b, $37, $d4, $0e, $a3
09A79 86 B3 06 C3 06 FF           .db $86, $b3, $06, $c3, $06, $ff
09A7F                           
09A7F                           ;level 2-3
09A7F                           E_GroundArea5:
09A7F C0 BE 0F 03 38 0E 15 8F..   .db $c0, $be, $0f, $03, $38, $0e, $15, $8f, $aa, $83, $f8, $07, $0f, $07, $96, $10
09A8F 0F 09 48 10 BA 03 FF        .db $0f, $09, $48, $10, $ba, $03, $ff
09A96                           
09A96                           ;level 3-1
09A96                           E_GroundArea6:
09A96 87 85 A3 05 DB 83 FB 03..   .db $87, $85, $a3, $05, $db, $83, $fb, $03, $93, $8f, $bb, $03, $ce, $42, $42, $9b
09AA6 83 AE B3 40 DB 00 F4 0F..   .db $83, $ae, $b3, $40, $db, $00, $f4, $0f, $33, $8f, $74, $0f, $10, $bc, $f5, $0f
09AB6 2E C2 45 B7 03 F7 03 C8..   .db $2e, $c2, $45, $b7, $03, $f7, $03, $c8, $90, $ff
09AC0                           
09AC0                           ;level 3-3
09AC0                           E_GroundArea7:
09AC0 80 BE 83 03 92 10 4B 80..   .db $80, $be, $83, $03, $92, $10, $4b, $80, $b0, $3c, $07, $80, $b7, $24, $0c, $a4
09AD0 96 A9 1B 83 7B 24 B7 24..   .db $96, $a9, $1b, $83, $7b, $24, $b7, $24, $97, $83, $e2, $0f, $a9, $a9, $38, $a9
09AE0 0F 0B 74 8F FF              .db $0f, $0b, $74, $8f, $ff
09AE5                           
09AE5                           ;level 4-1
09AE5                           E_GroundArea8:
09AE5 E2 91 0F 03 42 11 0F 06..   .db $e2, $91, $0f, $03, $42, $11, $0f, $06, $72, $11, $0f, $08, $ee, $02, $60, $02
09AF5 91 EE B3 60 D3 86 FF        .db $91, $ee, $b3, $60, $d3, $86, $ff
09AFC                           
09AFC                           ;level 4-2
09AFC                           E_GroundArea9:
09AFC 0F 02 9B 02 AB 02 0F 04..   .db $0f, $02, $9b, $02, $ab, $02, $0f, $04, $13, $03, $92, $11, $60, $b7, $00, $bc
09B0C 00 BB 0B 83 CB 03 7B 85..   .db $00, $bb, $0b, $83, $cb, $03, $7b, $85, $9e, $c2, $60, $e6, $05, $0f, $0c, $62
09B1C 10                          .db $10
09B1D                           
09B1D                           ;enemy data used by pipe intro area, warp zone area and exit area
09B1D                           E_GroundArea10:
09B1D                           E_GroundArea21:
09B1D                           E_GroundArea28:
09B1D FF                          .db $ff
09B1E                           
09B1E                           ;level 4-3
09B1E                           E_GroundArea11:
09B1E E6 A9 57 A8 B5 24 19 A4..   .db $e6, $a9, $57, $a8, $b5, $24, $19, $a4, $76, $28, $a2, $0f, $95, $8f, $9d, $a8
09B2E 0F 07 09 29 55 24 8B 17..   .db $0f, $07, $09, $29, $55, $24, $8b, $17, $a9, $24, $db, $83, $04, $a9, $24, $8f
09B3E 65 0F FF                    .db $65, $0f, $ff
09B41                           
09B41                           ;level 5-1
09B41                           E_GroundArea12:
09B41 1B 82 4B 02 7B 02 AB 02..   .db $1b, $82, $4b, $02, $7b, $02, $ab, $02, $0f, $03, $f9, $0e, $d0, $be, $8e, $c4
09B51 86 F8 0E C0 BA 0F 0D 3A..   .db $86, $f8, $0e, $c0, $ba, $0f, $0d, $3a, $0e, $bb, $02, $30, $b7, $80, $bc, $c0
09B61 BC 0F 12 24 0F 54 0F CE..   .db $bc, $0f, $12, $24, $0f, $54, $0f, $ce, $3c, $80, $d3, $0f, $cb, $8e, $f9, $0e
09B71 FF                          .db $ff
09B72                           
09B72                           ;level 5-3
09B72                           E_GroundArea13:
09B72 0A AA 15 8F 44 0F 4E 44..   .db $0a, $aa, $15, $8f, $44, $0f, $4e, $44, $80, $d8, $07, $57, $90, $0f, $06, $67
09B82 24 8B 17 B9 24 AB 97 16..   .db $24, $8b, $17, $b9, $24, $ab, $97, $16, $87, $2a, $28, $84, $0f, $57, $a9, $a5
09B92 29 F5 29 A7 A4 0A A4 FF     .db $29, $f5, $29, $a7, $a4, $0a, $a4, $ff
09B9A                           
09B9A                           ;level 6-1
09B9A                           E_GroundArea14:
09B9A 07 82 67 0E 40 BD E0 38..   .db $07, $82, $67, $0e, $40, $bd, $e0, $38, $d0, $bc, $6e, $84, $a0, $9b, $05, $0f
09BAA 06 BB 05 0F 08 0B 0E 4B..   .db $06, $bb, $05, $0f, $08, $0b, $0e, $4b, $0e, $0f, $0a, $05, $29, $85, $29, $0f
09BBA 0C DD 28 FF                 .db $0c, $dd, $28, $ff
09BBE                           
09BBE                           ;level 6-3
09BBE                           E_GroundArea15:
09BBE 0F 02 28 10 E6 03 D8 90..   .db $0f, $02, $28, $10, $e6, $03, $d8, $90, $0f, $05, $85, $0f, $78, $83, $c8, $10
09BCE 18 83 58 83 F7 90 0F 0C..   .db $18, $83, $58, $83, $f7, $90, $0f, $0c, $43, $0f, $73, $8f, $ff
09BDB                           
09BDB                           ;level 7-1
09BDB                           E_GroundArea16:
09BDB A7 83 D7 03 0F 03 6B 00..   .db $a7, $83, $d7, $03, $0f, $03, $6b, $00, $0f, $06, $e3, $0f, $14, $8f, $3e, $44
09BEB C3 0B 80 87 05 AB 05 DB..   .db $c3, $0b, $80, $87, $05, $ab, $05, $db, $83, $0f, $0b, $07, $05, $13, $0e, $2b
09BFB 02 4B 02 0F 10 0B 0E B0..   .db $02, $4b, $02, $0f, $10, $0b, $0e, $b0, $37, $90, $bc, $80, $bc, $ae, $44, $c0
09C0B FF                          .db $ff
09C0C                           
09C0C                           ;level 7-2
09C0C                           E_GroundArea17:
09C0C 0A AA D5 8F 03 8F 3E 44..   .db $0a, $aa, $d5, $8f, $03, $8f, $3e, $44, $c6, $d8, $83, $0f, $06, $a6, $11, $b9
09C1C 0E 39 9D 79 1B A6 11 E8..   .db $0e, $39, $9d, $79, $1b, $a6, $11, $e8, $03, $87, $83, $16, $90, $a6, $11, $b9
09C2C 1D 05 8F 38 29 89 29 26..   .db $1d, $05, $8f, $38, $29, $89, $29, $26, $8f, $46, $29, $ff
09C38                           
09C38                           ;level 7-3
09C38                           E_GroundArea18:
09C38 0F 04 A3 10 0F 09 E3 29..   .db $0f, $04, $a3, $10, $0f, $09, $e3, $29, $0f, $0d, $55, $24, $a9, $24, $0f, $11
09C48 59 1D A9 1B 23 8F 15 9B..   .db $59, $1d, $a9, $1b, $23, $8f, $15, $9b, $ff
09C51                           
09C51                           ;level 8-1
09C51                           E_GroundArea19:
09C51 0F 01 DB 02 30 B7 80 3B..   .db $0f, $01, $db, $02, $30, $b7, $80, $3b, $1b, $8e, $4a, $0e, $eb, $03, $3b, $82
09C61 5B 02 E5 0F 14 8F 44 0F..   .db $5b, $02, $e5, $0f, $14, $8f, $44, $0f, $5b, $82, $0c, $85, $35, $8f, $06, $85
09C71 E3 05 DB 83 3E 84 E0 FF     .db $e3, $05, $db, $83, $3e, $84, $e0, $ff
09C79                           
09C79                           ;cloud level used in levels 2-1, 3-1 and 4-1
09C79                           E_GroundArea20:
09C79 0A AA 1E 22 29 1E 25 49..   .db $0a, $aa, $1e, $22, $29, $1e, $25, $49, $2e, $27, $66, $ff
09C85                           
09C85                           ;level 8-2
09C85                           E_GroundArea22:
09C85 0F 02 0A 29 F7 02 80 BC..   .db $0f, $02, $0a, $29, $f7, $02, $80, $bc, $6b, $82, $7b, $02, $9b, $02, $ab, $02
09C95 39 8E 0F 07 CE 35 EC F5..   .db $39, $8e, $0f, $07, $ce, $35, $ec, $f5, $0f, $fb, $85, $fb, $85, $3e, $c4, $e3
09CA5 A7 02 FF                    .db $a7, $02, $ff
09CA8                           
09CA8                           ;level 8-3
09CA8                           E_GroundArea23:
09CA8 09 A9 86 11 D5 10 A3 8F..   .db $09, $a9, $86, $11, $d5, $10, $a3, $8f, $d5, $29, $86, $91, $2b, $83, $58, $03
09CB8 5B 85 EB 05 3E BC E0 0F..   .db $5b, $85, $eb, $05, $3e, $bc, $e0, $0f, $09, $43, $0f, $74, $0f, $6b, $85, $db
09CC8 05 C6 A4 19 A4 12 8F        .db $05, $c6, $a4, $19, $a4, $12, $8f
09CCF                           ;another unused area
09CCF                           E_GroundArea24:
09CCF FF                          .db $ff
09CD0                           
09CD0                           ;level 9-1 starting area
09CD0                           E_GroundArea25:
09CD0 1E 05 00 FF                   .db $1e, $05, $00, $ff
09CD4                           
09CD4                           ;cloud level used with level 5-1
09CD4                           E_GroundArea29:
09CD4 0A AA 2E 2B 98 2E 36 E7..   .db $0a, $aa, $2e, $2b, $98, $2e, $36, $e7, $ff
09CDD                           
09CDD                           ;level A-1
09CDD                           E_GroundArea30:
09CDD 07 83 37 03 6B 0E E0 3D..   .db $07, $83, $37, $03, $6b, $0e, $e0, $3d, $20, $be, $6e, $2b, $00, $a7, $85, $d3
09CED 05 E7 83 24 83 27 03 49..   .db $05, $e7, $83, $24, $83, $27, $03, $49, $00, $59, $00, $10, $bb, $b0, $3b, $6e
09CFD C1 00 17 85 53 05 36 8E..   .db $c1, $00, $17, $85, $53, $05, $36, $8e, $76, $0e, $b6, $0e, $e7, $83, $63, $83
09D0D 68 03 29 83 57 03 85 03..   .db $68, $03, $29, $83, $57, $03, $85, $03, $b5, $29, $ff
09D18                           
09D18                           ;level A-3
09D18                           E_GroundArea31:
09D18 0F 04 66 07 0F 06 86 10..   .db $0f, $04, $66, $07, $0f, $06, $86, $10, $0f, $08, $55, $0f, $e5, $8f, $ff
09D27                           
09D27                           ;level B-1
09D27                           E_GroundArea32:
09D27 70 B7 CA 00 66 80 0F 04..   .db $70, $b7, $ca, $00, $66, $80, $0f, $04, $79, $0e, $ab, $0e, $ee, $2b, $20, $eb
09D37 80 40 BB FB 00 40 B7 CB..   .db $80, $40, $bb, $fb, $00, $40, $b7, $cb, $0e, $0f, $09, $4b, $00, $76, $00, $d8
09D47 00 6B 8E 73 06 83 06 C7..   .db $00, $6b, $8e, $73, $06, $83, $06, $c7, $0e, $36, $90, $c5, $06, $ff
09D55                           
09D55                           ;level B-3
09D55                           E_GroundArea33:
09D55 84 8F A7 24 D3 0F EA 24..   .db $84, $8f, $a7, $24, $d3, $0f, $ea, $24, $45, $a9, $d5, $28, $45, $a9, $84, $25
09D65 B4 8F 09 90 B5 A8 5B 97..   .db $b4, $8f, $09, $90, $b5, $a8, $5b, $97, $cd, $28, $b5, $a4, $09, $a4, $65, $28
09D75 92 90 E3 83 FF              .db $92, $90, $e3, $83, $ff
09D7A                           
09D7A                           ;level C-1
09D7A                           E_GroundArea34:
09D7A 3A 8E 5B 0E C3 8E CA 8E..   .db $3a, $8e, $5b, $0e, $c3, $8e, $ca, $8e, $0b, $8e, $4a, $0e, $de, $c1, $44, $0f
09D8A 08 49 0E EB 0E 8A 90 AB..   .db $08, $49, $0e, $eb, $0e, $8a, $90, $ab, $85, $0f, $0c, $03, $0f, $2e, $2b, $40
09D9A 67 86 FF                    .db $67, $86, $ff
09D9D                           
09D9D                           ;level C-2
09D9D                           E_GroundArea35:
09D9D 15 8F 54 07 AA 83 F8 07..   .db $15, $8f, $54, $07, $aa, $83, $f8, $07, $0f, $04, $14, $07, $96, $10, $0f, $07
09DAD 95 0F 9D A8 0B 97 09 A9..   .db $95, $0f, $9d, $a8, $0b, $97, $09, $a9, $55, $24, $a9, $24, $bb, $17, $ff
09DBC                           
09DBC                           ;level C-3
09DBC                           E_GroundArea36:
09DBC 0F 03 A6 11 A3 90 A6 91..   .db $0f, $03, $a6, $11, $a3, $90, $a6, $91, $0f, $08, $a6, $11, $e3, $a9, $0f, $0d
09DCC 55 24 A9 24 0F 11 59 1D..   .db $55, $24, $a9, $24, $0f, $11, $59, $1d, $a9, $1b, $23, $8f, $15, $9b, $ff
09DDB                           
09DDB                           ;level D-1
09DDB                           E_GroundArea37:
09DDB 87 85 9B 05 18 90 A4 8F..   .db $87, $85, $9b, $05, $18, $90, $a4, $8f, $6e, $c1, $60, $9b, $02, $d0, $3b, $80
09DEB B8 03 8E 1B 02 3B 02 0F..   .db $b8, $03, $8e, $1b, $02, $3b, $02, $0f, $08, $03, $10, $f7, $05, $6b, $85, $ff
09DFB                           
09DFB                           ;level D-2
09DFB                           E_GroundArea38:
09DFB DB 82 F3 03 10 B7 80 37..   .db $db, $82, $f3, $03, $10, $b7, $80, $37, $1a, $8e, $4b, $0e, $7a, $0e, $ab, $0e
09E0B 0F 05 F9 0E D0 BE 2E C1..   .db $0f, $05, $f9, $0e, $d0, $be, $2e, $c1, $62, $d4, $8f, $64, $8f, $7e, $2b, $60
09E1B FF                          .db $ff
09E1C                           
09E1C                           ;level D-3
09E1C                           E_GroundArea39:
09E1C 0F 03 AB 05 1B 85 A3 85..   .db $0f, $03, $ab, $05, $1b, $85, $a3, $85, $d7, $05, $0f, $08, $33, $03, $0b, $85
09E2C FB 85 8B 85 3A 8E FF        .db $fb, $85, $8b, $85, $3a, $8e, $ff
09E33                           
09E33                           ;ground level area used with level D-4
09E33                           E_GroundArea40:
09E33 0F 02 09 05 3E 41 64 2B..   .db $0f, $02, $09, $05, $3e, $41, $64, $2b, $8e, $58, $0e, $ca, $07, $34, $87, $ff
09E43                           
09E43                           ;cloud level used with levels A-1, B-1 and D-2
09E43                           E_GroundArea41:
09E43 0A AA 1E 20 03 1E 22 27..   .db $0a, $aa, $1e, $20, $03, $1e, $22, $27, $2e, $24, $48, $2e, $28, $67, $ff
09E52                           
09E52                           ;level 1-2
09E52                           E_UndergroundArea1:
09E52 0A 8E DE B4 00 E0 37 5B..   .db $0a, $8e, $de, $b4, $00, $e0, $37, $5b, $82, $2b, $a9, $aa, $29, $29, $a9, $a8
09E62 29 0F 08 F0 3C 79 A9 C5..   .db $29, $0f, $08, $f0, $3c, $79, $a9, $c5, $26, $cd, $26, $ee, $3b, $01, $67, $b4
09E72 0F 0C 2E C1 00 FF           .db $0f, $0c, $2e, $c1, $00, $ff
09E78                           
09E78                           ;warp zone area used by level 1-2
09E78                           E_UndergroundArea2:
09E78 09 A9 19 A9 DE 42 02 7B..   .db $09, $a9, $19, $a9, $de, $42, $02, $7b, $83, $ff
09E82                           
09E82                           ;underground bonus rooms used in many levels
09E82                           E_UndergroundArea3:
09E82 1E A0 0A 1E 23 2B 1E 28..   .db $1e, $a0, $0a, $1e, $23, $2b, $1e, $28, $6b, $0f, $03, $1e, $40, $08, $1e, $25
09E92 4E 0F 06 1E 22 25 1E 25..   .db $4e, $0f, $06, $1e, $22, $25, $1e, $25, $45, $ff
09E9C                           
09E9C                           ;level 5-2
09E9C                           E_UndergroundArea4:
09E9C 0B 83 B7 03 D7 03 0F 05..   .db $0b, $83, $b7, $03, $d7, $03, $0f, $05, $67, $03, $7b, $02, $9b, $02, $80, $b9
09EAC 3B 83 4E B4 80 86 2B C9..   .db $3b, $83, $4e, $b4, $80, $86, $2b, $c9, $2c, $16, $ac, $67, $b4, $de, $3b, $81
09EBC FF                          .db $ff
09EBD                           
09EBD                           ;underground bonus rooms used with worlds 5-8
09EBD                           E_UndergroundArea5:
09EBD 1E AF CA 1E 2C 85 0F 04..   .db $1e, $af, $ca, $1e, $2c, $85, $0f, $04, $1e, $2d, $a7, $1e, $2f, $ce, $1e, $35
09ECD E5 0F 07 1E 2B 87 1E 30..   .db $e5, $0f, $07, $1e, $2b, $87, $1e, $30, $c5, $ff
09ED7                           
09ED7                           ;level A-2
09ED7                           E_UndergroundArea6:
09ED7 BB A9 1B A9 69 29 B8 29..   .db $bb, $a9, $1b, $a9, $69, $29, $b8, $29, $59, $a9, $8d, $a8, $0f, $07, $15, $29
09EE7 55 AC 6B 85 0E AD 01 67..   .db $55, $ac, $6b, $85, $0e, $ad, $01, $67, $34, $ff
09EF1                           
09EF1                           ;underground bonus rooms used with worlds A-D
09EF1                           E_UndergroundArea7:
09EF1 1E A0 09 1E 27 67 0F 03..   .db $1e, $a0, $09, $1e, $27, $67, $0f, $03, $1e, $28, $68, $0f, $05, $1e, $24, $48
09F01 1E 63 68 FF                 .db $1e, $63, $68, $ff
09F05                           
09F05                           ;level 3-2
09F05                           E_WaterArea1:
09F05 0F 01 2A 07 2E 3B 41 E9..   .db $0f, $01, $2a, $07, $2e, $3b, $41, $e9, $07, $0f, $03, $6b, $07, $f9, $07, $b8
09F15 80 2A 87 4A 87 B3 0F 84..   .db $80, $2a, $87, $4a, $87, $b3, $0f, $84, $87, $47, $83, $87, $07, $0a, $87, $42
09F25 87 1B 87 6B 03 FF           .db $87, $1b, $87, $6b, $03, $ff
09F2B                           
09F2B                           ;level 6-2
09F2B                           E_WaterArea2:
09F2B 0F 01 2E 3B A1 5B 07 AB..   .db $0f, $01, $2e, $3b, $a1, $5b, $07, $ab, $07, $69, $87, $ba, $07, $fb, $87, $65
09F3B A7 6A 27 A6 A7 AC 27 1B..   .db $a7, $6a, $27, $a6, $a7, $ac, $27, $1b, $87, $88, $07, $2b, $83, $7b, $07, $a7
09F4B 90 E5 83 14 A7 19 27 77..   .db $90, $e5, $83, $14, $a7, $19, $27, $77, $07, $f8, $07, $47, $8f, $b9, $07, $ff
09F5B                           
09F5B                           ;water area used by level 4-1
09F5B                           E_WaterArea3:
09F5B 1E A7 6A 5B 82 74 07 D8..   .db $1e, $a7, $6a, $5b, $82, $74, $07, $d8, $07, $e8, $02, $0f, $04, $26, $07, $ff
09F6B                           
09F6B                           ;water area used in level 8-4
09F6B                           E_WaterArea4:
09F6B 07 9B 0A 07 B9 1B 66 9B..   .db $07, $9b, $0a, $07, $b9, $1b, $66, $9b, $78, $07, $ae, $67, $e5, $ff
09F79                           
09F79                           ;water area used in level 6-1
09F79                           E_WaterArea5:
09F79 97 87 CB 00 EE 2B F8 FE..   .db $97, $87, $cb, $00, $ee, $2b, $f8, $fe, $2d, $ad, $75, $87, $d3, $27, $d9, $27
09F89 0F 04 56 0F FF              .db $0f, $04, $56, $0f, $ff
09F8E                           
09F8E                           ;two unused levels that have the same enemy data address as a used level
09F8E                           E_GroundArea26:
09F8E                           E_GroundArea27:
09F8E                           
09F8E                           ;level 9-1 water area
09F8E                           E_WaterArea6:
09F8E 26 8F 05 AC 46 0F 1F 04..     .db $26, $8f, $05, $ac, $46, $0f, $1f, $04, $e8, $10, $38, $90, $66, $11, $fb, $3c
09F9E 9B B7 CB 85 29 87 95 07..     .db $9b, $b7, $cb, $85, $29, $87, $95, $07, $eb, $02, $0b, $82, $96, $0e, $c3, $0e
09FAE FF                            .db $ff
09FAF                           
09FAF                           ;level 9-2
09FAF                           E_WaterArea7:
09FAF 1F 01 E6 11 FF                .db $1f, $01, $e6, $11, $ff
09FB4                           
09FB4                           ;level 9-4
09FB4                           E_WaterArea8:
09FB4 3B 86 7B 00 BB 02 2B 8E..     .db $3b, $86, $7b, $00, $bb, $02, $2b, $8e, $7a, $05, $57, $87, $27, $8f, $9a, $0c
09FC4 FF                            .db $ff
09FC5                           
09FC5                           ;level B-2
09FC5                           E_WaterArea9:
09FC5 EE AD 21 26 87 F3 0E 66..   .db $ee, $ad, $21, $26, $87, $f3, $0e, $66, $87, $cb, $00, $65, $87, $0f, $06, $06
09FD5 0E 97 07 CB 00 75 87 D3..   .db $0e, $97, $07, $cb, $00, $75, $87, $d3, $27, $d9, $27, $0f, $09, $77, $1f, $46
09FE5 87 B1 0F FF                 .db $87, $b1, $0f, $ff
09FE9                           
09FE9                           ;level 1-4
09FE9                           L_CastleArea1:
09FE9 9B 07 05 32 06 33 07 34..   .db $9b, $07, $05, $32, $06, $33, $07, $34, $33, $8e, $4e, $0a, $7e, $06, $9e, $0a
09FF9 CE 06 E3 00 EE 0A 1E 87..   .db $ce, $06, $e3, $00, $ee, $0a, $1e, $87, $53, $0e, $8e, $02, $9c, $00, $c7, $0e
0A009 D7 37 57 8E 6C 05 DA 60..   .db $d7, $37, $57, $8e, $6c, $05, $da, $60, $e9, $61, $f8, $62, $fe, $0b, $43, $8e
0A019 C3 0E 43 8E B7 0E EE 09..   .db $c3, $0e, $43, $8e, $b7, $0e, $ee, $09, $fe, $0a, $3e, $86, $57, $0e, $6e, $0a
0A029 7E 06 AE 0A BE 06 FE 07..   .db $7e, $06, $ae, $0a, $be, $06, $fe, $07, $15, $e2, $55, $62, $95, $62, $fe, $0a
0A039 0D C4 CD 43 CE 09 DE 0B..   .db $0d, $c4, $cd, $43, $ce, $09, $de, $0b, $dd, $42, $fe, $02, $5d, $c7, $fd
0A048                           
0A048                           ;level 2-4
0A048                           L_CastleArea2:
0A048 9B 07 05 32 06 33 07 34..   .db $9b, $07, $05, $32, $06, $33, $07, $34, $03, $e2, $0e, $06, $1e, $0c, $7e, $0a
0A058 8E 05 8E 82 8A 8E 8E 0A..   .db $8e, $05, $8e, $82, $8a, $8e, $8e, $0a, $ee, $02, $0a, $e0, $19, $61, $23, $06
0A068 28 62 2E 0B 7E 0A 81 62..   .db $28, $62, $2e, $0b, $7e, $0a, $81, $62, $87, $30, $8e, $04, $a7, $31, $c7, $0e
0A078 D7 33 FE 03 03 8E 0E 0A..   .db $d7, $33, $fe, $03, $03, $8e, $0e, $0a, $11, $62, $1e, $04, $27, $32, $4e, $0a
0A088 51 62 57 0E 5E 04 67 34..   .db $51, $62, $57, $0e, $5e, $04, $67, $34, $9e, $0a, $a1, $62, $ae, $03, $b3, $0e
0A098 BE 0B EE 09 FE 0A 2E 82..   .db $be, $0b, $ee, $09, $fe, $0a, $2e, $82, $7a, $0e, $7e, $0a, $97, $31, $be, $04
0A0A8 DA 0E EE 0A F1 62 FE 02..   .db $da, $0e, $ee, $0a, $f1, $62, $fe, $02, $3e, $8a, $7e, $06, $ae, $0a, $ce, $06
0A0B8 FE 0A 0D C4 11 53 21 52..   .db $fe, $0a, $0d, $c4, $11, $53, $21, $52, $24, $0b, $51, $52, $61, $52, $cd, $43
0A0C8 CE 09 DD 42 DE 0B FE 02..   .db $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
0A0D3                           
0A0D3                           ;level 3-4
0A0D3                           L_CastleArea3:
0A0D3 5B 09 05 34 06 35 6E 06..   .db $5b, $09, $05, $34, $06, $35, $6e, $06, $7e, $0a, $ae, $02, $fe, $02, $0d, $01
0A0E3 0E 0E 2E 0A 6E 09 BE 0A..   .db $0e, $0e, $2e, $0a, $6e, $09, $be, $0a, $ed, $4b, $e4, $60, $ee, $0d, $5e, $82
0A0F3 78 72 A4 3D A5 3E A6 3F..   .db $78, $72, $a4, $3d, $a5, $3e, $a6, $3f, $a3, $be, $a6, $3e, $a9, $32, $e9, $3a
0A103 9C 80 A3 33 A6 33 A9 33..   .db $9c, $80, $a3, $33, $a6, $33, $a9, $33, $e5, $06, $ed, $4b, $f3, $30, $f6, $30
0A113 F9 30 FE 02 0D 05 3C 01..   .db $f9, $30, $fe, $02, $0d, $05, $3c, $01, $57, $73, $7c, $02, $93, $30, $a7, $73
0A123 B3 37 CC 01 07 83 17 03..   .db $b3, $37, $cc, $01, $07, $83, $17, $03, $27, $03, $37, $03, $64, $3b, $77, $3a
0A133 0C 80 2E 0E 9E 02 A5 62..   .db $0c, $80, $2e, $0e, $9e, $02, $a5, $62, $b6, $61, $cc, $02, $c3, $33, $ed, $4b
0A143 03 B7 07 37 83 37 87 37..   .db $03, $b7, $07, $37, $83, $37, $87, $37, $dd, $4b, $03, $b5, $07, $35, $5e, $0a
0A153 8E 02 AE 0A DE 06 FE 0A..   .db $8e, $02, $ae, $0a, $de, $06, $fe, $0a, $0d, $c4, $cd, $43, $ce, $09, $dd, $42
0A163 DE 0B FE 02 5D C7 FD        .db $de, $0b, $fe, $02, $5d, $c7, $fd
0A16A                           
0A16A                           ;level 4-4
0A16A                           L_CastleArea4:
0A16A 9B 07 05 32 06 33 07 34..   .db $9b, $07, $05, $32, $06, $33, $07, $34, $4e, $03, $5c, $02, $0c, $f1, $27, $00
0A17A 3C 74 47 0E FC 00 FE 0B..   .db $3c, $74, $47, $0e, $fc, $00, $fe, $0b, $77, $8e, $ee, $09, $fe, $0a, $45, $b2
0A18A 55 0E 99 32 B9 0E FE 02..   .db $55, $0e, $99, $32, $b9, $0e, $fe, $02, $0e, $85, $fe, $02, $16, $8e, $2e, $0c
0A19A AE 0A EE 05 1E 82 47 0E..   .db $ae, $0a, $ee, $05, $1e, $82, $47, $0e, $07, $bd, $c4, $72, $de, $0a, $fe, $02
0A1AA 03 8E 07 0E 13 3C 17 3D..   .db $03, $8e, $07, $0e, $13, $3c, $17, $3d, $e3, $03, $ee, $0a, $f3, $06, $f7, $03
0A1BA FE 0E FE 8A 38 E4 4A 72..   .db $fe, $0e, $fe, $8a, $38, $e4, $4a, $72, $68, $64, $37, $b0, $98, $64, $a8, $64
0A1CA E8 64 F8 64 0D C4 71 64..   .db $e8, $64, $f8, $64, $0d, $c4, $71, $64, $cd, $43, $ce, $09, $dd, $42, $de, $0b
0A1DA FE 02 5D C7 FD              .db $fe, $02, $5d, $c7, $fd
0A1DF                           
0A1DF                           ;level 5-4
0A1DF                           L_CastleArea5:
0A1DF 9B 07 05 32 06 33 07 33..   .db $9b, $07, $05, $32, $06, $33, $07, $33, $3e, $03, $4c, $50, $4e, $07, $57, $31
0A1EF 6E 03 7C 52 9E 07 FE 0A..   .db $6e, $03, $7c, $52, $9e, $07, $fe, $0a, $7e, $89, $9e, $0a, $ee, $09, $fe, $0b
0A1FF 13 8E 1E 09 3E 0A 6E 09..   .db $13, $8e, $1e, $09, $3e, $0a, $6e, $09, $87, $0e, $9e, $02, $c6, $07, $ca, $0e
0A20F F7 62 07 8E 08 61 17 62..   .db $f7, $62, $07, $8e, $08, $61, $17, $62, $1e, $0a, $4e, $06, $5e, $0a, $7e, $06
0A21F 8E 0A AE 06 BE 07 F3 0E..   .db $8e, $0a, $ae, $06, $be, $07, $f3, $0e, $1e, $86, $2e, $0a, $84, $37, $93, $36
0A22F A2 45 1E 89 46 0E 6E 0A..   .db $a2, $45, $1e, $89, $46, $0e, $6e, $0a, $a7, $31, $db, $60, $f7, $60, $1b, $e0
0A23F 37 31 7E 09 8E 0B A3 0E..   .db $37, $31, $7e, $09, $8e, $0b, $a3, $0e, $fe, $04, $17, $bb, $47, $0e, $77, $0e
0A24F BE 02 CE 0A 07 8E 17 31..   .db $be, $02, $ce, $0a, $07, $8e, $17, $31, $63, $31, $a7, $34, $c7, $0e, $13, $b1
0A25F 4E 09 1E 8A 7E 02 97 34..   .db $4e, $09, $1e, $8a, $7e, $02, $97, $34, $b7, $0e, $ce, $0a, $de, $02, $d8, $61
0A26F F7 62 FE 03 07 B4 17 0E..   .db $f7, $62, $fe, $03, $07, $b4, $17, $0e, $47, $62, $4e, $0a, $5e, $03, $51, $61
0A27F 67 62 77 34 B7 62 C1 61..   .db $67, $62, $77, $34, $b7, $62, $c1, $61, $da, $60, $e9, $61, $f8, $62, $fe, $0a
0A28F 0D C4 01 52 11 52 21 52..   .db $0d, $c4, $01, $52, $11, $52, $21, $52, $31, $52, $41, $52, $51, $52, $61, $52
0A29F CD 43 CE 09 DE 0B DD 42..   .db $cd, $43, $ce, $09, $de, $0b, $dd, $42, $fe, $02, $5d, $c7, $fd
0A2AC                           
0A2AC                           ;level 6-4
0A2AC                           L_CastleArea6:
0A2AC 5B 09 05 32 06 33 4E 0A..   .db $5b, $09, $05, $32, $06, $33, $4e, $0a, $87, $31, $fe, $02, $88, $f2, $c7, $33
0A2BC 0D 02 07 0E 17 34 6E 0A..   .db $0d, $02, $07, $0e, $17, $34, $6e, $0a, $8e, $02, $bf, $67, $ed, $4b, $b7, $b6
0A2CC C3 35 1E 8A 2E 02 33 3F..   .db $c3, $35, $1e, $8a, $2e, $02, $33, $3f, $37, $3f, $88, $f2, $c7, $33, $ed, $4b
0A2DC 0D 06 03 33 0F 74 47 73..   .db $0d, $06, $03, $33, $0f, $74, $47, $73, $67, $73, $7e, $09, $9e, $0a, $ed, $4b
0A2EC F7 32 07 8E 97 0E AE 00..   .db $f7, $32, $07, $8e, $97, $0e, $ae, $00, $de, $02, $e3, $35, $e7, $35, $3e, $8a
0A2FC 4E 02 53 3E 57 3E 07 8E..   .db $4e, $02, $53, $3e, $57, $3e, $07, $8e, $a7, $34, $bf, $63, $ed, $4b, $2e, $8a
0A30C FE 06 2E 88 34 33 35 33..   .db $fe, $06, $2e, $88, $34, $33, $35, $33, $6e, $06, $8e, $0c, $be, $06, $fe, $0a
0A31C 01 D2 0D 44 11 52 21 52..   .db $01, $d2, $0d, $44, $11, $52, $21, $52, $31, $52, $41, $52, $42, $0b, $51, $52
0A32C 61 52 CD 43 CE 09 DD 42..   .db $61, $52, $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
0A33B                           
0A33B                           ;level 7-4
0A33B                           L_CastleArea7:
0A33B 58 07 05 35 06 3D 07 3D..   .db $58, $07, $05, $35, $06, $3d, $07, $3d, $be, $06, $de, $0c, $f3, $3d, $03, $8e
0A34B 6E 43 CE 0A E1 67 F1 67..   .db $6e, $43, $ce, $0a, $e1, $67, $f1, $67, $01, $e7, $11, $67, $1e, $05, $28, $39
0A35B 6E 40 BE 01 C7 06 DB 0E..   .db $6e, $40, $be, $01, $c7, $06, $db, $0e, $de, $00, $1f, $80, $6f, $00, $bf, $00
0A36B 0F 80 5F 00 7E 05 A8 37..   .db $0f, $80, $5f, $00, $7e, $05, $a8, $37, $fe, $02, $24, $8e, $34, $30, $3e, $0c
0A37B 4E 43 AE 0A BE 0C EE 0A..   .db $4e, $43, $ae, $0a, $be, $0c, $ee, $0a, $fe, $0c, $2e, $8a, $3e, $0c, $7e, $02
0A38B 8E 0E 98 36 B9 34 08 BF..   .db $8e, $0e, $98, $36, $b9, $34, $08, $bf, $09, $3f, $0e, $82, $2e, $86, $4e, $0c
0A39B 9E 09 C1 62 C4 0E EE 0C..   .db $9e, $09, $c1, $62, $c4, $0e, $ee, $0c, $0e, $86, $5e, $0c, $7e, $09, $a1, $62
0A3AB A4 0E CE 0C FE 0A 28 B4..   .db $a4, $0e, $ce, $0c, $fe, $0a, $28, $b4, $a6, $31, $e8, $34, $8b, $b2, $9b, $0e
0A3BB FE 07 FE 8A 0D C4 CD 43..   .db $fe, $07, $fe, $8a, $0d, $c4, $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02
0A3CB 5D C7 FD                    .db $5d, $c7, $fd
0A3CE                           
0A3CE                           ;level 8-4
0A3CE                           L_CastleArea8:
0A3CE 5B 03 05 34 06 35 07 36..   .db $5b, $03, $05, $34, $06, $35, $07, $36, $6e, $0a, $ee, $02, $fe, $05, $0d, $01
0A3DE 17 0E 97 0E 9E 02 C6 05..   .db $17, $0e, $97, $0e, $9e, $02, $c6, $05, $fa, $30, $fe, $0a, $4e, $82, $57, $0e
0A3EE 58 62 68 62 79 61 8A 60..   .db $58, $62, $68, $62, $79, $61, $8a, $60, $8e, $0a, $f5, $31, $f9, $7b, $39, $f3
0A3FE 97 33 B5 71 39 F3 4D 48..   .db $97, $33, $b5, $71, $39, $f3, $4d, $48, $9e, $02, $ae, $05, $cd, $4a, $ed, $4b
0A40E 0E 81 17 06 39 73 5C 02..   .db $0e, $81, $17, $06, $39, $73, $5c, $02, $85, $65, $95, $32, $a9, $7b, $cc, $03
0A41E 5E 8F 6D 47 FE 02 0D 07..   .db $5e, $8f, $6d, $47, $fe, $02, $0d, $07, $39, $73, $4e, $0a, $ae, $02, $ec, $71
0A42E 07 81 17 02 39 73 E6 05..   .db $07, $81, $17, $02, $39, $73, $e6, $05, $39, $fb, $4e, $0a, $c4, $31, $eb, $61
0A43E FE 02 07 B0 1E 0A 4E 06..   .db $fe, $02, $07, $b0, $1e, $0a, $4e, $06, $57, $0e, $be, $02, $c9, $61, $da, $60
0A44E ED 4B 0E 85 0D 0E FE 0A..   .db $ed, $4b, $0e, $85, $0d, $0e, $fe, $0a, $78, $e4, $8e, $06, $b3, $06, $bf, $47
0A45E EE 0F 6D C7 0E 82 39 73..   .db $ee, $0f, $6d, $c7, $0e, $82, $39, $73, $9a, $60, $a9, $61, $ae, $06, $de, $0a
0A46E E7 03 EB 79 F7 03 FE 06..   .db $e7, $03, $eb, $79, $f7, $03, $fe, $06, $0d, $14, $fe, $0a, $5e, $82, $7f, $66
0A47E 9E 0A F8 64 FE 0B 9E 84..   .db $9e, $0a, $f8, $64, $fe, $0b, $9e, $84, $be, $05, $be, $82, $da, $60, $e9, $61
0A48E F8 62 FE 0A 0D C4 11 64..   .db $f8, $62, $fe, $0a, $0d, $c4, $11, $64, $51, $62, $cd, $43, $ce, $09, $dd, $42
0A49E DE 0B FE 02 5D C7 FD        .db $de, $0b, $fe, $02, $5d, $c7, $fd
0A4A5                           
0A4A5                           ;level 9-3
0A4A5                           L_CastleArea9:
0A4A5 55 31 0D 01 CF 33 FE 39..     .db $55, $31, $0d, $01, $cf, $33, $fe, $39, $fe, $b2, $2e, $be, $fe, $31, $29, $8f
0A4B5 9E 43 FE 30 16 B1 23 09..     .db $9e, $43, $fe, $30, $16, $b1, $23, $09, $4e, $31, $4e, $40, $d7, $e0, $e6, $61
0A4C5 FE 3E F5 62 FA 60 0C DF..     .db $fe, $3e, $f5, $62, $fa, $60, $0c, $df, $0c, $df, $0c, $d1, $1e, $3c, $2d, $40
0A4D5 4E 32 5E 36 5E 42 CE 38..     .db $4e, $32, $5e, $36, $5e, $42, $ce, $38, $0d, $0b, $8e, $36, $8e, $40, $87, $37
0A4E5 96 36 BE 3A CC 5D 06 BD..     .db $96, $36, $be, $3a, $cc, $5d, $06, $bd, $07, $3e, $a8, $64, $b8, $64, $c8, $64
0A4F5 D8 64 E8 64 F8 64 FE 31..     .db $d8, $64, $e8, $64, $f8, $64, $fe, $31, $09, $e1, $1a, $60, $6d, $41, $9f, $26
0A505 7D C7 FD                      .db $7d, $c7, $fd
0A508                           
0A508                           ;cloud level used by level 9-3
0A508                           L_CastleArea10:
0A508 00 F1 FE B5 0D 02 FE 34..     .db $00, $f1, $fe, $b5, $0d, $02, $fe, $34, $07, $cf, $ce, $00, $0d, $05, $8d, $47
0A518 FD                            .db $fd
0A519                           
0A519                           ;level A-4
0A519                           L_CastleArea11:
0A519 9B 87 05 32 06 33 07 34..   .db $9b, $87, $05, $32, $06, $33, $07, $34, $ee, $0a, $0e, $86, $28, $0e, $3e, $0a
0A529 6E 02 8B 0E 97 00 9E 0A..   .db $6e, $02, $8b, $0e, $97, $00, $9e, $0a, $ce, $06, $e8, $0e, $fe, $0a, $2e, $86
0A539 6E 0A 8E 08 E4 0E 1E 82..   .db $6e, $0a, $8e, $08, $e4, $0e, $1e, $82, $8a, $0e, $8e, $0a, $fe, $02, $1a, $e0
0A549 29 61 2E 06 3E 09 56 60..   .db $29, $61, $2e, $06, $3e, $09, $56, $60, $65, $61, $6e, $0c, $83, $60, $7e, $8a
0A559 BB 61 F9 63 27 E5 88 64..   .db $bb, $61, $f9, $63, $27, $e5, $88, $64, $eb, $61, $fe, $05, $68, $90, $0a, $90
0A569 FE 02 3A 90 3E 0A AE 02..   .db $fe, $02, $3a, $90, $3e, $0a, $ae, $02, $da, $60, $e9, $61, $f8, $62, $fe, $0a
0A579 0D C4 A1 62 B1 62 CD 43..   .db $0d, $c4, $a1, $62, $b1, $62, $cd, $43, $ce, $09, $de, $0b, $dd, $42, $fe, $02
0A589 5D C7 FD                    .db $5d, $c7, $fd
0A58C                           
0A58C                           ;level B-4
0A58C                           L_CastleArea12:
0A58C 9B 07 05 32 06 33 07 33..   .db $9b, $07, $05, $32, $06, $33, $07, $33, $3e, $0a, $41, $3b, $42, $3b, $58, $64
0A59C 7A 62 C8 31 18 E4 39 73..   .db $7a, $62, $c8, $31, $18, $e4, $39, $73, $5e, $09, $66, $3c, $0e, $82, $28, $07
0A5AC 36 0E 3E 0A AE 02 D7 0E..   .db $36, $0e, $3e, $0a, $ae, $02, $d7, $0e, $fe, $0c, $fe, $8a, $11, $e5, $21, $65
0A5BC 31 65 4E 0C FE 02 16 8E..   .db $31, $65, $4e, $0c, $fe, $02, $16, $8e, $2e, $0e, $fe, $02, $18, $fa, $3e, $0e
0A5CC FE 02 16 8E 2E 0E FE 02..   .db $fe, $02, $16, $8e, $2e, $0e, $fe, $02, $18, $fa, $3e, $0e, $fe, $02, $16, $8e
0A5DC 2E 0E FE 02 18 FA 3E 0E..   .db $2e, $0e, $fe, $02, $18, $fa, $3e, $0e, $fe, $02, $16, $8e, $2e, $0e, $fe, $02
0A5EC 18 FA 5E 0A 6E 02 7E 0A..   .db $18, $fa, $5e, $0a, $6e, $02, $7e, $0a, $b7, $0e, $ee, $07, $fe, $8a, $0d, $c4
0A5FC CD 43 CE 09 DD 42 DE 0B..   .db $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
0A609                           
0A609                           ;level C-4
0A609                           L_CastleArea13:
0A609 98 07 05 35 06 3D 07 3D..   .db $98, $07, $05, $35, $06, $3d, $07, $3d, $be, $06, $de, $0c, $f3, $3d, $03, $8e
0A619 63 0E 6E 43 CE 0A E1 67..   .db $63, $0e, $6e, $43, $ce, $0a, $e1, $67, $f1, $67, $01, $e7, $11, $67, $1e, $05
0A629 28 39 6E 40 BE 01 C7 06..   .db $28, $39, $6e, $40, $be, $01, $c7, $06, $db, $0e, $de, $00, $1f, $80, $6f, $00
0A639 BF 00 0F 80 5F 00 7E 05..   .db $bf, $00, $0f, $80, $5f, $00, $7e, $05, $a8, $37, $fe, $02, $24, $8e, $34, $30
0A649 3E 0C 4E 43 AE 0A BE 0C..   .db $3e, $0c, $4e, $43, $ae, $0a, $be, $0c, $ee, $0a, $fe, $0c, $2e, $8a, $3e, $0c
0A659 7E 02 8E 0E 98 36 B9 34..   .db $7e, $02, $8e, $0e, $98, $36, $b9, $34, $08, $bf, $09, $3f, $0e, $82, $2e, $86
0A669 4E 0C 9E 09 A6 60 C1 62..   .db $4e, $0c, $9e, $09, $a6, $60, $c1, $62, $c4, $0e, $ee, $0c, $0e, $86, $5e, $0c
0A679 7E 09 86 60 A1 62 A4 0E..   .db $7e, $09, $86, $60, $a1, $62, $a4, $0e, $c6, $60, $ce, $0c, $fe, $0a, $28, $b4
0A689 A6 31 E8 34 8B B2 9B 0E..   .db $a6, $31, $e8, $34, $8b, $b2, $9b, $0e, $fe, $07, $fe, $8a, $0d, $c4, $cd, $43
0A699 CE 09 DD 42 DE 0B FE 02..   .db $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
0A6A4                           
0A6A4                           ;level D-4
0A6A4                           L_CastleArea14:
0A6A4 5B 03 05 34 06 35 39 71..   .db $5b, $03, $05, $34, $06, $35, $39, $71, $6e, $02, $ae, $0a, $fe, $05, $17, $8e
0A6B4 97 0E 9E 02 A6 06 FA 30..   .db $97, $0e, $9e, $02, $a6, $06, $fa, $30, $fe, $0a, $4e, $82, $57, $0e, $58, $62
0A6C4 68 62 79 61 8A 60 8E 0A..   .db $68, $62, $79, $61, $8a, $60, $8e, $0a, $f5, $31, $f9, $73, $39, $f3, $b5, $71
0A6D4 B7 31 4D C8 8A 62 9A 62..   .db $b7, $31, $4d, $c8, $8a, $62, $9a, $62, $ae, $05, $bb, $0e, $cd, $4a, $fe, $82
0A6E4 77 FB DE 0F 4E 82 6D 47..   .db $77, $fb, $de, $0f, $4e, $82, $6d, $47, $39, $f3, $0c, $ea, $08, $3f, $b3, $00
0A6F4 CC 63 F9 30 69 F9 EA 60..   .db $cc, $63, $f9, $30, $69, $f9, $ea, $60, $f9, $61, $fe, $07, $de, $84, $e4, $62
0A704 E9 61 F4 62 FA 60 04 E2..   .db $e9, $61, $f4, $62, $fa, $60, $04, $e2, $14, $62, $24, $62, $34, $62, $3e, $0a
0A714 7E 0C 7E 8A 8E 08 94 36..   .db $7e, $0c, $7e, $8a, $8e, $08, $94, $36, $fe, $0a, $0d, $c4, $61, $64, $71, $64
0A724 81 64 CD 43 CE 09 DD 42..   .db $81, $64, $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
0A733                           
0A733                           ;level 1-1
0A733                           L_GroundArea1:
0A733 52 31 0F 20 6E 40 13 E4..   .db $52, $31, $0f, $20, $6e, $40, $13, $e4, $23, $24, $27, $23, $37, $07, $66, $61, $ac, $74
0A745 C7 01 0B F1 77 73 B6 04..   .db $c7, $01, $0b, $f1, $77, $73, $b6, $04, $db, $71, $5c, $82, $83, $2d, $a2, $47
0A755 A7 0A B7 29 4F B3 87 0B..   .db $a7, $0a, $b7, $29, $4f, $b3, $87, $0b, $93, $23, $cc, $06, $e3, $2c, $3a, $e0
0A765 7C 71 97 01 AC 73 E6 61..   .db $7c, $71, $97, $01, $ac, $73, $e6, $61, $0e, $b1, $b7, $f3, $dc, $02, $d3, $25
0A775 07 FB 2C 01 E7 73 2C F2..   .db $07, $fb, $2c, $01, $e7, $73, $2c, $f2, $34, $72, $57, $00, $7c, $02, $39, $f1
0A785 BF 37 33 E7 CD 41 0F A6..   .db $bf, $37, $33, $e7, $cd, $41, $0f, $a6, $ed, $47, $fd
0A790                           
0A790                           ;level 1-3
0A790                           L_GroundArea2:
0A790 50 11 0F 26 FE 10 47 92..   .db $50, $11, $0f, $26, $fe, $10, $47, $92, $56, $40, $ac, $16, $af, $12, $0f, $95
0A7A0 73 16 82 44 EC 48 BC C2..   .db $73, $16, $82, $44, $ec, $48, $bc, $c2, $1c, $b1, $b3, $16, $c2, $44, $86, $c0
0A7B0 9C 14 9F 12 A6 40 DF 15..   .db $9c, $14, $9f, $12, $a6, $40, $df, $15, $0b, $96, $43, $12, $97, $31, $d3, $12
0A7C0 03 92 27 14 63 00 C7 15..   .db $03, $92, $27, $14, $63, $00, $c7, $15, $d6, $43, $ac, $97, $af, $11, $1f, $96
0A7D0 64 13 E3 12 2E 91 9D 41..   .db $64, $13, $e3, $12, $2e, $91, $9d, $41, $ae, $42, $df, $20, $cd, $c7, $fd
0A7DF                           
0A7DF                           ;level 2-1
0A7DF                           L_GroundArea3:
0A7DF 52 21 0F 20 6E 64 4F B2..   .db $52, $21, $0f, $20, $6e, $64, $4f, $b2, $7c, $5f, $7c, $3f, $7c, $d8, $7c, $38
0A7EF 83 02 A3 00 C3 02 F7 16..   .db $83, $02, $a3, $00, $c3, $02, $f7, $16, $5c, $d6, $cf, $35, $d3, $20, $e3, $0a
0A7FF F3 20 25 B5 2C 53 6A 7A..   .db $f3, $20, $25, $b5, $2c, $53, $6a, $7a, $8c, $54, $da, $72, $fc, $50, $0c, $d2
0A80F 39 73 5C 54 AA 72 CC 53..   .db $39, $73, $5c, $54, $aa, $72, $cc, $53, $f7, $16, $33, $83, $40, $06, $5c, $5b
0A81F 09 93 27 0F 3C 5C 0A B0..   .db $09, $93, $27, $0f, $3c, $5c, $0a, $b0, $63, $27, $78, $72, $93, $09, $97, $03
0A82F A7 03 B7 22 47 81 5C 72..   .db $a7, $03, $b7, $22, $47, $81, $5c, $72, $2a, $b0, $28, $0f, $3c, $5f, $58, $31
0A83F B8 31 28 B1 3C 5B 98 31..   .db $b8, $31, $28, $b1, $3c, $5b, $98, $31, $fa, $30, $03, $b2, $20, $04, $7f, $b7
0A84F F3 67 8D C1 BF 26 AD C7..   .db $f3, $67, $8d, $c1, $bf, $26, $ad, $c7, $fd
0A858                           
0A858                           ;level 2-2
0A858                           L_GroundArea4:
0A858 54 11 0F 26 38 F2 AB 71..   .db $54, $11, $0f, $26, $38, $f2, $ab, $71, $0b, $f1, $96, $42, $ce, $10, $1e, $91
0A868 29 61 3A 60 4E 10 78 74..   .db $29, $61, $3a, $60, $4e, $10, $78, $74, $8e, $11, $06, $c3, $1a, $e0, $1e, $10
0A878 5E 11 67 63 77 63 88 62..   .db $5e, $11, $67, $63, $77, $63, $88, $62, $99, $61, $aa, $60, $be, $10, $0a, $f2
0A888 15 45 7E 11 7A 31 9A E0..   .db $15, $45, $7e, $11, $7a, $31, $9a, $e0, $ac, $02, $d9, $61, $d4, $0a, $ec, $01
0A898 D6 C2 84 C3 98 FA D3 07..   .db $d6, $c2, $84, $c3, $98, $fa, $d3, $07, $d7, $0b, $e9, $61, $ee, $10, $2e, $91
0A8A8 39 71 93 03 A6 03 BE 10..   .db $39, $71, $93, $03, $a6, $03, $be, $10, $e1, $71, $e3, $31, $5e, $91, $69, $61
0A8B8 E6 41 28 E2 99 71 AE 10..   .db $e6, $41, $28, $e2, $99, $71, $ae, $10, $ce, $11, $be, $90, $d6, $32, $3e, $91
0A8C8 5F 37 66 60 D3 67 6D C1..   .db $5f, $37, $66, $60, $d3, $67, $6d, $c1, $af, $26, $9d, $c7, $fd
0A8D5                           
0A8D5                           ;level 2-3
0A8D5                           L_GroundArea5:
0A8D5 54 11 0F 26 AF 32 D8 62..   .db $54, $11, $0f, $26, $af, $32, $d8, $62, $e8, $62, $f8, $62, $fe, $10, $fe, $43
0A8E5 0C BE F8 64 0D C8 2C 43..   .db $0c, $be, $f8, $64, $0d, $c8, $2c, $43, $98, $64, $ac, $39, $48, $e4, $6a, $62
0A8F5 7C 47 FA 62 3C B7 EA 62..   .db $7c, $47, $fa, $62, $3c, $b7, $ea, $62, $fc, $4d, $f6, $02, $03, $80, $06, $02
0A905 13 02 DA 62 0D C8 0B 17..   .db $13, $02, $da, $62, $0d, $c8, $0b, $17, $97, $16, $2c, $b1, $33, $43, $6c, $31
0A915 AC 31 17 93 73 12 CC 31..   .db $ac, $31, $17, $93, $73, $12, $cc, $31, $1a, $e2, $2c, $4b, $67, $48, $ea, $62
0A925 EE 40 0D CA 17 12 53 12..   .db $ee, $40, $0d, $ca, $17, $12, $53, $12, $be, $11, $1d, $c1, $3e, $42, $6f, $20
0A935 4D C7 FD                    .db $4d, $c7, $fd
0A938                           
0A938                           ;level 3-1
0A938                           L_GroundArea6:
0A938 52 B1 0F 20 6E 75 53 AA..   .db $52, $b1, $0f, $20, $6e, $75, $53, $aa, $57, $25, $b7, $0a, $c7, $23, $0c, $83
0A948 5C 72 87 01 C3 00 C7 20..   .db $5c, $72, $87, $01, $c3, $00, $c7, $20, $dc, $65, $0c, $87, $c3, $22, $f3, $03
0A958 03 A2 27 7B 33 03 43 23..   .db $03, $a2, $27, $7b, $33, $03, $43, $23, $52, $42, $9c, $06, $a7, $20, $c3, $23
0A968 03 A2 0C 02 33 09 39 71..   .db $03, $a2, $0c, $02, $33, $09, $39, $71, $43, $23, $77, $06, $83, $67, $a7, $73
0A978 5C 82 C9 11 07 80 1C 71..   .db $5c, $82, $c9, $11, $07, $80, $1c, $71, $98, $11, $9a, $10, $f3, $04, $16, $f4
0A988 3C 02 68 7A 8C 01 A7 73..   .db $3c, $02, $68, $7a, $8c, $01, $a7, $73, $e7, $73, $ac, $83, $09, $8f, $1c, $03
0A998 9F 37 13 E7 7C 02 AD 41..   .db $9f, $37, $13, $e7, $7c, $02, $ad, $41, $ef, $26, $0d, $0e, $39, $71, $7f, $37
0A9A8 F2 68 02 E8 12 3A 1C 00..   .db $f2, $68, $02, $e8, $12, $3a, $1c, $00, $68, $7a, $de, $3f, $6d, $c5, $fd
0A9B7                           
0A9B7                           ;level 3-3
0A9B7                           L_GroundArea7:
0A9B7 55 10 0B 1F 0F 26 D6 12..   .db $55, $10, $0b, $1f, $0f, $26, $d6, $12, $07, $9f, $33, $1a, $fb, $1f, $f7, $94
0A9C7 53 94 71 71 CC 15 CF 13..   .db $53, $94, $71, $71, $cc, $15, $cf, $13, $1f, $98, $63, $12, $9b, $13, $a9, $71
0A9D7 FB 17 09 F1 13 13 21 42..   .db $fb, $17, $09, $f1, $13, $13, $21, $42, $59, $0f, $eb, $13, $33, $93, $40, $06
0A9E7 8C 14 8F 17 93 40 CF 13..   .db $8c, $14, $8f, $17, $93, $40, $cf, $13, $0b, $94, $57, $15, $07, $93, $19, $f3
0A9F7 C6 43 C7 13 D3 03 E3 03..   .db $c6, $43, $c7, $13, $d3, $03, $e3, $03, $33, $b0, $4a, $72, $55, $46, $73, $31
0AA07 A8 74 E3 12 8E 91 AD 41..   .db $a8, $74, $e3, $12, $8e, $91, $ad, $41, $ce, $42, $ef, $20, $dd, $c7, $fd
0AA16                           
0AA16                           ;level 4-1
0AA16                           L_GroundArea8:
0AA16 52 21 0F 20 6E 63 A9 F1..   .db $52, $21, $0f, $20, $6e, $63, $a9, $f1, $fb, $71, $22, $83, $37, $0b, $36, $50
0AA26 39 51 B8 62 57 F3 E8 02..   .db $39, $51, $b8, $62, $57, $f3, $e8, $02, $f8, $02, $08, $82, $18, $02, $2d, $4a
0AA36 28 02 38 02 48 00 A8 0F..   .db $28, $02, $38, $02, $48, $00, $a8, $0f, $aa, $30, $bc, $5a, $6a, $b0, $4f, $b6
0AA46 B7 04 9A B0 AC 71 C7 01..   .db $b7, $04, $9a, $b0, $ac, $71, $c7, $01, $e6, $74, $0d, $09, $46, $02, $56, $00
0AA56 6C 01 84 79 86 02 96 02..   .db $6c, $01, $84, $79, $86, $02, $96, $02, $a4, $71, $a6, $02, $b6, $02, $c4, $71
0AA66 C6 02 D6 02 39 F1 6C 00..   .db $c6, $02, $d6, $02, $39, $f1, $6c, $00, $77, $02, $a3, $09, $ac, $00, $b8, $72
0AA76 DC 01 07 F3 4C 00 6F 37..   .db $dc, $01, $07, $f3, $4c, $00, $6f, $37, $e3, $03, $e6, $03, $5d, $ca, $6c, $00
0AA86 7D 41 CF 26 9D C7 FD        .db $7d, $41, $cf, $26, $9d, $c7, $fd
0AA8D                           
0AA8D                           ;level 4-2
0AA8D                           L_GroundArea9:
0AA8D 50 A1 0F 26 17 91 19 11..   .db $50, $a1, $0f, $26, $17, $91, $19, $11, $48, $00, $68, $11, $6a, $10, $96, $14
0AA9D D8 0A E8 02 F8 02 DC 81..   .db $d8, $0a, $e8, $02, $f8, $02, $dc, $81, $6c, $81, $89, $0f, $9c, $00, $c3, $29
0AAAD F8 62 47 A7 C6 61 0D 07..   .db $f8, $62, $47, $a7, $c6, $61, $0d, $07, $56, $74, $b7, $00, $b9, $11, $cc, $76
0AABD ED 4A 1C 80 37 01 3A 10..   .db $ed, $4a, $1c, $80, $37, $01, $3a, $10, $de, $20, $e9, $0b, $ee, $21, $c8, $bc
0AACD 9C F6 BC 00 CB 7A EB 72..   .db $9c, $f6, $bc, $00, $cb, $7a, $eb, $72, $0c, $82, $39, $71, $b7, $63, $cc, $03
0AADD E6 60 26 E0 4A 30 53 31..   .db $e6, $60, $26, $e0, $4a, $30, $53, $31, $5c, $58, $ed, $41, $2f, $a6, $1d, $c7
0AAED FD                          .db $fd
0AAEE                           
0AAEE                           ;pipe intro area
0AAEE                           L_GroundArea10:
0AAEE 38 11 0F 26 AD 40 3D C7..   .db $38, $11, $0f, $26, $ad, $40, $3d, $c7, $fd
0AAF7                           
0AAF7                           ;level 4-3
0AAF7                           L_GroundArea11:
0AAF7 50 11 0F 26 FE 10 8B 93..   .db $50, $11, $0f, $26, $fe, $10, $8b, $93, $a9, $0f, $14, $c1, $cc, $16, $cf, $11
0AB07 2F 95 B7 14 C7 96 D6 44..   .db $2f, $95, $b7, $14, $c7, $96, $d6, $44, $2b, $92, $39, $0f, $72, $41, $a7, $00
0AB17 1B 95 97 13 6C 95 6F 11..   .db $1b, $95, $97, $13, $6c, $95, $6f, $11, $a2, $40, $bf, $15, $c2, $40, $0b, $9f
0AB27 53 16 62 44 72 C2 9B 1D..   .db $53, $16, $62, $44, $72, $c2, $9b, $1d, $b7, $e0, $ed, $4a, $03, $e0, $8e, $11
0AB37 9D 41 BE 42 EF 20 CD C7..   .db $9d, $41, $be, $42, $ef, $20, $cd, $c7, $fd
0AB40                           
0AB40                           ;level 5-1
0AB40                           L_GroundArea12:
0AB40 52 B1 0F 20 6E 75 CC 73..   .db $52, $b1, $0f, $20, $6e, $75, $cc, $73, $a3, $b3, $bf, $74, $0c, $84, $83, $3f
0AB50 9F 74 EF 71 EC 01 2F F1..   .db $9f, $74, $ef, $71, $ec, $01, $2f, $f1, $2c, $01, $6f, $71, $6c, $01, $a8, $91
0AB60 AA 10 77 FB 56 F4 39 F1..   .db $aa, $10, $77, $fb, $56, $f4, $39, $f1, $bf, $37, $33, $e7, $43, $04, $47, $03
0AB70 6C 05 C3 67 D3 67 E3 67..   .db $6c, $05, $c3, $67, $d3, $67, $e3, $67, $ed, $4c, $fc, $07, $73, $e7, $83, $67
0AB80 93 67 A3 67 BC 08 43 E7..   .db $93, $67, $a3, $67, $bc, $08, $43, $e7, $53, $67, $dc, $02, $59, $91, $c3, $33
0AB90 D9 71 DF 72 2D CD 5B 71..   .db $d9, $71, $df, $72, $2d, $cd, $5b, $71, $9b, $71, $3b, $f1, $a7, $c2, $db, $71
0ABA0 0D 10 9B 71 0A B0 1C 04..   .db $0d, $10, $9b, $71, $0a, $b0, $1c, $04, $67, $63, $76, $64, $85, $65, $94, $66
0ABB0 A3 67 B3 67 CC 09 73 A3..   .db $a3, $67, $b3, $67, $cc, $09, $73, $a3, $87, $22, $b3, $09, $d6, $83, $e3, $03
0ABC0 FE 3F 0D 15 DE 31 EC 01..   .db $fe, $3f, $0d, $15, $de, $31, $ec, $01, $03, $f7, $9d, $41, $df, $26, $0d, $18
0ABD0 39 71 7F 37 F2 68 01 E9..   .db $39, $71, $7f, $37, $f2, $68, $01, $e9, $11, $39, $68, $7a, $de, $3f, $6d, $c5
0ABE0 FD                          .db $fd
0ABE1                           
0ABE1                           ;level 5-3
0ABE1                           L_GroundArea13:
0ABE1 50 11 0F 26 DF 32 FE 10..   .db $50, $11, $0f, $26, $df, $32, $fe, $10, $0d, $01, $98, $74, $c8, $13, $52, $e1
0ABF1 63 31 61 79 C6 61 06 E1..   .db $63, $31, $61, $79, $c6, $61, $06, $e1, $8b, $71, $ab, $71, $e4, $19, $eb, $19
0AC01 60 86 C8 13 CD 4B 39 F3..   .db $60, $86, $c8, $13, $cd, $4b, $39, $f3, $98, $13, $17, $f5, $7c, $15, $7f, $13
0AC11 CF 15 D4 40 0B 9A 23 16..   .db $cf, $15, $d4, $40, $0b, $9a, $23, $16, $32, $44, $a3, $95, $b2, $43, $0d, $0a
0AC21 27 14 3D 4A A4 40 BC 16..   .db $27, $14, $3d, $4a, $a4, $40, $bc, $16, $bf, $13, $c4, $40, $04, $c0, $1f, $16
0AC31 24 40 43 31 CE 11 DD 41..   .db $24, $40, $43, $31, $ce, $11, $dd, $41, $0e, $d2, $3f, $20, $3d, $c7, $fd
0AC40                            
0AC40                           ;level 6-1
0AC40                           L_GroundArea14:
0AC40 52 A1 0F 20 6E 40 D6 61..   .db $52, $a1, $0f, $20, $6e, $40, $d6, $61, $e7, $07, $f7, $21, $16, $e1, $34, $63
0AC50 47 21 54 04 67 0A 74 63..   .db $47, $21, $54, $04, $67, $0a, $74, $63, $dc, $01, $06, $e1, $17, $26, $86, $61
0AC60 66 C2 58 C1 F7 03 04 F6..   .db $66, $c2, $58, $c1, $f7, $03, $04, $f6, $8a, $10, $9c, $04, $e8, $62, $f9, $61
0AC70 0A E0 53 31 5F 73 7B 71..   .db $0a, $e0, $53, $31, $5f, $73, $7b, $71, $77, $25, $fc, $e2, $17, $aa, $23, $00
0AC80 3C 67 B3 01 CC 63 DB 71..   .db $3c, $67, $b3, $01, $cc, $63, $db, $71, $df, $73, $fc, $00, $4f, $b7, $ca, $7a
0AC90 C5 31 EC 54 3C DC 5D 4C..   .db $c5, $31, $ec, $54, $3c, $dc, $5d, $4c, $0f, $b3, $47, $63, $6b, $f1, $8c, $0a
0ACA0 39 F1 EC 03 F0 33 0F E2..   .db $39, $f1, $ec, $03, $f0, $33, $0f, $e2, $29, $73, $49, $61, $58, $62, $67, $73
0ACB0 85 65 94 66 A3 77 AD 4D..   .db $85, $65, $94, $66, $a3, $77, $ad, $4d, $4d, $c1, $6f, $26, $5d, $c7, $fd
0ACBF                           
0ACBF                           ;level 6-3
0ACBF                           L_GroundArea15:
0ACBF 50 11 0F 26 AF 32 D8 62..   .db $50, $11, $0f, $26, $af, $32, $d8, $62, $de, $10, $08, $e4, $0e, $43, $5a, $62
0ACCF 6C 4C 86 43 AD 48 3A E2..   .db $6c, $4c, $86, $43, $ad, $48, $3a, $e2, $53, $42, $88, $64, $9c, $36, $08, $e4
0ACDF 4A 62 5C 4D 3A E2 9C 32..   .db $4a, $62, $5c, $4d, $3a, $e2, $9c, $32, $fc, $41, $3c, $b1, $83, $00, $ac, $42
0ACEF 2A E2 3C 46 AA 62 BC 4E..   .db $2a, $e2, $3c, $46, $aa, $62, $bc, $4e, $c6, $43, $46, $c3, $aa, $62, $bd, $48
0ACFF 0B 96 47 07 C7 12 3C C2..   .db $0b, $96, $47, $07, $c7, $12, $3c, $c2, $9c, $41, $cd, $48, $dc, $32, $4c, $c2
0AD0F BC 32 1C B1 5A 62 6C 44..   .db $bc, $32, $1c, $b1, $5a, $62, $6c, $44, $76, $43, $ba, $62, $be, $40, $dc, $32
0AD1F 5D CA 73 12 E3 12 8E 91..   .db $5d, $ca, $73, $12, $e3, $12, $8e, $91, $9d, $41, $be, $42, $ef, $20, $cd, $c7
0AD2F FD                          .db $fd
0AD30                           
0AD30                           ;level 7-1
0AD30                           L_GroundArea16:
0AD30 52 B1 0F 20 6E 76 03 B1..   .db $52, $b1, $0f, $20, $6e, $76, $03, $b1, $09, $71, $0f, $71, $6f, $33, $a7, $63
0AD40 B7 34 BC 0E 4D CC 03 A6..   .db $b7, $34, $bc, $0e, $4d, $cc, $03, $a6, $08, $72, $3f, $72, $6d, $4c, $73, $07
0AD50 77 73 83 27 AC 00 BF 73..   .db $77, $73, $83, $27, $ac, $00, $bf, $73, $3c, $80, $9a, $30, $ac, $5b, $c6, $3c
0AD60 6A B0 75 10 96 74 B6 0A..   .db $6a, $b0, $75, $10, $96, $74, $b6, $0a, $da, $30, $e3, $28, $ec, $5b, $ed, $48
0AD70 AA B0 33 B4 51 79 AD 4A..   .db $aa, $b0, $33, $b4, $51, $79, $ad, $4a, $dd, $4d, $e3, $2c, $0c, $fa, $73, $07
0AD80 B3 04 CB 71 EC 07 0D 0A..   .db $b3, $04, $cb, $71, $ec, $07, $0d, $0a, $39, $71, $df, $33, $ca, $b0, $d6, $10
0AD90 D7 30 DC 0C 03 B1 AD 41..   .db $d7, $30, $dc, $0c, $03, $b1, $ad, $41, $ef, $26, $ed, $c7, $39, $f1, $0d, $10
0ADA0 7D 4C 0D 13 A8 11 AA 10..   .db $7d, $4c, $0d, $13, $a8, $11, $aa, $10, $1c, $83, $d7, $7b, $f3, $67, $5d, $cd
0ADB0 6D 47 FD                    .db $6d, $47, $fd
0ADB3                           
0ADB3                           ;level 7-2
0ADB3                           L_GroundArea17:
0ADB3 56 11 0F 26 DF 32 FE 11..   .db $56, $11, $0f, $26, $df, $32, $fe, $11, $0d, $01, $0c, $5f, $03, $80, $0c, $52
0ADC3 29 15 7C 5B 23 B2 29 1F..   .db $29, $15, $7c, $5b, $23, $b2, $29, $1f, $31, $79, $1c, $de, $48, $3b, $ed, $4b
0ADD3 39 F1 CF B3 FE 10 37 8E..   .db $39, $f1, $cf, $b3, $fe, $10, $37, $8e, $77, $0e, $9e, $11, $a8, $34, $a9, $34
0ADE3 AA 34 F8 62 FE 10 37 B6..   .db $aa, $34, $f8, $62, $fe, $10, $37, $b6, $de, $11, $e7, $63, $f8, $62, $09, $e1
0ADF3 0E 10 47 36 B7 0E BE 91..   .db $0e, $10, $47, $36, $b7, $0e, $be, $91, $ca, $32, $ee, $10, $1d, $ca, $7e, $11
0AE03 83 77 9E 10 1E 91 2D 41..   .db $83, $77, $9e, $10, $1e, $91, $2d, $41, $4f, $26, $4d, $c7, $fd
0AE10                           
0AE10                           ;level 7-3
0AE10                           L_GroundArea18:
0AE10 57 11 0F 26 FE 10 4B 92..   .db $57, $11, $0f, $26, $fe, $10, $4b, $92, $59, $0f, $ad, $4c, $d3, $93, $0b, $94
0AE20 29 0F 7B 93 99 0F 0D 06..   .db $29, $0f, $7b, $93, $99, $0f, $0d, $06, $27, $12, $35, $0f, $23, $b1, $57, $75
0AE30 A3 31 AB 71 F7 75 23 B1..   .db $a3, $31, $ab, $71, $f7, $75, $23, $b1, $87, $13, $95, $0f, $0d, $0a, $23, $35
0AE40 38 13 55 00 9B 16 0B 96..   .db $38, $13, $55, $00, $9b, $16, $0b, $96, $c7, $75, $3b, $92, $49, $0f, $ad, $4c
0AE50 29 92 52 40 6C 15 6F 11..   .db $29, $92, $52, $40, $6c, $15, $6f, $11, $72, $40, $bf, $15, $03, $93, $0a, $13
0AE60 12 41 8B 12 99 0F 0D 10..   .db $12, $41, $8b, $12, $99, $0f, $0d, $10, $47, $16, $46, $45, $b3, $32, $13, $b1
0AE70 57 0E A7 0E D3 31 53 B1..   .db $57, $0e, $a7, $0e, $d3, $31, $53, $b1, $a6, $31, $03, $b2, $13, $0e, $8d, $4d
0AE80 AE 11 BD 41 EE 52 0F A0..   .db $ae, $11, $bd, $41, $ee, $52, $0f, $a0, $dd, $47, $fd
0AE8B                           
0AE8B                           ;level 8-1
0AE8B                           L_GroundArea19:
0AE8B 52 A1 0F 20 6E 65 57 F3..   .db $52, $a1, $0f, $20, $6e, $65, $57, $f3, $60, $21, $6f, $62, $ac, $75, $07, $80
0AE9B 1C 76 87 01 9C 70 B0 33..   .db $1c, $76, $87, $01, $9c, $70, $b0, $33, $cf, $66, $57, $e3, $6c, $04, $cd, $4c
0AEAB 9A B0 AC 0C 83 B1 8F 74..   .db $9a, $b0, $ac, $0c, $83, $b1, $8f, $74, $bd, $4d, $f8, $11, $fa, $10, $83, $87
0AEBB 93 22 9F 74 59 F1 89 61..   .db $93, $22, $9f, $74, $59, $f1, $89, $61, $a9, $61, $bc, $0c, $67, $a0, $eb, $71
0AECB 77 87 7A 10 86 51 95 52..   .db $77, $87, $7a, $10, $86, $51, $95, $52, $a4, $53, $b6, $04, $b3, $24, $26, $85
0AEDB 4A 10 53 23 5C 00 6F 73..   .db $4a, $10, $53, $23, $5c, $00, $6f, $73, $93, $08, $07, $fb, $2c, $04, $33, $30
0AEEB 74 76 EB 71 57 8B 6C 02..   .db $74, $76, $eb, $71, $57, $8b, $6c, $02, $96, $74, $e3, $30, $0c, $86, $7d, $41
0AEFB BF 26 BD C7 FD              .db $bf, $26, $bd, $c7, $fd
0AF00                           
0AF00                           ;cloud level used in levels 2-1, 3-1 and 4-1
0AF00                           L_GroundArea20:
0AF00 00 C1 4C 00 03 CF 00 D7..   .db $00, $c1, $4c, $00, $03, $cf, $00, $d7, $23, $4d, $07, $af, $2a, $4c, $03, $cf
0AF10 3E 80 F3 4A BB C2 BD C7..   .db $3e, $80, $f3, $4a, $bb, $c2, $bd, $c7, $fd
0AF19                           
0AF19                           ;warp zone area used in levels 1-2 and 5-2
0AF19                           L_GroundArea21:
0AF19 10 00 0B 13 5B 14 6A 42..   .db $10, $00, $0b, $13, $5b, $14, $6a, $42, $c7, $12, $c6, $42, $1b, $94, $2a, $42
0AF29 53 13 62 41 97 17 A6 45..   .db $53, $13, $62, $41, $97, $17, $a6, $45, $6e, $81, $8f, $37, $02, $e8, $12, $3a
0AF39 68 7A DE 0F 6D C5 FD        .db $68, $7a, $de, $0f, $6d, $c5, $fd
0AF40                           
0AF40                           ;level 8-2
0AF40                           L_GroundArea22:
0AF40 50 61 0F 26 BB F1 DC 06..   .db $50, $61, $0f, $26, $bb, $f1, $dc, $06, $23, $87, $b5, $71, $b7, $31, $d7, $28
0AF50 06 C5 67 08 0D 05 39 71..   .db $06, $c5, $67, $08, $0d, $05, $39, $71, $7c, $00, $9e, $62, $b6, $0b, $e6, $08
0AF60 4E E0 5D 4C 59 0F 6C 02..   .db $4e, $e0, $5d, $4c, $59, $0f, $6c, $02, $93, $67, $ac, $56, $ad, $4c, $1f, $b1
0AF70 3C 01 98 0A 9E 20 A8 21..   .db $3c, $01, $98, $0a, $9e, $20, $a8, $21, $f3, $09, $0e, $a1, $27, $20, $3e, $62
0AF80 56 08 7D 4D C6 08 3E E0..   .db $56, $08, $7d, $4d, $c6, $08, $3e, $e0, $9e, $62, $b6, $08, $1e, $e0, $4c, $00
0AF90 6C 00 A7 7B DE 2F 6D C7..   .db $6c, $00, $a7, $7b, $de, $2f, $6d, $c7, $fe, $10, $0b, $93, $5b, $15, $b7, $12
0AFA0 03 91 AB 1F BD 41 EF 26..   .db $03, $91, $ab, $1f, $bd, $41, $ef, $26, $ad, $c7, $fd
0AFAB                           
0AFAB                           ;level 8-3
0AFAB                           L_GroundArea23:
0AFAB 50 50 0F 26 0B 1F 57 92..   .db $50, $50, $0f, $26, $0b, $1f, $57, $92, $8b, $12, $d2, $14, $4b, $92, $59, $0f
0AFBB 0B 95 BB 1F BE 52 58 E2..   .db $0b, $95, $bb, $1f, $be, $52, $58, $e2, $9e, $50, $97, $08, $bb, $1f, $ae, $d2
0AFCB B6 08 BB 1F DD 4A F6 07..   .db $b6, $08, $bb, $1f, $dd, $4a, $f6, $07, $26, $89, $8e, $50, $98, $62, $eb, $11
0AFDB 07 F3 0B 1D 2E 52 47 0A..   .db $07, $f3, $0b, $1d, $2e, $52, $47, $0a, $ce, $50, $eb, $1f, $ee, $52, $5e, $d0
0AFEB D9 0F AB 9F BE 52 8E D0..   .db $d9, $0f, $ab, $9f, $be, $52, $8e, $d0, $ab, $1d, $ae, $52, $36, $8b, $56, $08
0AFFB 5E 50 DC 15 DF 12 2F 95..   .db $5e, $50, $dc, $15, $df, $12, $2f, $95, $c3, $31, $5b, $9f, $6d, $41, $8e, $52
0B00B AF 20 AD C7                 .db $af, $20, $ad, $c7
0B00F                           
0B00F                           ;three unused levels
0B00F                           L_GroundArea24:
0B00F                           L_GroundArea26:
0B00F                           L_GroundArea27:
0B00F FD                          .db $fd
0B010                           
0B010                           ;level 9-1 starting area
0B010                           L_GroundArea25:
0B010 50 02 9F 38 EE 01 12 B9..     .db $50, $02, $9f, $38, $ee, $01, $12, $b9, $77, $7b, $de, $0f, $6d, $c7, $fd
0B01F                           
0B01F                           ;exit area used in levels 1-2, 3-2, 5-2, 6-2, A-2 and B-2
0B01F                           L_GroundArea28:
0B01F 90 31 39 F1 BF 37 33 E7..   .db $90, $31, $39, $f1, $bf, $37, $33, $e7, $a3, $03, $a7, $03, $cd, $41, $0f, $a6
0B02F ED 47 FD                    .db $ed, $47, $fd
0B032                           
0B032                           ;cloud level used with level 5-1
0B032                           L_GroundArea29:
0B032 00 C1 4C 00 F3 4F FA C6..   .db $00, $c1, $4c, $00, $f3, $4f, $fa, $c6, $68, $a0, $69, $20, $6a, $20, $7a, $47
0B042 F8 20 F9 20 FA 20 0A CF..   .db $f8, $20, $f9, $20, $fa, $20, $0a, $cf, $b4, $49, $55, $a0, $56, $20, $73, $47
0B052 F5 20 F6 20 22 A1 41 48..   .db $f5, $20, $f6, $20, $22, $a1, $41, $48, $52, $20, $72, $20, $92, $20, $b2, $20
0B062 FE 00 9B C2 AD C7 FD        .db $fe, $00, $9b, $c2, $ad, $c7, $fd
0B069                           
0B069                           ;level A-1
0B069                           L_GroundArea30:
0B069 52 71 0F 20 6E 70 E3 64..   .db $52, $71, $0f, $20, $6e, $70, $e3, $64, $fc, $61, $fc, $71, $13, $86, $2c, $61
0B079 2C 71 43 64 B2 22 B5 62..   .db $2c, $71, $43, $64, $b2, $22, $b5, $62, $c7, $28, $22, $a2, $52, $09, $56, $61
0B089 6C 03 DB 71 FC 03 F3 20..   .db $6c, $03, $db, $71, $fc, $03, $f3, $20, $03, $a4, $0f, $71, $40, $0c, $8c, $74
0B099 9C 66 D7 01 EC 71 89 E1..   .db $9c, $66, $d7, $01, $ec, $71, $89, $e1, $b6, $61, $b9, $2a, $c7, $26, $f4, $23
0B0A9 67 E2 E8 F2 78 82 88 01..   .db $67, $e2, $e8, $f2, $78, $82, $88, $01, $98, $02, $a8, $02, $b8, $02, $03, $a6
0B0B9 07 26 21 79 4B 71 CF 33..   .db $07, $26, $21, $79, $4b, $71, $cf, $33, $06, $e4, $16, $2a, $39, $71, $58, $45
0B0C9 5A 45 C6 07 DC 04 3F E7..   .db $5a, $45, $c6, $07, $dc, $04, $3f, $e7, $3b, $71, $30, $31, $8c, $71, $ac, $01
0B0D9 E7 63 39 8F 63 20 65 0B..   .db $e7, $63, $39, $8f, $63, $20, $65, $0b, $68, $62, $8c, $00, $0c, $81, $29, $63
0B0E9 3C 01 57 65 6C 01 85 67..   .db $3c, $01, $57, $65, $6c, $01, $85, $67, $9c, $04, $1d, $c1, $5f, $26, $3d, $c7
0B0F9 FD                          .db $fd
0B0FA                           
0B0FA                           ;level A-3
0B0FA                           L_GroundArea31:
0B0FA 50 50 0B 1F 0F 26 19 96..   .db $50, $50, $0b, $1f, $0f, $26, $19, $96, $84, $43, $b7, $1f, $5d, $cc, $6d, $48
0B10A E0 42 E3 12 39 9C 56 43..   .db $e0, $42, $e3, $12, $39, $9c, $56, $43, $47, $9b, $a4, $12, $c1, $06, $ed, $4d
0B11A F4 42 1B 98 B7 13 02 C2..   .db $f4, $42, $1b, $98, $b7, $13, $02, $c2, $03, $12, $47, $1f, $ad, $48, $63, $9c
0B12A 82 48 76 93 08 94 8E 11..   .db $82, $48, $76, $93, $08, $94, $8e, $11, $b0, $03, $c9, $0f, $1d, $c1, $2d, $4a
0B13A 4E 42 6F 20 0D 0E 0E 40..   .db $4e, $42, $6f, $20, $0d, $0e, $0e, $40, $39, $71, $7f, $37, $f2, $68, $01, $e9
0B14A 11 39 68 7A DE 1F 6D C5..   .db $11, $39, $68, $7a, $de, $1f, $6d, $c5, $fd
0B153                           
0B153                           ;level B-1
0B153                           L_GroundArea32:
0B153 52 21 0F 20 6E 60 6C F6..   .db $52, $21, $0f, $20, $6e, $60, $6c, $f6, $ca, $30, $dc, $02, $08, $f2, $37, $04
0B163 56 74 7C 00 DC 01 E7 25..   .db $56, $74, $7c, $00, $dc, $01, $e7, $25, $47, $8b, $49, $20, $6c, $02, $96, $74
0B173 06 82 36 02 66 00 A7 22..   .db $06, $82, $36, $02, $66, $00, $a7, $22, $dc, $02, $0a, $e0, $63, $22, $78, $72
0B183 93 09 97 03 A3 25 A7 03..   .db $93, $09, $97, $03, $a3, $25, $a7, $03, $b6, $24, $03, $a2, $5c, $75, $65, $71
0B193 7C 00 9C 00 63 A2 67 20..   .db $7c, $00, $9c, $00, $63, $a2, $67, $20, $77, $03, $87, $20, $93, $0a, $97, $03
0B1A3 A3 22 A7 20 B7 03 BC 00..   .db $a3, $22, $a7, $20, $b7, $03, $bc, $00, $c7, $20, $dc, $00, $fc, $01, $19, $8f
0B1B3 1E 20 46 22 4C 61 63 00..   .db $1e, $20, $46, $22, $4c, $61, $63, $00, $8e, $21, $d7, $73, $46, $a6, $4c, $62
0B1C3 68 62 73 01 8C 62 D8 62..   .db $68, $62, $73, $01, $8c, $62, $d8, $62, $43, $a9, $c7, $73, $ec, $06, $57, $f3
0B1D3 7C 00 B5 65 C5 65 DC 00..   .db $7c, $00, $b5, $65, $c5, $65, $dc, $00, $e3, $67, $7d, $c1, $bf, $26, $ad, $c7
0B1E3 FD                          .db $fd
0B1E4                           
0B1E4                           ;level B-3
0B1E4                           L_GroundArea33:
0B1E4 90 10 0B 1B 0F 26 07 94..   .db $90, $10, $0b, $1b, $0f, $26, $07, $94, $bc, $14, $bf, $13, $c7, $40, $ff, $16
0B1F4 D1 80 C3 94 CB 17 C2 44..   .db $d1, $80, $c3, $94, $cb, $17, $c2, $44, $29, $8f, $77, $31, $0b, $96, $76, $32
0B204 C7 75 13 F7 1B 61 2B 61..   .db $c7, $75, $13, $f7, $1b, $61, $2b, $61, $4b, $12, $59, $0f, $3b, $b0, $3a, $40
0B214 43 12 7A 40 7B 30 B5 41..   .db $43, $12, $7a, $40, $7b, $30, $b5, $41, $b6, $20, $c6, $07, $f3, $13, $03, $92
0B224 6B 12 79 0F CC 15 CF 11..   .db $6b, $12, $79, $0f, $cc, $15, $cf, $11, $1f, $95, $c3, $14, $b3, $95, $a3, $95
0B234 4D CA 6B 61 7E 11 8D 41..   .db $4d, $ca, $6b, $61, $7e, $11, $8d, $41, $be, $42, $df, $20, $bd, $c7, $fd
0B243                           
0B243                           ;level C-1
0B243                           L_GroundArea34:
0B243 52 31 0F 20 6E 74 0D 02..   .db $52, $31, $0f, $20, $6e, $74, $0d, $02, $03, $33, $1f, $72, $39, $71, $65, $04
0B253 6C 70 77 01 84 72 8C 72..   .db $6c, $70, $77, $01, $84, $72, $8c, $72, $b3, $34, $ec, $01, $ef, $72, $0d, $04
0B263 AC 67 CC 01 CF 71 E7 22..   .db $ac, $67, $cc, $01, $cf, $71, $e7, $22, $17, $88, $23, $00, $27, $23, $3c, $62
0B273 65 71 67 33 8C 61 DC 01..   .db $65, $71, $67, $33, $8c, $61, $dc, $01, $08, $fa, $45, $75, $63, $0a, $73, $23
0B283 7C 02 8F 72 73 A9 9F 74..   .db $7c, $02, $8f, $72, $73, $a9, $9f, $74, $bf, $74, $ef, $73, $39, $f1, $fc, $0a
0B293 0D 0B 13 25 4C 01 4F 72..   .db $0d, $0b, $13, $25, $4c, $01, $4f, $72, $73, $0b, $77, $03, $dc, $08, $23, $a2
0B2A3 53 09 56 03 63 24 8C 02..   .db $53, $09, $56, $03, $63, $24, $8c, $02, $3f, $b3, $77, $63, $96, $74, $b3, $77
0B2B3 5D C1 8F 26 7D C7 FD        .db $5d, $c1, $8f, $26, $7d, $c7, $fd
0B2BA                           
0B2BA                           ;level C-2
0B2BA                           L_GroundArea35:
0B2BA 54 11 0F 26 CF 32 EE 43..   .db $54, $11, $0f, $26, $cf, $32, $ee, $43, $f8, $62, $fe, $10, $3c, $b2, $bd, $48
0B2CA EA 62 FC 4D FC 4D 17 C9..   .db $ea, $62, $fc, $4d, $fc, $4d, $17, $c9, $da, $62, $0b, $97, $b7, $12, $2c, $b1
0B2DA 33 43 6C 31 AC 41 0B 98..   .db $33, $43, $6c, $31, $ac, $41, $0b, $98, $7e, $40, $ad, $4a, $db, $30, $27, $b0
0B2EA B7 14 C6 42 C7 96 D6 44..   .db $b7, $14, $c6, $42, $c7, $96, $d6, $44, $2b, $92, $39, $0f, $72, $41, $a7, $00
0B2FA 1B 95 97 13 6C 95 6F 11..   .db $1b, $95, $97, $13, $6c, $95, $6f, $11, $a2, $40, $bf, $15, $c2, $40, $0b, $9a
0B30A 62 42 63 12 AD 4A 0E 91..   .db $62, $42, $63, $12, $ad, $4a, $0e, $91, $1d, $41, $4f, $26, $4d, $c7, $fd
0B319                           
0B319                           ;level C-3
0B319                           L_GroundArea36:
0B319 57 11 0F 26 FE 10 4B 92..   .db $57, $11, $0f, $26, $fe, $10, $4b, $92, $59, $0f, $ad, $4c, $d3, $93, $0b, $94
0B329 29 0F 7B 93 99 0F 0D 06..   .db $29, $0f, $7b, $93, $99, $0f, $0d, $06, $27, $12, $35, $0f, $23, $b1, $57, $75
0B339 A3 31 AB 71 F7 75 23 B1..   .db $a3, $31, $ab, $71, $f7, $75, $23, $b1, $87, $13, $95, $0f, $0d, $0a, $23, $35
0B349 38 13 55 00 9B 16 0B 96..   .db $38, $13, $55, $00, $9b, $16, $0b, $96, $c7, $75, $dd, $4a, $3b, $92, $49, $0f
0B359 AD 4C 29 92 52 40 6C 15..   .db $ad, $4c, $29, $92, $52, $40, $6c, $15, $6f, $11, $72, $40, $bf, $15, $03, $93
0B369 0A 13 12 41 8B 12 99 0F..   .db $0a, $13, $12, $41, $8b, $12, $99, $0f, $0d, $10, $47, $16, $46, $45, $b3, $32
0B379 13 B1 57 0E A7 0E D3 31..   .db $13, $b1, $57, $0e, $a7, $0e, $d3, $31, $53, $b1, $a6, $31, $03, $b2, $13, $0e
0B389 8D 4D AE 11 BD 41 EE 52..   .db $8d, $4d, $ae, $11, $bd, $41, $ee, $52, $0f, $a0, $dd, $47, $fd
0B396                           
0B396                           ;level D-1
0B396                           L_GroundArea37:
0B396 52 A1 0F 20 6E 65 04 A0..   .db $52, $a1, $0f, $20, $6e, $65, $04, $a0, $14, $07, $24, $2d, $57, $25, $bc, $09
0B3A6 4C 80 6F 33 A5 11 A7 63..   .db $4c, $80, $6f, $33, $a5, $11, $a7, $63, $b7, $63, $e7, $20, $35, $a0, $59, $11
0B3B6 B4 08 C0 04 05 82 15 02..   .db $b4, $08, $c0, $04, $05, $82, $15, $02, $25, $02, $3a, $10, $4c, $01, $6c, $79
0B3C6 95 79 73 A7 8F 74 F3 0A..   .db $95, $79, $73, $a7, $8f, $74, $f3, $0a, $03, $a0, $93, $08, $97, $73, $e3, $20
0B3D6 39 F1 94 07 AA 30 BC 5C..   .db $39, $f1, $94, $07, $aa, $30, $bc, $5c, $c7, $30, $24, $f2, $27, $31, $8f, $33
0B3E6 C6 10 C7 63 D7 63 E7 63..   .db $c6, $10, $c7, $63, $d7, $63, $e7, $63, $f7, $63, $03, $a5, $07, $25, $aa, $10
0B3F6 03 BF 4F 74 6C 00 DF 74..   .db $03, $bf, $4f, $74, $6c, $00, $df, $74, $fc, $00, $5c, $81, $77, $73, $9d, $4c
0B406 C5 30 E3 30 7D C1 BD 4D..   .db $c5, $30, $e3, $30, $7d, $c1, $bd, $4d, $bf, $26, $ad, $c7, $fd
0B413                           
0B413                           ;level D-2
0B413                           L_GroundArea38:
0B413 55 A1 0F 26 9C 01 4F B6..   .db $55, $a1, $0f, $26, $9c, $01, $4f, $b6, $b3, $34, $c9, $3f, $13, $ba, $a3, $b3
0B423 BF 74 0C 84 83 3F 9F 74..   .db $bf, $74, $0c, $84, $83, $3f, $9f, $74, $ef, $72, $ec, $01, $2f, $f2, $2c, $01
0B433 6F 72 6C 01 A8 91 AA 10..   .db $6f, $72, $6c, $01, $a8, $91, $aa, $10, $03, $b7, $61, $79, $6f, $75, $39, $f1
0B443 DB 71 03 A2 17 22 33 09..   .db $db, $71, $03, $a2, $17, $22, $33, $09, $43, $20, $5b, $71, $48, $8f, $4a, $30
0B453 5C 5C A3 30 2D C1 5F 26..   .db $5c, $5c, $a3, $30, $2d, $c1, $5f, $26, $3d, $c7, $fd
0B45E                           
0B45E                           ;level D-3
0B45E                           L_GroundArea39:
0B45E 55 A1 0F 26 39 91 68 12..   .db $55, $a1, $0f, $26, $39, $91, $68, $12, $a7, $12, $aa, $10, $c7, $07, $e8, $12
0B46E 19 91 6C 00 78 74 0E C2..   .db $19, $91, $6c, $00, $78, $74, $0e, $c2, $76, $a8, $fe, $40, $29, $91, $73, $29
0B47E 77 53 8C 77 59 91 87 13..   .db $77, $53, $8c, $77, $59, $91, $87, $13, $b6, $14, $ba, $10, $e8, $12, $38, $92
0B48E 19 8F 2C 00 33 67 4E 42..   .db $19, $8f, $2c, $00, $33, $67, $4e, $42, $68, $0b, $2e, $c0, $38, $72, $a8, $11
0B49E AA 10 49 91 6E 42 DE 40..   .db $aa, $10, $49, $91, $6e, $42, $de, $40, $e7, $22, $0e, $c2, $4e, $c0, $6c, $00
0B4AE 79 11 8C 01 A7 13 BC 01..   .db $79, $11, $8c, $01, $a7, $13, $bc, $01, $d5, $15, $ec, $01, $03, $97, $0e, $00
0B4BE 6E 01 9D 41 CE 42 FF 20..   .db $6e, $01, $9d, $41, $ce, $42, $ff, $20, $9d, $c7, $fd
0B4C9                           
0B4C9                           ;ground level area used with level D-4
0B4C9                           L_GroundArea40:
0B4C9 10 21 39 F1 09 F1 AD 4C..   .db $10, $21, $39, $f1, $09, $f1, $ad, $4c, $7c, $83, $96, $30, $5b, $f1, $c8, $05
0B4D9 1F B7 93 67 A3 67 B3 67..   .db $1f, $b7, $93, $67, $a3, $67, $b3, $67, $bd, $4d, $cc, $08, $54, $fe, $6e, $2f
0B4E9 6D C7 FD                    .db $6d, $c7, $fd
0B4EC                           
0B4EC                           ;cloud level used with levels A-1, B-1 and D-2
0B4EC                           L_GroundArea41:
0B4EC 00 C1 4C 00 02 C9 BA 49..   .db $00, $c1, $4c, $00, $02, $c9, $ba, $49, $62, $c9, $a4, $20, $a5, $20, $1a, $c9
0B4FC A3 2C B2 49 56 C2 6E 00..   .db $a3, $2c, $b2, $49, $56, $c2, $6e, $00, $95, $41, $ad, $c7, $fd
0B509                           
0B509                           ;level 1-2
0B509                           L_UndergroundArea1:
0B509 48 0F 0E 01 5E 02 0A B0..   .db $48, $0f, $0e, $01, $5e, $02, $0a, $b0, $1c, $54, $6a, $30, $7f, $34, $c6, $64
0B519 D6 64 E6 64 F6 64 FE 00..   .db $d6, $64, $e6, $64, $f6, $64, $fe, $00, $f0, $07, $00, $a1, $1e, $02, $47, $73
0B529 7E 04 84 52 94 50 95 0B..   .db $7e, $04, $84, $52, $94, $50, $95, $0b, $96, $50, $a4, $52, $ae, $05, $b8, $51
0B539 C8 51 CE 01 17 F3 45 03..   .db $c8, $51, $ce, $01, $17, $f3, $45, $03, $52, $09, $62, $21, $6f, $34, $81, $21
0B549 9E 02 B6 64 C6 64 C0 0C..   .db $9e, $02, $b6, $64, $c6, $64, $c0, $0c, $d6, $64, $d0, $07, $e6, $64, $e0, $0c
0B559 F0 07 FE 0A 0D 06 0E 01..   .db $f0, $07, $fe, $0a, $0d, $06, $0e, $01, $4e, $04, $67, $73, $8e, $02, $b7, $0a
0B569 BC 03 C4 72 C7 22 08 F2..   .db $bc, $03, $c4, $72, $c7, $22, $08, $f2, $2c, $02, $59, $71, $7c, $01, $96, $74
0B579 BC 01 D8 72 FC 01 39 F1..   .db $bc, $01, $d8, $72, $fc, $01, $39, $f1, $4e, $01, $9e, $04, $a7, $52, $b7, $0b
0B589 B8 51 C7 51 D7 50 DE 02..   .db $b8, $51, $c7, $51, $d7, $50, $de, $02, $3a, $e0, $3e, $0a, $9e, $00, $08, $d4
0B599 18 54 28 54 48 54 6E 06..   .db $18, $54, $28, $54, $48, $54, $6e, $06, $9e, $01, $a8, $52, $af, $47, $b8, $52
0B5A9 C8 52 D8 52 DE 0F 4D C7..   .db $c8, $52, $d8, $52, $de, $0f, $4d, $c7, $ce, $01, $dc, $01, $f9, $79, $1c, $82
0B5B9 48 72 7F 37 F2 68 01 E9..   .db $48, $72, $7f, $37, $f2, $68, $01, $e9, $11, $3a, $68, $7a, $de, $0f, $6d, $c5
0B5C9 FD                          .db $fd
0B5CA                           
0B5CA                           ;warp zone area used by level 1-2
0B5CA                           L_UndergroundArea2:
0B5CA 0B 0F 0E 01 9C 71 B7 00..   .db $0b, $0f, $0e, $01, $9c, $71, $b7, $00, $be, $00, $3e, $81, $47, $73, $5e, $00
0B5DA 63 42 8E 01 A7 73 BE 00..   .db $63, $42, $8e, $01, $a7, $73, $be, $00, $7e, $81, $88, $72, $f0, $59, $fe, $00
0B5EA 00 D9 0E 01 39 79 A7 03..   .db $00, $d9, $0e, $01, $39, $79, $a7, $03, $ae, $00, $b4, $03, $de, $0f, $0d, $05
0B5FA 0E 02 68 7A BE 01 DE 0F..   .db $0e, $02, $68, $7a, $be, $01, $de, $0f, $6d, $c5, $fd
0B605                           
0B605                           ;underground bonus rooms used with worlds 1-4
0B605                           L_UndergroundArea3:
0B605 08 8F 0E 01 17 05 2E 02..   .db $08, $8f, $0e, $01, $17, $05, $2e, $02, $30, $07, $37, $03, $3a, $49, $44, $03
0B615 58 47 DF 4A 6D C7 0E 81..   .db $58, $47, $df, $4a, $6d, $c7, $0e, $81, $00, $5a, $2e, $02, $87, $52, $97, $2f
0B625 99 4F 0A 90 93 56 A3 0B..   .db $99, $4f, $0a, $90, $93, $56, $a3, $0b, $a7, $50, $b3, $55, $df, $4a, $6d, $c7
0B635 0E 81 00 5A 2E 00 3E 02..   .db $0e, $81, $00, $5a, $2e, $00, $3e, $02, $41, $56, $57, $25, $56, $45, $68, $51
0B645 7A 43 B7 0B B8 51 DF 4A..   .db $7a, $43, $b7, $0b, $b8, $51, $df, $4a, $6d, $c7, $fd
0B650                           
0B650                           ;level 5-2
0B650                           L_UndergroundArea4:
0B650 48 0F 1E 01 27 06 5E 02..   .db $48, $0f, $1e, $01, $27, $06, $5e, $02, $8f, $63, $8c, $01, $ef, $67, $1c, $81
0B660 2E 09 3C 63 73 01 8C 60..   .db $2e, $09, $3c, $63, $73, $01, $8c, $60, $fe, $02, $1e, $8e, $3e, $02, $44, $07
0B670 45 52 4E 0E 8E 02 99 71..   .db $45, $52, $4e, $0e, $8e, $02, $99, $71, $b5, $24, $b6, $24, $b7, $24, $fe, $02
0B680 07 87 17 22 37 52 37 0B..   .db $07, $87, $17, $22, $37, $52, $37, $0b, $47, $52, $4e, $0a, $57, $52, $5e, $02
0B690 67 52 77 52 7E 0A 87 52..   .db $67, $52, $77, $52, $7e, $0a, $87, $52, $8e, $02, $96, $46, $97, $52, $a7, $52
0B6A0 B7 52 C7 52 D7 52 E7 52..   .db $b7, $52, $c7, $52, $d7, $52, $e7, $52, $f7, $52, $fe, $04, $07, $a3, $47, $08
0B6B0 57 26 C7 0A E9 71 17 A7..   .db $57, $26, $c7, $0a, $e9, $71, $17, $a7, $97, $08, $9e, $01, $a0, $24, $c6, $74
0B6C0 F0 0C FE 04 0C 80 6F 32..   .db $f0, $0c, $fe, $04, $0c, $80, $6f, $32, $98, $62, $a8, $62, $bc, $00, $c7, $73
0B6D0 E7 73 FE 02 7F E7 8E 01..   .db $e7, $73, $fe, $02, $7f, $e7, $8e, $01, $9e, $00, $de, $02, $f7, $0b, $fe, $0e
0B6E0 4E 82 54 52 64 51 6E 00..   .db $4e, $82, $54, $52, $64, $51, $6e, $00, $74, $09, $9f, $00, $df, $00, $2f, $80
0B6F0 4E 02 59 47 CE 0A 07 F5..   .db $4e, $02, $59, $47, $ce, $0a, $07, $f5, $68, $54, $7f, $64, $88, $54, $a8, $54
0B700 AE 01 B8 52 BF 47 C8 52..   .db $ae, $01, $b8, $52, $bf, $47, $c8, $52, $d8, $52, $e8, $52, $ee, $0f, $4d, $c7
0B710 0D 0D 0E 02 68 7A BE 01..   .db $0d, $0d, $0e, $02, $68, $7a, $be, $01, $ee, $0f, $6d, $c5, $fd
0B71D                           
0B71D                           ;underground bonus rooms used with worlds 5-8
0B71D                           L_UndergroundArea5:
0B71D 08 0F 0E 01 2E 05 38 2C..   .db $08, $0f, $0e, $01, $2e, $05, $38, $2c, $3a, $4f, $08, $ac, $c7, $0b, $ce, $01
0B72D DF 4A 6D C7 0E 81 00 5A..   .db $df, $4a, $6d, $c7, $0e, $81, $00, $5a, $2e, $02, $b8, $4f, $cf, $65, $0f, $e5
0B73D 4F 65 8F 65 DF 4A 6D C7..   .db $4f, $65, $8f, $65, $df, $4a, $6d, $c7, $0e, $81, $00, $5a, $30, $07, $34, $52
0B74D 3E 02 42 47 44 47 46 27..   .db $3e, $02, $42, $47, $44, $47, $46, $27, $c0, $0b, $c4, $52, $df, $4a, $6d, $c7
0B75D FD                          .db $fd
0B75E                           
0B75E                           ;level A-2
0B75E                           L_UndergroundArea6:
0B75E 48 8F 1E 01 4E 02 00 8C..   .db $48, $8f, $1e, $01, $4e, $02, $00, $8c, $09, $0f, $6e, $0a, $ee, $82, $2e, $80
0B76E 30 20 7E 01 87 27 07 87..   .db $30, $20, $7e, $01, $87, $27, $07, $87, $17, $23, $3e, $00, $9e, $05, $5b, $f1
0B77E 8B 71 BB 71 EB 71 3E 82..   .db $8b, $71, $bb, $71, $eb, $71, $3e, $82, $7f, $38, $fe, $0a, $3e, $84, $47, $29
0B78E 48 2E AF 71 CB 71 E7 0A..   .db $48, $2e, $af, $71, $cb, $71, $e7, $0a, $f7, $23, $2b, $f1, $37, $51, $3e, $00
0B79E 6F 00 8E 04 DF 32 9C 82..   .db $6f, $00, $8e, $04, $df, $32, $9c, $82, $ca, $12, $dc, $00, $e8, $14, $fc, $00
0B7AE FE 08 4E 8A 88 74 9E 01..   .db $fe, $08, $4e, $8a, $88, $74, $9e, $01, $a8, $52, $bf, $47, $b8, $52, $c8, $52
0B7BE D8 52 E8 52 EE 0F 4D C7..   .db $d8, $52, $e8, $52, $ee, $0f, $4d, $c7, $0d, $0d, $0e, $02, $68, $7a, $be, $01
0B7CE EE 0F 6D C5 FD              .db $ee, $0f, $6d, $c5, $fd
0B7D3                           
0B7D3                           ;underground bonus rooms used with worlds A-D
0B7D3                           L_UndergroundArea7:
0B7D3 08 0F 0E 01 2E 05 38 20..   .db $08, $0f, $0e, $01, $2e, $05, $38, $20, $3e, $04, $48, $07, $55, $45, $57, $45
0B7E3 58 25 B8 08 BE 05 C8 20..   .db $58, $25, $b8, $08, $be, $05, $c8, $20, $ce, $01, $df, $4a, $6d, $c7, $0e, $81
0B7F3 00 5A 2E 02 34 42 36 42..   .db $00, $5a, $2e, $02, $34, $42, $36, $42, $37, $22, $73, $54, $83, $0b, $87, $20
0B803 93 54 90 07 B4 41 B6 41..   .db $93, $54, $90, $07, $b4, $41, $b6, $41, $b7, $21, $df, $4a, $6d, $c7, $0e, $81
0B813 00 5A 14 56 24 56 2E 0C..   .db $00, $5a, $14, $56, $24, $56, $2e, $0c, $33, $43, $6e, $09, $8e, $0b, $96, $48
0B823 1E 84 3E 05 4A 48 47 0B..   .db $1e, $84, $3e, $05, $4a, $48, $47, $0b, $ce, $01, $df, $4a, $6d, $c7, $fd
0B832                           
0B832                           ;level 3-2
0B832                           L_WaterArea1:
0B832 41 01 03 B4 04 34 05 34..   .db $41, $01, $03, $b4, $04, $34, $05, $34, $5c, $02, $83, $37, $84, $37, $85, $37
0B842 09 C2 0C 02 1D 49 FA 60..   .db $09, $c2, $0c, $02, $1d, $49, $fa, $60, $09, $e1, $18, $62, $20, $63, $27, $63
0B852 33 37 37 63 47 63 5C 05..   .db $33, $37, $37, $63, $47, $63, $5c, $05, $79, $43, $fe, $06, $35, $d2, $46, $48
0B862 91 53 D6 51 FE 01 0C 83..   .db $91, $53, $d6, $51, $fe, $01, $0c, $83, $6c, $04, $b4, $62, $c4, $62, $d4, $62
0B872 E4 62 F4 62 18 D2 79 51..   .db $e4, $62, $f4, $62, $18, $d2, $79, $51, $f4, $66, $fe, $02, $0c, $8a, $1d, $49
0B882 31 55 56 41 77 41 98 41..   .db $31, $55, $56, $41, $77, $41, $98, $41, $c5, $55, $fe, $01, $07, $e3, $17, $63
0B892 27 63 37 63 47 63 57 63..   .db $27, $63, $37, $63, $47, $63, $57, $63, $67, $63, $78, $62, $89, $61, $9a, $60
0B8A2 BC 07 CA 42 3A B3 46 53..   .db $bc, $07, $ca, $42, $3a, $b3, $46, $53, $63, $34, $66, $44, $7c, $01, $9a, $33
0B8B2 B7 52 DC 01 FA 32 05 D4..   .db $b7, $52, $dc, $01, $fa, $32, $05, $d4, $2c, $0d, $43, $37, $47, $35, $b7, $30
0B8C2 C3 64 23 E4 29 45 33 64..   .db $c3, $64, $23, $e4, $29, $45, $33, $64, $43, $64, $53, $64, $63, $64, $73, $64
0B8D2 9A 60 A9 61 B8 62 BE 0B..   .db $9a, $60, $a9, $61, $b8, $62, $be, $0b, $d4, $31, $d5, $0d, $de, $0f, $0d, $ca
0B8E2 7D 47 FD                    .db $7d, $47, $fd
0B8E5                           
0B8E5                           ;level 6-2
0B8E5                           L_WaterArea2:
0B8E5 41 01 27 D3 79 51 C4 56..   .db $41, $01, $27, $d3, $79, $51, $c4, $56, $00, $e2, $03, $53, $0c, $0f, $12, $3b
0B8F5 1A 42 43 54 6D 49 83 53..   .db $1a, $42, $43, $54, $6d, $49, $83, $53, $99, $53, $c3, $54, $da, $52, $0c, $84
0B905 09 53 53 64 63 31 67 34..   .db $09, $53, $53, $64, $63, $31, $67, $34, $86, $41, $8c, $01, $a3, $30, $b3, $64
0B915 CC 03 D9 42 5C 84 A0 62..   .db $cc, $03, $d9, $42, $5c, $84, $a0, $62, $a8, $62, $b0, $62, $b8, $62, $c0, $62
0B925 C8 62 D0 62 D8 62 E0 62..   .db $c8, $62, $d0, $62, $d8, $62, $e0, $62, $e8, $62, $16, $c2, $58, $52, $8c, $04
0B935 A7 55 D0 63 D7 65 E2 61..   .db $a7, $55, $d0, $63, $d7, $65, $e2, $61, $e7, $65, $f2, $61, $f7, $65, $13, $b8
0B945 17 38 8C 03 1D C9 50 62..   .db $17, $38, $8c, $03, $1d, $c9, $50, $62, $5c, $0b, $62, $3e, $63, $52, $8a, $52
0B955 93 54 AA 42 D3 51 EA 41..   .db $93, $54, $aa, $42, $d3, $51, $ea, $41, $03, $d3, $1c, $04, $1a, $52, $33, $55
0B965 73 44 77 44 16 D2 19 31..   .db $73, $44, $77, $44, $16, $d2, $19, $31, $1a, $32, $5c, $0f, $9a, $47, $95, $64
0B975 A5 64 B5 64 C5 64 D5 64..   .db $a5, $64, $b5, $64, $c5, $64, $d5, $64, $e5, $64, $f5, $64, $05, $e4, $40, $61
0B985 42 35 56 34 5C 09 A2 61..   .db $42, $35, $56, $34, $5c, $09, $a2, $61, $a6, $61, $b3, $34, $b7, $34, $fc, $08
0B995 0C 87 28 54 59 53 9A 30..   .db $0c, $87, $28, $54, $59, $53, $9a, $30, $a9, $61, $b8, $62, $be, $0b, $d4, $60
0B9A5 D5 0D DE 0F 0D CA 7D 47..   .db $d5, $0d, $de, $0f, $0d, $ca, $7d, $47, $fd
0B9AE                           
0B9AE                           ;water area used by level 4-1
0B9AE                           L_WaterArea3:
0B9AE 01 01 78 52 B5 55 DA 60..   .db $01, $01, $78, $52, $b5, $55, $da, $60, $e9, $61, $f8, $62, $fe, $0b, $fe, $81
0B9BE 0A CF 36 49 62 43 FE 07..   .db $0a, $cf, $36, $49, $62, $43, $fe, $07, $36, $c9, $fe, $01, $0c, $84, $65, $55
0B9CE 97 52 9A 32 A9 31 B8 30..   .db $97, $52, $9a, $32, $a9, $31, $b8, $30, $c7, $63, $ce, $0f, $d5, $0d, $7d, $c7
0B9DE FD                          .db $fd
0B9DF                           
0B9DF                           ;water area used in level 8-4
0B9DF                           L_WaterArea4:
0B9DF 07 0F 0E 02 39 73 05 8E..   .db $07, $0f, $0e, $02, $39, $73, $05, $8e, $2e, $0b, $b7, $0e, $64, $8e, $6e, $02
0B9EF CE 06 DE 0F E6 0D 7D C7..   .db $ce, $06, $de, $0f, $e6, $0d, $7d, $c7, $fd
0B9F8                           
0B9F8                           ;water area used in level 6-1
0B9F8                           L_WaterArea5:
0B9F8 01 01 77 39 A3 43 00 BF..   .db $01, $01, $77, $39, $a3, $43, $00, $bf, $29, $51, $39, $48, $61, $55, $d6, $54
0BA08 D2 44 0C 82 2E 02 31 66..   .db $d2, $44, $0c, $82, $2e, $02, $31, $66, $44, $47, $47, $32, $4a, $47, $97, $32
0BA18 C1 66 CE 01 DC 02 FE 0E..   .db $c1, $66, $ce, $01, $dc, $02, $fe, $0e, $0c, $8f, $08, $4f, $fe, $01, $27, $d3
0BA28 5C 02 9A 60 A9 61 B8 62..   .db $5c, $02, $9a, $60, $a9, $61, $b8, $62, $c7, $63, $ce, $0f, $d5, $0d, $7d, $c7
0BA38 FD                          .db $fd
0BA39                           
0BA39                           ;level 9-1 water area
0BA39                           L_WaterArea6:
0BA39 00 A1 0A 60 19 61 28 62..     .db $00, $a1, $0a, $60, $19, $61, $28, $62, $39, $71, $58, $62, $69, $61, $7a, $60
0BA49 7C F5 A5 11 FE 20 1F 80..     .db $7c, $f5, $a5, $11, $fe, $20, $1f, $80, $5e, $21, $80, $3f, $8f, $65, $d6, $74
0BA59 5E A0 6F 66 9E 21 C3 37..     .db $5e, $a0, $6f, $66, $9e, $21, $c3, $37, $47, $f3, $9e, $20, $fe, $21, $0d, $06
0BA69 57 32 64 11 66 10 83 A7..     .db $57, $32, $64, $11, $66, $10, $83, $a7, $87, $27, $0d, $09, $1d, $4a, $5f, $38
0BA79 6D C1 AF 26 6D C7 FD          .db $6d, $c1, $af, $26, $6d, $c7, $fd
0BA80                           
0BA80                           ;level 9-2
0BA80                           L_WaterArea7:
0BA80 50 11 D7 73 FE 1A 6F E2..     .db $50, $11, $d7, $73, $fe, $1a, $6f, $e2, $1f, $e5, $bf, $63, $c7, $a8, $df, $61
0BA90 15 F1 7F 62 9B 2F A8 72..     .db $15, $f1, $7f, $62, $9b, $2f, $a8, $72, $fe, $10, $69, $f1, $b7, $25, $c5, $71
0BAA0 33 AC 5F 71 8D 4A AA 14..     .db $33, $ac, $5f, $71, $8d, $4a, $aa, $14, $d1, $71, $17, $95, $26, $42, $72, $42
0BAB0 73 12 7A 14 C6 14 D5 42..     .db $73, $12, $7a, $14, $c6, $14, $d5, $42, $fe, $11, $7f, $b8, $8d, $c1, $cf, $26
0BAC0 6D C7 FD                      .db $6d, $c7, $fd
0BAC3                           
0BAC3                           ;level 9-4
0BAC3                           L_WaterArea8:
0BAC3 57 00 0B 3F 0B BF 0B BF..     .db $57, $00, $0b, $3f, $0b, $bf, $0b, $bf, $73, $36, $9a, $30, $a5, $64, $b6, $31
0BAD3 D4 61 0B BF 13 63 4A 60..     .db $d4, $61, $0b, $bf, $13, $63, $4a, $60, $53, $66, $a5, $34, $b3, $67, $e5, $65
0BAE3 F4 60 0B BF 14 60 53 67..     .db $f4, $60, $0b, $bf, $14, $60, $53, $67, $67, $32, $c4, $62, $d4, $31, $f3, $61
0BAF3 FA 60 0B BF 04 30 09 61..     .db $fa, $60, $0b, $bf, $04, $30, $09, $61, $14, $65, $63, $65, $6a, $60, $0b, $bf
0BB03 0F 38 0B BF 1D 41 3E 42..     .db $0f, $38, $0b, $bf, $1d, $41, $3e, $42, $5f, $20, $ce, $40, $0b, $bf, $3d, $47
0BB13 FD                            .db $fd
0BB14                           
0BB14                           ;level B-2
0BB14                           L_WaterArea9:
0BB14 41 01 DA 60 E9 61 F8 62..   .db $41, $01, $da, $60, $e9, $61, $f8, $62, $fe, $0b, $fe, $81, $47, $d3, $8a, $60
0BB24 99 61 A8 62 B7 63 C6 64..   .db $99, $61, $a8, $62, $b7, $63, $c6, $64, $d5, $65, $e4, $66, $ed, $49, $f3, $67
0BB34 1A CB E3 67 F3 67 FE 02..   .db $1a, $cb, $e3, $67, $f3, $67, $fe, $02, $31, $d6, $3c, $02, $77, $53, $ac, $02
0BB44 B1 56 E7 53 FE 01 77 B9..   .db $b1, $56, $e7, $53, $fe, $01, $77, $b9, $a3, $43, $00, $bf, $29, $51, $39, $48
0BB54 61 55 D2 44 D6 54 0C 82..   .db $61, $55, $d2, $44, $d6, $54, $0c, $82, $2e, $02, $31, $66, $44, $47, $47, $32
0BB64 4A 47 97 32 C1 66 CE 01..   .db $4a, $47, $97, $32, $c1, $66, $ce, $01, $dc, $02, $fe, $0e, $0c, $8f, $08, $4f
0BB74 FE 02 75 E0 FE 01 0C 87..   .db $fe, $02, $75, $e0, $fe, $01, $0c, $87, $9a, $60, $a9, $61, $b8, $62, $c7, $63
0BB84 CE 0F D5 0D 6D CA 7D 47..   .db $ce, $0f, $d5, $0d, $6d, $ca, $7d, $47, $fd
0BB8D                           
0BB8D                           ;-------------------------------------------------------------------------------------
0BB8D FF FF FF FF FF FF FF FF.. .pad $c000,$ff
0C000                           
0C000                           .base $8000
08000                           ;-------------------------------------------------------------------------------------
08000                           
08000                           Start:
08000 AD 5F 07                              lda WorldNumber             ;get world number and save it temporarily
08003 48                                    pha
08004 A0 FE                                 ldy #ColdBootOffset         ;load default cold boot pointer
08006 A2 05                                 ldx #$05
08008 BD D7 07                  WBootCheck: lda TopScoreDisplay,x       ;first checkpoint, check each score digit
0800B C9 0A                                 cmp #10                     ;in the top score for a valid digit
0800D B0 0C                                 bcs ColdBoot                ;if even one digit isn't valid (greater than 10 decimal)
0800F CA                                    dex                         ;then branch to perform cold boot
08010 10 F6                                 bpl WBootCheck
08012 AD FF 07                              lda WarmBootValidation      ;second checkpoint, check to see if 
08015 C9 A5                                 cmp #$a5                    ;another location has a specific value
08017 D0 02                                 bne ColdBoot   
08019 A0 D6                                 ldy #WarmBootOffset         ;if passed both, load warm boot pointer
0801B 20 92 8F                  ColdBoot:   jsr InitializeMemory        ;clear memory using pointer in Y  
0801E 8D 11 40                              sta SND_DELTA_REG+1
08021 8D 70 07                              sta OperMode                ;now manually reset some other stuff
08024 8D FC 07                              sta DiskIOTask
08027 68                                    pla
08028 8D 5F 07                              sta WorldNumber
0802B A9 A5                                 lda #$a5                    ;set warm boot flag in case the player hits reset
0802D 8D FF 07                              sta WarmBootValidation     
08030 8D A7 07                              sta PseudoRandomBitReg      ;set seed for pseudorandom register
08033 A9 0F                                 lda #%00001111
08035 8D 15 40                              sta SND_MASTERCTRL_REG      ;enable all sound channels except dmc
08038 A9 06                                 lda #%00000110
0803A 8D 01 20                              sta PPU_MASK                ;turn off clipping for OAM and background
0803D 20 30 82                              jsr MoveAllSpritesOffscreen
08040 20 0D 8D                              jsr InitializeNameTables
08043 EE 74 07                              inc DisableScreenFlag
08046 58                                    cli
08047 AD 78 07                              lda Mirror_PPU_CTRL
0804A 09 80                                 ora #%10000000
0804C 20 E1 8D                              jsr WritePPUReg1
0804F                           EndlessLoop:
0804F A5 00                                 lda $00                     ;endless loop
08051 4C 4F 80                              jmp EndlessLoop
08054                           
08054                           ;-------------------------------------------------------------------------------------
08054                           
08054                           VRAM_AddrTable:
08054 01 03 F4 8B 18 8C 3C 8C      .dw VRAM_Buffer1, WaterPaletteData, GroundPaletteData, UndergroundPaletteData
0805C 60 8C 9B E4 41 03 41 03      .dw CastlePaletteData, TitleScreenGfxData, VRAM_Buffer2, VRAM_Buffer2
08064 9C 8C 84 8C 8C 8C 94 8C      .dw BowserPaletteData, DaySnowPaletteData, NightSnowPaletteData, MushroomPaletteData
0806C A4 8C B8 8C CC 8C D4 E9      .dw MarioThankYouMsg, LuigiThankYouMsg, MushroomRetainerMsg, FinalRoomPalette
08074 E8 E9 18 EA 2E EA 44 EA      .dw MarioThankYouMsgFinal, PeaceIsPavedMsg, WithKingdomSavedMsg, MarioHurrahMsg
0807C 6A EA 7B EA 92 EA AA EA      .dw OurOnlyHeroMsg, ThisEndsYourTripMsg, OfALongFriendshipMsg, PointsAddedMsg
08084 C2 EA 00 EA 57 EA 7F E2      .dw ForEachPlayerLeftMsg, LuigiThankYouMsgFinal, LuigiHurrahMsg, DiskScreenPalette
0808C DB EA FC EA 3F EB            .dw PrincessPeachsRoom, FantasyWorld9Msg, ThanksForPlayingMsg
08092                           
08092                           VRAM_Buffer_Offset:
08092 00 40                        .db <VRAM_Buffer1_Offset, <VRAM_Buffer2_Offset
08094                           
08094                           ;-------------------------------------------------------------------------------------
08094                           
08094                           NMIHandler:
08094 AD 78 07                     lda Mirror_PPU_CTRL       ;alter name table address to be $2800
08097 29 7E                        and #%01111110            ;(essentially $2000) and disable another NMI
08099 8D 78 07                     sta Mirror_PPU_CTRL       ;from interrupting this one
0809C 8D 00 20                     sta PPU_CTRL
0809F 78                           sei
080A0 AD 79 07                     lda Mirror_PPU_MASK
080A3 29 E6                        and #%11100110            ;disable OAM and background display by default
080A5 AC 74 07                     ldy DisableScreenFlag     ;if screen disabled, skip this
080A8 D0 05                        bne ScrnSwch
080AA AD 79 07                     lda Mirror_PPU_MASK       ;otherwise reenable bits and save them
080AD 09 1E                        ora #%00011110
080AF                           ScrnSwch:
080AF 8D 79 07                     sta Mirror_PPU_MASK
080B2 29 E7                        and #%11100111            ;turn screen off regardless of mirror reg
080B4 8D 01 20                     sta PPU_MASK
080B7 AE 02 20                     ldx PPU_STATUS
080BA A9 00                        lda #$00
080BC 20 DA 8D                     jsr InitScroll
080BF 8D 03 20                     sta PPU_SPR_ADDR
080C2 A9 02                        lda #$02                  ;dump OAM data to PPU's sprite RAM
080C4 8D 14 40                     sta SPR_DMA
080C7 AD 73 07                     lda VRAM_Buffer_AddrCtrl
080CA 0A                           asl
080CB AA                           tax
080CC BD 54 80                     lda VRAM_AddrTable,x      ;get pointer to VRAM data
080CF 85 00                        sta $00
080D1 E8                           inx
080D2 BD 54 80                     lda VRAM_AddrTable,x
080D5 85 01                        sta $01
080D7 20 D1 8D                     jsr UpdateScreen          ;now update the screen with it
080DA A0 00                        ldy #$00
080DC AE 73 07                     ldx VRAM_Buffer_AddrCtrl
080DF E0 06                        cpx #$06                  ;if pointer number was set to 6 (for
080E1 D0 01                        bne InitVRAMVars          ;second VRAM buffer), increment Y to get
080E3 C8                           iny                       ;offset for second VRAM buffer
080E4                           InitVRAMVars:
080E4 BE 92 80                     ldx VRAM_Buffer_Offset,y  ;get pointer to correct buffer offset
080E7 A9 00                        lda #$00                  ;erase the VRAM buffer offset, init first VRAM buffer
080E9 9D 00 03                     sta VRAM_Buffer1_Offset,x ;by writing end terminator at the first byte, and
080EC 9D 01 03                     sta VRAM_Buffer1,x        ;init address control to point at first VRAM buffer
080EF 8D 73 07                     sta VRAM_Buffer_AddrCtrl
080F2 AD 79 07                     lda Mirror_PPU_MASK
080F5 8D 01 20                     sta PPU_MASK              ;dump PPU control register 2
080F8 58                           cli
080F9 AD 22 07                     lda IRQUpdateFlag
080FC F0 0E                        beq SkipIRQ
080FE A9 1F                        lda #31                   ;count 31 scanlines (plus the pre-render scanline)
08100 8D 00 C0                     sta MMC3_IRQLatch
08103 8D 01 C0                     sta MMC3_IRQReload
08106 8D 01 E0                     sta MMC3_IRQEnable
08109 EE 7B 07                     inc IRQAckFlag            ;reset flag to wait for next IRQ
0810C                           SkipIRQ:
0810C 20 9F FE                     jsr RunSoundEngine        ;run subs that need to be run on every frame
0810F 20 50 8D                     jsr ReadJoypads
08112 20 92 81                     jsr PauseRoutine
08115 20 83 8E                     jsr UpdateTopScore
08118 AD 76 07                     lda GamePauseStatus       ;check d0 of game pause flags
0811B 4A                           lsr                       ;if set, branch to skip 
0811C B0 25                        bcs SeedLFSR
0811E AD 47 07                     lda TimerControl          ;if master timer control not set, branch
08121 F0 05                        beq CheckIntervalTC       ;to decrement frame and interval timers
08123 CE 47 07                     dec TimerControl          ;otherwise count this timer down
08126 D0 19                        bne IncFrameCntr                 
08128                           CheckIntervalTC:
08128 A2 14                        ldx #$14                  ;set offset to decrement only frame timers
0812A CE 7F 07                     dec IntervalTimerControl  ;if interval timer control not expired, branch
0812D 10 07                        bpl DecrTheTimers         ;to skip and thus decrement only frame timers
0812F A9 14                        lda #$14
08131 8D 7F 07                     sta IntervalTimerControl  ;otherwise reset interval timer control to 20 frames
08134 A2 23                        ldx #$23                  ;and load offset to decrement frame and interval timers
08136                           DecrTheTimers:
08136 BD 80 07                     lda Timers,x              ;if current timer is already expired, skip it
08139 F0 03                        beq DTTLoop               ;otherwise decrement it
0813B DE 80 07                     dec Timers,x
0813E                           DTTLoop:
0813E CA                           dex                       ;loop until all timers that need to be counted down are
0813F 10 F5                        bpl DecrTheTimers
08141                           IncFrameCntr:
08141 E6 09                        inc FrameCounter
08143                           SeedLFSR:
08143 A2 00                        ldx #$00
08145 A0 07                        ldy #$07
08147 AD A7 07                     lda PseudoRandomBitReg    ;get d1 of first byte
0814A 29 02                        and #$02
0814C 85 00                        sta $00
0814E AD A8 07                     lda PseudoRandomBitReg+1  ;get d1 of second byte, XOR it with the first byte
08151 29 02                        and #$02
08153 45 00                        eor $00
08155 18                           clc
08156 F0 01                        beq RotateLFSR            ;prepare to rotate the result in
08158 38                           sec
08159                           RotateLFSR:
08159 7E A7 07                     ror PseudoRandomBitReg,x  ;basically, rotate the operation result into d7
0815C E8                           inx                       ;then rotate the entire LFSR
0815D 88                           dey
0815E D0 F9                        bne RotateLFSR
08160 AD 76 07                     lda GamePauseStatus       ;if d0 of game pause flag is set, skip this part
08163 4A                           lsr
08164 B0 18                        bcs WaitForIRQ
08166 AD 22 07                     lda IRQUpdateFlag
08169 F0 06                        beq CheckInvalidWorldNum
0816B 20 33 82                     jsr MoveSpritesOffscreen
0816E 20 D6 81                     jsr SpriteShuffler
08171                           CheckInvalidWorldNum:
08171 AD 5F 07                     lda WorldNumber           ;if world number somehow goes past D, just end the game
08174 C9 0D                        cmp #WorldD+1                  
08176 90 03                        bcc ExecutionTree
08178 20 37 91                     jsr TerminateGame
0817B                           ExecutionTree:
0817B 20 22 82                     jsr OperModeExecutionTree ;run one of the program's four modes
0817E                           WaitForIRQ:
0817E AD 7B 07                     lda IRQAckFlag            ;wait for IRQ
08181 D0 FB                        bne WaitForIRQ
08183 AD 02 20                     lda PPU_STATUS
08186 AD 78 07                     lda Mirror_PPU_CTRL       ;reenable NMIs 
08189 09 80                        ora #$80
0818B 8D 78 07                     sta Mirror_PPU_CTRL       ;then park it at endless loop until next NMI
0818E 8D 00 20                     sta PPU_CTRL
08191 40                           rti
08192                           
08192                           ;-------------------------------------------------------------------------------------
08192                           
08192                           PauseRoutine:
08192 AD 70 07                                 lda OperMode           ;are we in victory mode?
08195 C9 02                                    cmp #VictoryMode       ;if so, go ahead
08197 F0 0B                                    beq ChkPauseTimer
08199 C9 01                                    cmp #GameMode          ;are we in game mode?
0819B D0 38                                    bne ExitPause          ;if not, leave
0819D AD 72 07                                 lda OperMode_Task      ;if we are in game mode, are we running game engine?
081A0 C9 04                                    cmp #$04
081A2 D0 31                                    bne ExitPause          ;if not, leave
081A4 AD 77 07                  ChkPauseTimer: lda GamePauseTimer     ;check if pause timer is still counting down
081A7 F0 04                                    beq ChkStart
081A9 CE 77 07                                 dec GamePauseTimer     ;if so, decrement and leave
081AC 60                                       rts
081AD AD FC 06                  ChkStart:      lda SavedJoypad1Bits   ;check to see if start is pressed
081B0 29 10                                    and #Start_Button
081B2 F0 19                                    beq ClrPauseTimer
081B4 AD 76 07                                 lda GamePauseStatus    ;check to see if timer flag is set
081B7 29 80                                    and #%10000000         ;and if so, do not reset timer (residual,
081B9 D0 1A                                    bne ExitPause          ;joypad reading routine makes this unnecessary)
081BB A9 2B                                    lda #$2b               ;set pause timer
081BD 8D 77 07                                 sta GamePauseTimer
081C0 AD 76 07                                 lda GamePauseStatus
081C3 A8                                       tay
081C4 C8                                       iny                    ;set pause sfx queue for next pause mode
081C5 84 FA                                    sty PauseSoundQueue
081C7 49 01                                    eor #%00000001         ;invert d0 and set d7
081C9 09 80                                    ora #%10000000
081CB D0 05                                    bne SetPause           ;unconditional branch
081CD AD 76 07                  ClrPauseTimer: lda GamePauseStatus    ;clear timer flag if timer is at zero and start button
081D0 29 7F                                    and #%01111111         ;is not pressed
081D2 8D 76 07                  SetPause:      sta GamePauseStatus
081D5 60                        ExitPause:     rts
081D6                           
081D6                           
081D6                           ;-------------------------------------------------------------------------------------
081D6                           ;$00 - used for preset value
081D6                           
081D6                           SpriteShuffler:
081D6 AC 4E 07                                 ldy AreaType                ;residual code, this value is never used
081D9 A9 28                                    lda #$28                    ;load preset value which will put it at
081DB 85 00                                    sta $00                     ;sprite #10
081DD A2 0E                                    ldx #$0e                    ;start at the end of OAM data offsets
081DF BD E4 06                  ShuffleLoop:   lda SprDataOffset,x         ;check for offset value against
081E2 C5 00                                    cmp $00                     ;the preset value
081E4 90 0F                                    bcc NextSprOffset           ;if less, skip this part
081E6 AC E0 06                                 ldy SprShuffleAmtOffset     ;get current offset to preset value we want to add
081E9 18                                       clc
081EA 79 E1 06                                 adc SprShuffleAmt,y         ;get shuffle amount, add to current sprite offset
081ED 90 03                                    bcc StrSprOffset            ;if not exceeded $ff, skip second add
081EF 18                                       clc
081F0 65 00                                    adc $00                     ;otherwise add preset value $28 to offset
081F2 9D E4 06                  StrSprOffset:  sta SprDataOffset,x         ;store new offset here or old one if branched to here
081F5 CA                        NextSprOffset: dex                         ;move backwards to next one
081F6 10 E7                                    bpl ShuffleLoop
081F8 AE E0 06                                 ldx SprShuffleAmtOffset     ;load offset
081FB E8                                       inx
081FC E0 03                                    cpx #$03                    ;check if offset + 1 goes to 3
081FE D0 02                                    bne SetAmtOffset            ;if offset + 1 not 3, store
08200 A2 00                                    ldx #$00                    ;otherwise, init to 0
08202 8E E0 06                  SetAmtOffset:  stx SprShuffleAmtOffset
08205 A2 08                                    ldx #$08                    ;load offsets for values and storage
08207 A0 02                                    ldy #$02
08209 B9 E9 06                  SetMiscOffset: lda SprDataOffset+5,y       ;load one of three OAM data offsets
0820C 9D F1 06                                 sta Misc_SprDataOffset-2,x  ;store first one unmodified, but
0820F 18                                       clc                         ;add eight to the second and eight
08210 69 08                                    adc #$08                    ;more to the third one
08212 9D F2 06                                 sta Misc_SprDataOffset-1,x  ;note that due to the way X is set up,
08215 18                                       clc                         ;this code loads into the misc sprite offsets
08216 69 08                                    adc #$08
08218 9D F3 06                                 sta Misc_SprDataOffset,x        
0821B CA                                       dex
0821C CA                                       dex
0821D CA                                       dex
0821E 88                                       dey
0821F 10 E8                                    bpl SetMiscOffset           ;do this until all misc spr offsets are loaded
08221 60                                       rts
08222                           
08222                           ;-------------------------------------------------------------------------------------
08222                           
08222                           OperModeExecutionTree:
08222 AD 70 07                        lda OperMode     ;this is the heart of the entire program,
08225 20 F8 8C                        jsr JumpEngine   ;most of what goes on starts here
08228                           
08228 D7 E1                           .dw AttractModeSubs
0822A 4A 9B                           .dw GameModeSubs
0822C 41 82                           .dw VictoryModeMain
0822E 03 91                           .dw GameOverSubs
08230                           
08230                           ;-------------------------------------------------------------------------------------
08230                           
08230                           MoveAllSpritesOffscreen:
08230 A0 00                                   ldy #$00                ;this routine moves all sprites off the screen
08232 2C                                      .db $2c                 ;BIT instruction opcode
08233                           
08233                           MoveSpritesOffscreen:
08233 A0 04                                   ldy #$04                ;this routine moves all but sprite 0
08235 A9 F8                                   lda #$f8                ;off the screen
08237 99 00 02                  SprInitLoop:  sta Sprite_Y_Position,y ;write 248 into OAM data's Y coordinate
0823A C8                                      iny                     ;which will move it off the screen
0823B C8                                      iny
0823C C8                                      iny
0823D C8                                      iny
0823E D0 F7                                   bne SprInitLoop
08240 60                        VMExit:       rts
08241                           
08241                           ;-------------------------------------------------------------------------------------
08241                           
08241                           VictoryModeMain:
08241 20 69 82                            jsr VictoryModeSubroutines ;run victory mode subroutines in order
08244 AD 72 07                            lda OperMode_Task          ;if running bridge collapse subroutine
08247 F0 1A                               beq BrdgSkip               ;then skip most of this
08249 AE 5F 07                            ldx WorldNumber
0824C E0 07                               cpx #World8                ;if not on world 8, skip, don't bother checking
0824E D0 0C                               bne NotW8orD               ;to see which subroutine we're on
08250 E0 0C                               cpx #WorldD                ;if not on world D, skip, don't bother checking
08252 D0 08                               bne NotW8orD               ;to see which subroutine we're on
08254 C9 05                               cmp #$05
08256 F0 E8                               beq VMExit                 ;if running disk subroutines, branch to leave
08258 C9 0D                               cmp #$0d                   ;because the screen will be blank during this
0825A F0 E4                               beq VMExit
0825C A2 00                     NotW8orD: ldx #$00
0825E 86 08                               stx ObjectOffset           ;run code for a single enemy object
08260 20 68 AD                            jsr EnemiesAndLoopsCore    ;(either the mushroom retainer or door/princess)
08263 20 37 E0                  BrdgSkip: jsr RelativePlayerPosition ;draw the player as usual
08266 4C EC DD                            jmp PlayerGfxHandler
08269                           
08269                           VictoryModeSubroutines:
08269 AD 5F 07                      lda WorldNumber               ;run different list of subroutines if on world 8
0826C C9 07                         cmp #World8
0826E F0 16                         beq VictoryModeSubsForW8andD  ;note that world D will also run second set of subs
08270 C9 0C                         cmp #WorldD
08272 F0 12                         beq VictoryModeSubsForW8andD
08274 AD 72 07                      lda OperMode_Task             ;after running the first two subs in the first set
08277 20 F8 8C                      jsr JumpEngine
0827A                           
0827A 05 BE                         .dw BridgeCollapse
0827C B0 82                         .dw SetupVictoryMode
0827E D8 82                         .dw PlayerVictoryWalk
08280 11 83                         .dw PrintVictoryMessages
08282 5C 83                         .dw EndCastleAward
08284 7F 83                         .dw EndWorld1Thru7
08286                           
08286                           VictoryModeSubsForW8andD:
08286 AD 72 07                      lda OperMode_Task
08289 20 F8 8C                      jsr JumpEngine
0828C                           
0828C 05 BE                         .dw BridgeCollapse
0828E B0 82                         .dw SetupVictoryMode
08290 D8 82                         .dw PlayerVictoryWalk
08292 59 E2                         .dw StartVMDelay
08294 60 E2                         .dw ContinueVMDelay
08296 66 E2                         .dw VictoryModeDiskRoutines
08298 8D E7                         .dw ScreenSubsForFinalRoom    ;all these subs are in SM2DATA3
0829A C9 E7                         .dw PrintVictoryMsgsForWorld8 
0829C 5C 83                         .dw EndCastleAward            ;except this one
0829E 21 E8                         .dw AwardExtraLives           
082A0 6F E8                         .dw FadeToBlue
082A2 B5 E8                         .dw EraseLivesLines
082A4 CC E8                         .dw RunMushroomRetainers
082A6 D8 E8                         .dw EndingDiskRoutines
082A8                           
082A8                           ;-------------------------------------------------------------------------------------
082A8                           
082A8                           WorldBits:
082A8 01 02 04 08 10 20 40 80       .db $01, $02, $04, $08, $10, $20, $40, $80
082B0                           
082B0                           SetupVictoryMode:
082B0 AE 1B 07                           ldx ScreenRight_PageLoc ;get page location of right side of screen
082B3 E8                                 inx                     ;increment to next page
082B4 86 34                              stx DestinationPageLoc
082B6 AC 5F 07                           ldy WorldNumber
082B9 C0 08                              cpy #World9             ;if world 9 or later, skip setting completed worlds bit
082BB B0 09                              bcs SkipCompletedWorlds
082BD B9 A8 82                           lda WorldBits,y
082C0 0D FA 07                           ora CompletedWorlds     ;set bit according to the world the player was in
082C3 8D FA 07                           sta CompletedWorlds
082C6                           SkipCompletedWorlds:
082C6 A9 08                              lda #EndOfCastleMusic
082C8 85 FC                              sta EventMusicQueue     ;play win castle music
082CA                           
082CA                           IncModeTask:
082CA EE 72 07                      inc OperMode_Task
082CD 60                            rts
082CE                           
082CE                           ;-------------------------------------------------------------------------------------
082CE                           
082CE                           DrawTitleScreen:
082CE AD 70 07                      lda OperMode       ;if not in attract mode, do not draw title screen
082D1 D0 F7                         bne IncModeTask    ;yes, this routine is run in other modes
082D3 A9 05                         lda #$05
082D5 4C 81 85                      jmp SetVRAMAddr_B  ;otherwise set up VRAM address controller accordingly
082D8                           
082D8                           ;-------------------------------------------------------------------------------------
082D8                           
082D8                           PlayerVictoryWalk:
082D8 A0 00                                  ldy #$00                ;set value here to not walk player by default
082DA 84 35                                  sty VictoryWalkControl
082DC A5 6D                                  lda Player_PageLoc      ;get player's page location
082DE C5 34                                  cmp DestinationPageLoc  ;compare with destination page location
082E0 D0 06                                  bne PerformWalk         ;if page locations don't match, branch
082E2 A5 86                                  lda Player_X_Position   ;otherwise get player's horizontal position
082E4 C9 60                                  cmp #$60                ;compare with preset horizontal position
082E6 B0 03                                  bcs DontWalk            ;if still on other page, branch ahead
082E8 E6 35                     PerformWalk: inc VictoryWalkControl  ;otherwise increment value and Y
082EA C8                                     iny                     ;note Y will be used to walk the player
082EB 98                        DontWalk:    tya                     ;put contents of Y in A and
082EC 20 51 9D                               jsr AutoControlPlayer   ;use A to move player to the right or not
082EF AD 1A 07                               lda ScreenLeft_PageLoc  ;check page location of left side of screen
082F2 C5 34                                  cmp DestinationPageLoc  ;against set value here
082F4 F0 16                                  beq ExitVWalk           ;branch if equal to change modes if necessary
082F6 AD 68 07                               lda ScrollFractional
082F9 18                                     clc                     ;do fixed point math on fractional part of scroll
082FA 69 80                                  adc #$80        
082FC 8D 68 07                               sta ScrollFractional    ;save fractional movement amount
082FF A9 01                                  lda #$01                ;set 1 pixel per frame
08301 69 00                                  adc #$00                ;add carry from previous addition
08303 A8                                     tay                     ;use as scroll amount
08304 20 33 9C                               jsr ScrollScreen        ;do sub to scroll the screen
08307 20 DE 9B                               jsr UpdScrollVar        ;do another sub to update screen and scroll variables
0830A E6 35                                  inc VictoryWalkControl  ;increment value to stay in this routine
0830C A5 35                     ExitVWalk:   lda VictoryWalkControl  ;load value set here
0830E F0 48                                  beq IncModeTask_A       ;if zero, branch to change modes
08310 60                                     rts                     ;otherwise leave
08311                           
08311                           PrintVictoryMessages:
08311 AD 49 07                                 lda MsgFractional        ;load message counter fractional
08314 D0 28                                    bne IncMsgCounter        ;if not yet wrapped, branch to increment it
08316 AD 19 07                                 lda MsgCounter           ;otherwise load message counter
08319 F0 08                                    beq ThankPlayer          ;if set to zero, branch to print first message
0831B C9 08                                    cmp #$08                 ;if at 8 or above, branch elsewhere
0831D B0 1F                                    bcs IncMsgCounter
0831F C9 01                                    cmp #$01                 ;if at zero, branch (note, this branch is never
08321 90 1B                                    bcc IncMsgCounter        ;taken because we already branched at zero earlier)
08323 A8                        ThankPlayer:   tay
08324 F0 0B                                    beq ChkPlayer
08326 C0 03                                    cpy #$03
08328 B0 27                                    bcs SetEndTimer          ;wait until a specific point to set the timer
0832A C0 02                                    cpy #$02
0832C B0 10                                    bcs IncMsgCounter        ;skip printing of messages after the first two
0832E C8                                       iny                      ;increment Y for second messsage
0832F D0 06                                    bne PrintMsgs            ;unconditional branch
08331 AD 53 07                  ChkPlayer:     lda SelectedPlayer       ;get selected player
08334 F0 01                                    beq PrintMsgs            ;if mario, branch
08336 C8                                       iny                      ;otherwise increment Y once for luigi
08337 98                        PrintMsgs:     tya                      ;put primary message counter in A
08338 18                                       clc                      ;add 12 to counter, thus giving an appropriate value
08339 69 0C                                    adc #$0c
0833B 8D 73 07                                 sta VRAM_Buffer_AddrCtrl ;write message counter to vram address controller
0833E AD 49 07                  IncMsgCounter: lda MsgFractional
08341 18                                       clc
08342 69 04                                    adc #$04                 ;add four to fractional
08344 8D 49 07                                 sta MsgFractional
08347 AD 19 07                                 lda MsgCounter
0834A 69 00                                    adc #$00                 ;carry the one if fractional wraps
0834C 8D 19 07                                 sta MsgCounter
0834F C9 06                                    cmp #$06                 ;check message counter one more time
08351 90 08                     SetEndTimer:   bcc ExitMsgs             ;if not reached 6 yet, branch to leave
08353 A9 08                                    lda #$08
08355 8D A1 07                                 sta WorldEndTimer        ;otherwise set world end timer
08358 EE 72 07                  IncModeTask_A: inc OperMode_Task        ;move onto next task in mode
0835B 60                        ExitMsgs:      rts                 
0835C                           
0835C                           EndCastleAward:
0835C AD A1 07                     lda WorldEndTimer      ;if world end timer has not yet reached a certain point
0835F C9 06                        cmp #$06               ;then go ahead and skip all of this
08361 B0 1B                        bcs ExEWA
08363 AD EC 07                     lda GameTimerDisplay   ;if game timer points not all awarded, skip this part
08366 0D ED 07                     ora GameTimerDisplay+1
08369 0D EE 07                     ora GameTimerDisplay+2
0836C F0 03                        beq SetWorldEndTimer   ;ANN bugfix for castle countdown, skip ahead if timer is zero
0836E 4C 43 C1                     jmp AwardTimerCastle   ;otherwise run timer countdown
08371                           SetWorldEndTimer:
08371 A9 30                        lda #$30
08373 8D 80 07                     sta SelectTimer        ;set select timer (used for world 8 ending only)
08376 A9 06                        lda #$06
08378 8D A1 07                     sta WorldEndTimer      ;another short delay, then on to the next task
0837B EE 72 07                     inc OperMode_Task
0837E                           ExEWA:
0837E 60                           rts
0837F                           
0837F                           EndWorld1Thru7:
0837F AD A1 07                             lda WorldEndTimer         ;skip this until world end timer expires
08382 D0 37                                bne EndExit
08384 A9 00                     NextWorld: lda #$00
08386 8D 60 07                             sta AreaNumber            ;reset area/level numbers to start the next world
08389 8D 5C 07                             sta LevelNumber
0838C 8D 72 07                             sta OperMode_Task
0838F AD 5F 07                             lda WorldNumber
08392 18                                   clc
08393 69 01                                adc #$01                  ;add one to world number
08395 C9 09                                cmp #WorldA               ;are we going into world A?
08397 90 14                                bcc StoreWNum             ;no, update world number accordingly
08399 AC FB 07                             ldy HardWorldFlag         ;are we in SMB1 levels mode?
0839C D0 07                                bne ChkHardM              ;no, it's fine to go to the next world
0839E EE FB 07                             inc HardWorldFlag         ;otherwise we're going into 2J levels
083A1 A9 00                                lda #World1               ;continue the game at world 1 of SMB2J
083A3 F0 08                                beq StoreWNum
083A5 AC 6A 07                  ChkHardM:  ldy PrimaryHardMode       ;have we already set primary hard mode?
083A8 D0 03                                bne StoreWNum             ;yes, branch ahead
083AA EE 6A 07                             inc PrimaryHardMode       ;otherwise go ahead and set it for 2J letter worlds
083AD 8D 5F 07                  StoreWNum: sta WorldNumber           ;update the world number
083B0 20 AF FE                             jsr RunLoadAreaPointer    ;get pointer for the next area
083B3 EE 57 07                             inc FetchNewGameTimerFlag ;and get a new game timer
083B6 A9 01                                lda #$01
083B8 8D 70 07                             sta OperMode              ;and oh yeah, go back to game mode also
083BB 60                        EndExit:   rts
083BC                           
083BC                           ;-------------------------------------------------------------------------------------
083BC                           
083BC                           ;data is used as tiles for numbers
083BC                           ;that appear when you defeat enemies
083BC                           FloateyNumTileData:
083BC FF FF                           .db $ff, $ff ;dummy
083BE F6 FB                           .db $f6, $fb ; "100"
083C0 F7 FB                           .db $f7, $fb ; "200"
083C2 F8 FB                           .db $f8, $fb ; "400"
083C4 F9 FB                           .db $f9, $fb ; "500"
083C6 FA FB                           .db $fa, $fb ; "800"
083C8 F6 50                           .db $f6, $50 ; "1000"
083CA F7 50                           .db $f7, $50 ; "2000"
083CC F8 50                           .db $f8, $50 ; "4000"
083CE F9 50                           .db $f9, $50 ; "5000"
083D0 FA 50                           .db $fa, $50 ; "8000"
083D2 FD FE                           .db $fd, $fe ; "1-UP"
083D4                           
083D4                           ;high nybble is digit number, low nybble is number to
083D4                           ;add to the digit of the player's score
083D4                           ScoreUpdateData:
083D4 FF                              .db $ff ;dummy
083D5 41 42 44 45 48                  .db $41, $42, $44, $45, $48
083DA 31 32 34 35 38 00               .db $31, $32, $34, $35, $38, $00
083E0                           
083E0                           FloateyNumbersRoutine:
083E0 BD 10 01                                lda FloateyNum_Control,x     ;load control for floatey number
083E3 F0 D6                                   beq EndExit                  ;if zero, branch to leave
083E5 C9 0B                                   cmp #$0b                     ;if less than $0b, branch
083E7 90 05                                   bcc ChkNumTimer
083E9 A9 0B                                   lda #$0b                     ;otherwise set to $0b, thus keeping
083EB 9D 10 01                                sta FloateyNum_Control,x     ;it in range
083EE A8                        ChkNumTimer:  tay                          ;use as Y
083EF BD 2C 01                                lda FloateyNum_Timer,x       ;check value here
083F2 D0 04                                   bne DecNumTimer              ;if nonzero, branch ahead
083F4 9D 10 01                                sta FloateyNum_Control,x     ;initialize floatey number control and leave
083F7 60                                      rts
083F8 DE 2C 01                  DecNumTimer:  dec FloateyNum_Timer,x       ;decrement value here
083FB C9 2B                                   cmp #$2b                     ;if not reached a certain point, branch  
083FD D0 1A                                   bne ChkTallEnemy
083FF C0 0B                                   cpy #$0b                     ;check offset for $0b
08401 D0 03                                   bne LoadNumTiles             ;branch ahead if not found
08403 20 80 84                                jsr GiveExtraLife            ;award an extra life
08406 B9 D4 83                  LoadNumTiles: lda ScoreUpdateData,y        ;load point value here
08409 4A                                      lsr                          ;move high nybble to low
0840A 4A                                      lsr
0840B 4A                                      lsr
0840C 4A                                      lsr
0840D AA                                      tax                          ;use as X offset, essentially the digit
0840E B9 D4 83                                lda ScoreUpdateData,y        ;load again and this time
08411 29 0F                                   and #%00001111               ;mask out the high nybble
08413 9D 34 01                                sta DigitModifier,x          ;store as amount to add to the digit
08416 20 38 A9                                jsr AddToScore               ;update the score accordingly
08419 BC E5 06                  ChkTallEnemy: ldy Enemy_SprDataOffset,x    ;get OAM data offset for enemy object
0841C B5 16                                   lda Enemy_ID,x               ;get enemy object identifier
0841E C9 12                                   cmp #Spiny
08420 F0 22                                   beq FloateyPart              ;branch if spiny
08422 C9 0D                                   cmp #PiranhaPlant
08424 F0 1E                                   beq FloateyPart              ;branch if piranha plant
08426 C9 05                                   cmp #HammerBro
08428 F0 12                                   beq GetAltOffset             ;branch elsewhere if hammer bro
0842A C9 0A                                   cmp #GreyCheepCheep
0842C F0 16                                   beq FloateyPart              ;branch if cheep-cheep of either color
0842E C9 0B                                   cmp #RedCheepCheep
08430 F0 12                                   beq FloateyPart
08432 C9 09                                   cmp #TallEnemy
08434 B0 06                                   bcs GetAltOffset             ;branch elsewhere if enemy object => $09
08436 B5 1E                                   lda Enemy_State,x
08438 C9 02                                   cmp #$02                     ;if enemy state defeated or otherwise
0843A B0 08                                   bcs FloateyPart              ;$02 or greater, branch beyond this part
0843C AE EE 03                  GetAltOffset: ldx SprDataOffset_Ctrl       ;load some kind of control bit
0843F BC EC 06                                ldy Alt_SprDataOffset,x      ;get alternate OAM data offset
08442 A6 08                                   ldx ObjectOffset             ;get enemy object offset again
08444 BD 1E 01                  FloateyPart:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate for
08447 C9 18                                   cmp #$18                     ;floatey number, if coordinate in the
08449 90 05                                   bcc SetupNumSpr              ;status bar, branch
0844B E9 01                                   sbc #$01
0844D 9D 1E 01                                sta FloateyNum_Y_Pos,x       ;otherwise subtract one and store as new
08450 BD 1E 01                  SetupNumSpr:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate
08453 E9 08                                   sbc #$08                     ;subtract eight and dump into the
08455 20 79 D4                                jsr DumpTwoSpr               ;left and right sprite's Y coordinates
08458 BD 17 01                                lda FloateyNum_X_Pos,x       ;get horizontal coordinate
0845B 99 03 02                                sta Sprite_X_Position,y      ;store into X coordinate of left sprite
0845E 18                                      clc
0845F 69 08                                   adc #$08                     ;add eight pixels and store into X
08461 99 07 02                                sta Sprite_X_Position+4,y    ;coordinate of right sprite
08464 A9 02                                   lda #$02
08466 99 02 02                                sta Sprite_Attributes,y      ;set palette control in attribute bytes
08469 99 06 02                                sta Sprite_Attributes+4,y    ;of left and right sprites
0846C BD 10 01                                lda FloateyNum_Control,x
0846F 0A                                      asl                          ;multiply our floatey number control by 2
08470 AA                                      tax                          ;and use as offset for look-up table
08471 BD BC 83                                lda FloateyNumTileData,x
08474 99 01 02                                sta Sprite_Tilenumber,y      ;display first half of number of points
08477 BD BD 83                                lda FloateyNumTileData+1,x
0847A 99 05 02                                sta Sprite_Tilenumber+4,y    ;display the second half
0847D A6 08                                   ldx ObjectOffset             ;get enemy object offset and leave
0847F 60                                      rts
08480                           
08480                           GiveExtraLife:
08480 EE 5A 07                        inc NumberofLives      ;give the player an extra life
08483 AD 5A 07                        lda NumberofLives      ;have we exceeded the maximum number of lives?
08486 C9 80                           cmp #$80
08488 90 05                           bcc NotMaxLives        ;if not, branch ahead to play 1-up sound
0848A A9 7F                           lda #$7f               ;otherwise cap lives at 128
0848C 8D 5A 07                        sta NumberofLives
0848F                           NotMaxLives:
0848F A9 40                           lda #Sfx_ExtraLife
08491 85 FE                           sta Square2SoundQueue  ;play 1-up sound
08493 60                              rts                    ;leave
08494                           
08494                           ;-------------------------------------------------------------------------------------
08494                           
08494                           ScreenRoutines:
08494 AD 3C 07                     lda ScreenRoutineTask
08497 20 F8 8C                     jsr JumpEngine
0849A                           
0849A BA 84                        .dw InitScreen
0849C CA 84                        .dw SetupIntermediate
0849E 87 85                        .dw WriteTopStatusLine
084A0 8F 85                        .dw WriteBottomStatusLine
084A2 D1 85                        .dw DisplayTimeUp
084A4 CD 87                        .dw ResetSpritesAndScreenTimer
084A6 F0 85                        .dw DisplayIntermediate
084A8 74 E7                        .dw DemoResetOrGameOver
084AA CD 87                        .dw ResetSpritesAndScreenTimer
084AC 33 86                        .dw AreaParserTaskControl
084AE EE 84                        .dw GetAreaPalette
084B0 16 85                        .dw GetBackgroundColor
084B2 78 85                        .dw GetAlternatePalette1
084B4 CE 82                        .dw DrawTitleScreen
084B6 FC E3                        .dw ClearBuffersDrawIcon
084B8 60 E4                        .dw WriteTopScore
084BA                           
084BA                           InitScreen:
084BA 20 30 82                        jsr MoveAllSpritesOffscreen ;initialize all sprites including sprite #0
084BD 20 0D 8D                        jsr InitializeNameTables    ;and erase both name and attribute tables
084C0 AD 70 07                        lda OperMode
084C3 F0 32                           beq NextSubtask             ;if in attact mode, do not set pointer control
084C5                           InitScreenPalette:
084C5 A2 03                           ldx #$03                    ;otherwise set for underground palette
084C7 4C F4 84                        jmp SetVRAMAddr_A
084CA                           
084CA                           SetupIntermediate:
084CA AD 44 07                        lda BackgroundColorCtrl  ;save current background color control
084CD 48                              pha                      ;and player status to stack
084CE AD 56 07                        lda PlayerStatus
084D1 48                              pha
084D2 A9 00                           lda #$00                 ;set background color to black
084D4 8D 56 07                        sta PlayerStatus         ;and player status to not fiery
084D7 A9 02                           lda #$02                 ;this is the ONLY time background color control
084D9 8D 44 07                        sta BackgroundColorCtrl  ;is set to less than 4
084DC 20 24 85                        jsr GetPlayerColors
084DF 68                              pla                      ;set up colors for intermediate lives display
084E0 8D 56 07                        sta PlayerStatus
084E3 68                              pla                      ;return bg color control and player status
084E4 8D 44 07                        sta BackgroundColorCtrl
084E7 4C EC 85                        jmp IncSubtask           ;then move onto the next task
084EA                           
084EA                           AreaPalette:
084EA 01 02 03 04                     .db $01, $02, $03, $04
084EE                           
084EE                           GetAreaPalette:
084EE AC 4E 07                                 ldy AreaType             ;select appropriate palette to load
084F1 BE EA 84                                 ldx AreaPalette,y        ;based on area type
084F4 8E 73 07                  SetVRAMAddr_A: stx VRAM_Buffer_AddrCtrl ;store offset into buffer control
084F7 4C EC 85                  NextSubtask:   jmp IncSubtask           ;move onto next task
084FA                           
084FA                           ;-------------------------------------------------------------------------------------
084FA                           ;$00 - used as temp counter in GetPlayerColors
084FA                           
084FA                           BGColorCtrl_Addr:
084FA 00 09 0A 04                     .db $00, $09, $0a, $04
084FE                           
084FE                           BackgroundColors:
084FE 22 22 0F 0F                     .db $22, $22, $0f, $0f ;used by area type if bg color ctrl not set
08502 0F 22 0F 0F                     .db $0f, $22, $0f, $0f ;used by background color control if set
08506                           
08506                           PlayerColors:
08506 22 16 27 18                     .db $22, $16, $27, $18 ;mario's normal colors
0850A 22 1A 27 18                     .db $22, $1A, $27, $18 ;luigi's normal colors
0850E 22 37 27 16                     .db $22, $37, $27, $16 ;mario's colors after grabbing fire flower
08512 22 30 27 19                     .db $22, $30, $27, $19 ;luigi's colors after grabbing fire flower
08516                           
08516                           GetBackgroundColor:
08516 AC 44 07                             ldy BackgroundColorCtrl   ;check background color control
08519 F0 06                                beq NoBGColor             ;if not set, increment task and fetch palette
0851B B9 F6 84                             lda BGColorCtrl_Addr-4,y  ;put appropriate palette into vram
0851E 8D 73 07                             sta VRAM_Buffer_AddrCtrl  ;note that if set to 5-7, first VRAM buffer will not be read
08521 EE 3C 07                  NoBGColor: inc ScreenRoutineTask     ;increment to next subtask and plod on through
08524                                 
08524                           GetPlayerColors:
08524 AE 00 03                                 ldx VRAM_Buffer1_Offset  ;get current buffer offset
08527 A9 00                                    lda #$00                 ;load offset for mario
08529 AC 53 07                                 ldy SelectedPlayer       ;check which player is on the screen
0852C F0 02                                    beq ChkFiery             ;if mario, branch
0852E A9 04                                    lda #$04                 ;otherwise load offset for luigi
08530 AC 56 07                  ChkFiery:      ldy PlayerStatus         ;check player status
08533 C0 02                                    cpy #$02
08535 D0 03                                    bne StartClrGet          ;if fiery, add $08 to offset for fiery player
08537 18                                       clc
08538 69 08                                    adc #$08
0853A A8                        StartClrGet:   tay                      ;transfer our offset into Y
0853B A9 03                                    lda #$03                 ;do four colors
0853D 85 00                                    sta $00
0853F B9 06 85                  ClrGetLoop:    lda PlayerColors,y       ;fetch player colors and store them
08542 9D 04 03                                 sta VRAM_Buffer1+3,x     ;in the buffer
08545 C8                                       iny
08546 E8                                       inx
08547 C6 00                                    dec $00
08549 10 F4                                    bpl ClrGetLoop
0854B AE 00 03                                 ldx VRAM_Buffer1_Offset  ;load original offset from before
0854E AC 44 07                                 ldy BackgroundColorCtrl  ;if this value is four or greater, it will be set
08551 D0 03                                    bne SetBGColor           ;therefore use it as offset to background color
08553 AC 4E 07                                 ldy AreaType             ;otherwise use area type bits from area offset as offset
08556 B9 FE 84                  SetBGColor:    lda BackgroundColors,y   ;to background color instead
08559 9D 04 03                                 sta VRAM_Buffer1+3,x
0855C A9 3F                                    lda #$3f                 ;set for sprite palette address
0855E 9D 01 03                                 sta VRAM_Buffer1,x       ;save to buffer
08561 A9 10                                    lda #$10
08563 9D 02 03                                 sta VRAM_Buffer1+1,x
08566 A9 04                                    lda #$04                 ;write length byte to buffer
08568 9D 03 03                                 sta VRAM_Buffer1+2,x
0856B A9 00                                    lda #$00                 ;now the null terminator
0856D 9D 08 03                                 sta VRAM_Buffer1+7,x
08570 8A                                       txa                      ;move the buffer pointer ahead 7 bytes
08571 18                                       clc                      ;in case we want to write anything else later
08572 69 07                                    adc #$07
08574 8D 00 03                  SetVRAMOffset: sta VRAM_Buffer1_Offset  ;store as new vram buffer offset
08577 60                                       rts
08578                           
08578                           GetAlternatePalette1:
08578 AD 33 07                                 lda AreaStyle            ;check for mushroom level style
0857B C9 01                                    cmp #$01
0857D D0 05                                    bne NoAltPal
0857F A9 0B                                    lda #$0b                 ;if found, load appropriate palette
08581 8D 73 07                  SetVRAMAddr_B: sta VRAM_Buffer_AddrCtrl
08584 4C EC 85                  NoAltPal:      jmp IncSubtask           ;now onto the next task
08587                           
08587                           WriteTopStatusLine:
08587 A9 00                           lda #$00          ;select main status bar
08589 20 2B 87                        jsr WriteGameText ;output it
0858C 4C EC 85                        jmp IncSubtask    ;onto the next task
0858F                           
0858F                           WriteBottomStatusLine:
0858F 20 3D A9                        jsr WriteScoreAndCoinTally ;write player's score and coin tally to screen
08592 AE 00 03                        ldx VRAM_Buffer1_Offset
08595 A9 20                           lda #$20                   ;write address for world-area number on screen
08597 9D 01 03                        sta VRAM_Buffer1,x
0859A A9 73                           lda #$73
0859C 9D 02 03                        sta VRAM_Buffer1+1,x
0859F A9 03                           lda #$03                   ;write length for it
085A1 9D 03 03                        sta VRAM_Buffer1+2,x
085A4 AC 5F 07                        ldy WorldNumber            ;get the current world number
085A7 C8                              iny                        ;increment the world number/letter because
085A8 98                              tya                        ;the internal world number counts from 0, not 1
085A9 9D 04 03                        sta VRAM_Buffer1+3,x
085AC AD FB 07                        lda HardWorldFlag
085AF F0 04                           beq PutD
085B1 A9 9F                           lda #$9f                   ;put star instead of dash if playing 2J levels
085B3 D0 02                           bne PutS
085B5 A9 28                     PutD: lda #$28                   ;next the dash
085B7 9D 05 03                  PutS: sta VRAM_Buffer1+4,x
085BA AC 5C 07                        ldy LevelNumber            ;next the level number
085BD C8                              iny                        ;increment for proper number display
085BE 98                              tya
085BF 9D 06 03                        sta VRAM_Buffer1+5,x
085C2 A9 00                           lda #$00                   ;put null terminator at the end
085C4 9D 07 03                        sta VRAM_Buffer1+6,x
085C7 8A                              txa                        ;move the buffer offset up by 6 bytes
085C8 18                              clc
085C9 69 06                           adc #$06
085CB 8D 00 03                        sta VRAM_Buffer1_Offset
085CE 4C EC 85                        jmp IncSubtask
085D1                           
085D1                           DisplayTimeUp:
085D1 AD 59 07                            lda GameTimerExpiredFlag  ;if game timer not expired, increment task
085D4 F0 13                               beq IncSubtaskby2         ;control 2 tasks forward, otherwise, stay here
085D6 A9 00                               lda #$00
085D8 8D 59 07                            sta GameTimerExpiredFlag  ;reset timer expiration flag
085DB A9 02                               lda #$02                  ;output time-up screen to buffer
085DD                           OtherInter:
085DD 20 2B 87                            jsr WriteGameText
085E0 20 D5 87                            jsr ResetScreenTimer
085E3 A9 00                               lda #$00
085E5 8D 74 07                            sta DisableScreenFlag
085E8 60                                  rts
085E9                           
085E9                           IncSubtaskby2:
085E9 EE 3C 07                        inc ScreenRoutineTask
085EC                           IncSubtask:
085EC EE 3C 07                        inc ScreenRoutineTask
085EF 60                              rts
085F0                           
085F0                           DisplayIntermediate:
085F0 A9 00                                    lda #$00
085F2 8D 7A 07                                 sta NameTableSelect          ;we need to reset nametable unlike super mario bros 1
085F5 AD 70 07                                 lda OperMode                 ;check primary mode of operation
085F8 F0 33                                    beq NoInter                  ;if in attract mode, do not display intermediate screens
085FA C9 03                                    cmp #GameOverMode            ;are we in game over mode?
085FC F0 22                                    beq GameOverInter            ;if so, proceed to display game over screen
085FE AD 52 07                                 lda AltEntranceControl       ;otherwise check for mode of alternate entry
08601 D0 2A                                    bne NoInter                  ;and branch if found
08603 AC 4E 07                                 ldy AreaType                 ;check if we are on castle level
08606 C0 03                                    cpy #$03                     ;and if so, branch (possibly residual)
08608 F0 05                                    beq PlayerInter
0860A AD 69 07                                 lda DisableIntermediate      ;if this flag is set, skip intermediate lives display
0860D D0 1E                                    bne NoInter                  ;and jump to specific task, otherwise
0860F 20 A7 DE                  PlayerInter:   jsr DrawPlayer_Intermediate  ;put player in appropriate place for
08612 A9 01                                    lda #$01                     ;lives display, then output lives display to buffer
08614 20 DD 85                  OutputInter:   jsr OtherInter
08617 AD F5 07                                 lda GameOverMsgFlag          ;if special message flag not set, do next task
0861A F0 D0                                    beq IncSubtask
0861C EE 74 07                                 inc DisableScreenFlag        ;disable screen output
0861F 60                                       rts
08620                           
08620 A9 03                     GameOverInter: lda #$03                     ;output game over screen to buffer
08622 20 2B 87                                 jsr WriteGameText
08625 AD F5 07                                 lda GameOverMsgFlag
08628 D0 C2                                    bne IncSubtask
0862A 4C CA 82                                 jmp IncModeTask
0862D                           
0862D A9 09                     NoInter:       lda #$09                     ;skip ahead in screen routine list
0862F 8D 3C 07                                 sta ScreenRoutineTask        ;to execute area parser
08632 60                                       rts
08633                           
08633                           AreaParserTaskControl:
08633 EE 74 07                             inc DisableScreenFlag     ;turn off screen
08636 20 6E 91                  TaskLoop:  jsr AreaParserTaskHandler ;render column set of current area
08639 AD 1F 07                             lda AreaParserTaskNum     ;check number of tasks
0863C D0 F8                                bne TaskLoop              ;if tasks still not all done, do another one
0863E CE 1E 07                             dec ColumnSets            ;do we need to render more column sets?
08641 10 03                                bpl OutputCol
08643 EE 3C 07                             inc ScreenRoutineTask     ;if not, move on to the next task
08646 A9 06                     OutputCol: lda #$06                  ;set vram buffer to output rendered column set
08648 8D 73 07                             sta VRAM_Buffer_AddrCtrl  ;on next NMI
0864B 60                                   rts
0864C                           
0864C                           GameText:
0864C                           TopStatusBarLine:
0864C 20 43 05 16 0A 1B 12 18     .db $20, $43, $05, $16, $0a, $1b, $12, $18 ;"MARIO"
08654 20 52 0B 20 18 1B 15 0D     .db $20, $52, $0b, $20, $18, $1b, $15, $0d ;"WORLD  TIME"
0865C 24 24 1D 12 16 0E           .db $24, $24, $1d, $12, $16, $0e
08662 20 68 05 00 24 24 2E 29     .db $20, $68, $05, $00, $24, $24, $2e, $29 ;score trailing digit and coin display
0866A 23 C0 7F AA                 .db $23, $c0, $7f, $aa ;attribute table data, clears name table 0 to palette 2
0866E 23 C2 01 EA                 .db $23, $c2, $01, $ea ;attribute table data, used for coin icon in status bar
08672 FF                          .db $ff ;end of data block
08673                           
08673                           WorldLivesDisplay:
08673 21 CD 07 24 24              .db $21, $cd, $07, $24, $24 ;cross with spaces used on
08678 29 24 24 24 24              .db $29, $24, $24, $24, $24 ;lives display
0867D 21 4B 09 20 18              .db $21, $4b, $09, $20, $18 ;"WORLD  - " used on lives display
08682 1B 15 0D 24 24 28 24        .db $1b, $15, $0d, $24, $24, $28, $24
08689 22 0C 47 24                 .db $22, $0c, $47, $24 ;possibly used to clear time up
0868D FF                          .db $ff
0868E                           
0868E                           TimeUp:
0868E 22 0C 07 1D 12 16 0E 24..   .db $22, $0c, $07, $1d, $12, $16, $0e, $24, $1e, $19 ; "TIME UP"
08698 FF                          .db $ff
08699                           
08699                           GameOver:
08699 21 6B 09 10 0A 16 0E 24     .db $21, $6b, $09, $10, $0a, $16, $0e, $24 ;"GAME OVER"
086A1 18 1F 0E 1B                 .db $18, $1f, $0e, $1b
086A5 21 EB 08 0C 18 17 1D 12..   .db $21, $eb, $08, $0c, $18, $17, $1d, $12, $17, $1e, $0e ;"CONTINUE"
086B0 22 0C 47 24                 .db $22, $0c, $47, $24
086B4 22 4B 05 1B 0E 1D 1B 22     .db $22, $4b, $05, $1b, $0e, $1d, $1b, $22 ;"RETRY"
086BC FF                          .db $ff
086BD                           
086BD                           WarpZone:
086BD 25 84 15                    .db $25, $84, $15
086C0 20 0E 15 0C 18 16 0E 24..   .db $20, $0e, $15, $0c, $18, $16, $0e, $24, $1d, $18 ; "WELCOME TO WARP ZONE!"
086CA 24 20 0A 1B 19 24 23 18..   .db $24, $20, $0a, $1b, $19, $24, $23, $18, $17, $0e
086D4 2B                          .db $2b
086D5 26 25 01 24                 .db $26, $25, $01, $24         ; placeholder for left pipe
086D9 26 2D 01 24                 .db $26, $2d, $01, $24         ; placeholder for middle pipe
086DD 26 35 01 24                 .db $26, $35, $01, $24         ; placeholder for right pipe
086E1 27 D9 46 AA                 .db $27, $d9, $46, $aa         ; attribute data
086E5 27 E1 45 AA                 .db $27, $e1, $45, $aa
086E9 00                          .db $00
086EA                           
086EA                           LuigiName:
086EA 15 1E 12 10 12              .db $15, $1e, $12, $10, $12 ; "LUIGI", no address or length
086EF                           
086EF                           WarpZoneNumbers:
086EF 04 03 02 00                 .db $04, $03, $02, $00         ; warp zone numbers, note spaces on middle
086F3 24 05 24 00                 .db $24, $05, $24, $00         ; zone, partly responsible for
086F7 08 07 06 00                 .db $08, $07, $06, $00         ; the minus world
086FB                           
086FB 24 02 24 00                 .db $24, $02, $24, $00         ; 1-2 underground main area warpzone
086FF 24 03 24 00                 .db $24, $03, $24, $00         ; 1-2 ground subarea warpzone
08703 24 04 24 00                 .db $24, $04, $24, $00         ; 1-2 underground subarea warpzone
08707 24 01 24 00                 .db $24, $01, $24, $00         ; 3-1 warpzone
0870B 24 06 24 00                 .db $24, $06, $24, $00         ; 5-1 warpzone
0870F 24 07 24 00                 .db $24, $07, $24, $00         ; 5-2 underground main area warpzone
08713 24 08 24 00                 .db $24, $08, $24, $00         ; 5-2 ground subarea warpzone
08717 24 05 24 00                 .db $24, $05, $24, $00         ; 8-1 warpzone
0871B 24 0B 24 00                 .db $24, $0b, $24, $00         ; A-2 warpzone
0871F 24 0C 24 00                 .db $24, $0c, $24, $00         ; A-3 warpzone
08723 24 0D 24 00                 .db $24, $0d, $24, $00         ; B-4 warpzone
08727                           
08727                           GameTextOffsets:
08727 00                           .db TopStatusBarLine-GameText
08728 27                           .db WorldLivesDisplay-GameText
08729 42                           .db TimeUp-GameText
0872A 4D                           .db GameOver-GameText
0872B                           
0872B                           WriteGameText:
0872B 48                                       pha                       ;save text number to stack and use as offset
0872C A8                                       tay
0872D BE 27 87                                 ldx GameTextOffsets,y     ;get offset to game text we want to print
08730 A0 00                                    ldy #$00
08732 BD 4C 86                  GameTextLoop:  lda GameText,x            ;load game text data
08735 C9 FF                                    cmp #$ff                  ;check for terminator
08737 F0 07                                    beq EndGameText           ;branch to end text if found
08739 99 01 03                                 sta VRAM_Buffer1,y        ;otherwise write data to buffer
0873C E8                                       inx                       ;and increment increment
0873D C8                                       iny
0873E D0 F2                                    bne GameTextLoop          ;do this for 256 bytes if no terminator found
08740 A9 00                     EndGameText:   lda #$00                  ;put null terminator at end
08742 99 01 03                                 sta VRAM_Buffer1,y
08745 68                                       pla                       ;pull original text number from stack
08746 F0 4B                                    beq CheckPlayerName       ;if printing top status bar, branch to check player's name
08748 AA                                       tax
08749 CA                                       dex                       ;if printing anything else besides world/lives display
0874A D0 46                                    bne ExWGT                 ;then branch to leave
0874C AD 5A 07                                 lda NumberofLives         ;otherwise, check number of lives
0874F 18                                       clc                       ;and increment by one for display
08750 69 01                                    adc #1
08752 A0 00                                    ldy #0                    ;initialize register for tens digit
08754 A2 00                                    ldx #0                    ;and register for hundreds digit
08756 C9 0A                     LivesLoop:     cmp #10                   ;more than 9 lives?
08758 90 0C                                    bcc PutHundreds           ;if not, branch ahead
0875A E9 0A                                    sbc #10                   ;if so, subtract 10 from ones digit
0875C C8                                       iny                       ;and increment tens digit
0875D C0 0A                                    cpy #10                   ;have we reached the hundreds digit?
0875F 90 F5                                    bcc LivesLoop             ;if not, branch back
08761 A0 00                                    ldy #0                    ;otherwise set tens digit to zero
08763 E8                                       inx                       ;and increment hundreds digit
08764 D0 F0                                    bne LivesLoop             ;unconditional branch
08766 E0 00                     PutHundreds:   cpx #0                    ;if hundreds digit is 0, don't bother showing it
08768 F0 05                                    beq PutTens
0876A 8E 08 03                                 stx VRAM_Buffer1+7        ;write hundreds digit of lives to screen
0876D D0 04                                    bne WriteTens
0876F C0 00                     PutTens:       cpy #0                    ;if tens digit is 0, don't bother showing it
08771 F0 03                                    beq PutOnes
08773 8C 09 03                  WriteTens:     sty VRAM_Buffer1+8        ;write tens digit of lives to screen
08776 8D 0A 03                  PutOnes:       sta VRAM_Buffer1+9        ;write ones digit of lives to screen
08779 AC 5F 07                                 ldy WorldNumber           ;get the current world number
0877C C8                                       iny                       ;increment the world number/letter because
0877D 98                                       tya                       ;the internal world number counts from 0, not 1
0877E 8D 14 03                                 sta VRAM_Buffer1+19
08781 AD FB 07                                 lda HardWorldFlag
08784 F0 05                                    beq PutLevelNum
08786 A9 9F                                    lda #$9f                  ;put star instead of dash if playing 2J levels
08788 8D 15 03                                 sta VRAM_Buffer1+20
0878B AC 5C 07                  PutLevelNum:   ldy LevelNumber
0878E C8                                       iny
0878F 8C 16 03                                 sty VRAM_Buffer1+21       ;we're done here
08792 60                        ExWGT:         rts
08793                           
08793                           CheckPlayerName:
08793 AD 53 07                               lda SelectedPlayer     ;check selected player
08796 F0 0B                                  beq ExitChkName        ;if mario, leave
08798 A0 04                                  ldy #$04
0879A B9 EA 86                  NameLoop:    lda LuigiName,y        ;otherwise, replace "MARIO" with "LUIGI"
0879D 99 04 03                               sta VRAM_Buffer1+3,y
087A0 88                                     dey
087A1 10 F7                                  bpl NameLoop           ;do this until each letter is replaced
087A3 60                        ExitChkName: rts
087A4                           
087A4                           WriteWarpZoneMessage:
087A4 48                                 pha                   ;save warp zone control temporarily
087A5 A0 FF                              ldy #$ff
087A7 C8                        WZMLoop: iny
087A8 B9 BD 86                           lda WarpZone,y        ;write warp zone message to VRAM buffer
087AB 99 01 03                           sta VRAM_Buffer1,y
087AE D0 F7                              bne WZMLoop
087B0 68                                 pla
087B1 38                                 sec
087B2 E9 80                              sbc #$80              ;clear d7 of warp zone control, use as offset
087B4 0A                                 asl                   ;shift to the left twice to get
087B5 0A                                 asl                   ;proper warp zone number offset
087B6 AA                                 tax
087B7 A0 00                              ldy #$00
087B9 BD EF 86                  WNumLp:  lda WarpZoneNumbers,x ;print warp zone numbers into the
087BC 99 1C 03                           sta VRAM_Buffer1+27,y ;placeholders from earlier
087BF E8                                 inx
087C0 C8                                 iny                   ;put a number in every fourth space
087C1 C8                                 iny
087C2 C8                                 iny
087C3 C8                                 iny
087C4 C0 0C                              cpy #$0c
087C6 90 F1                              bcc WNumLp
087C8 A9 2C                              lda #$2c              ;set VRAM offset after the contents
087CA 4C 74 85                           jmp SetVRAMOffset     ;in case anything else needs to go in there
087CD                           
087CD                           ResetSpritesAndScreenTimer:
087CD AD A0 07                           lda ScreenTimer             ;check if screen timer has expired
087D0 D0 0B                              bne NoReset                 ;if not, branch to leave
087D2 20 30 82                           jsr MoveAllSpritesOffscreen ;otherwise reset sprites now
087D5                           
087D5                           ResetScreenTimer:
087D5 A9 07                              lda #$07                    ;reset timer again
087D7 8D A0 07                           sta ScreenTimer
087DA EE 3C 07                           inc ScreenRoutineTask       ;move onto next task
087DD 60                        NoReset: rts
087DE                           
087DE                           ;-------------------------------------------------------------------------------------
087DE                           ;$00 - temp vram buffer offset
087DE                           ;$01 - temp metatile buffer offset
087DE                           ;$02 - temp metatile graphics table offset
087DE                           ;$03 - used to store attribute bits
087DE                           ;$04 - used to determine attribute table row
087DE                           ;$05 - used to determine attribute table column
087DE                           ;$06 - metatile graphics table address low
087DE                           ;$07 - metatile graphics table address high
087DE                           
087DE                           RenderAreaGraphics:
087DE AD 26 07                              lda CurrentColumnPos         ;store LSB of where we're at
087E1 29 01                                 and #$01
087E3 85 05                                 sta $05
087E5 AC 40 03                              ldy VRAM_Buffer2_Offset      ;store vram buffer offset
087E8 84 00                                 sty $00
087EA AD 21 07                              lda CurrentNTAddr_Low        ;get current name table address we're supposed to render
087ED 99 42 03                              sta VRAM_Buffer2+1,y
087F0 AD 20 07                              lda CurrentNTAddr_High
087F3 99 41 03                              sta VRAM_Buffer2,y
087F6 A9 9A                                 lda #$9a                     ;store length byte of 26 here with d7 set
087F8 99 43 03                              sta VRAM_Buffer2+2,y         ;to increment by 32 (in columns)
087FB A9 00                                 lda #$00                     ;init attribute row
087FD 85 04                                 sta $04
087FF AA                                    tax
08800 86 01                     DrawMTLoop: stx $01                      ;store init value of 0 or incremented offset for buffer
08802 BD A1 06                              lda MetatileBuffer,x         ;get first metatile number, and mask out all but 2 MSB
08805 29 C0                                 and #%11000000
08807 85 03                                 sta $03                      ;store attribute table bits here
08809 0A                                    asl                          ;note that metatile format is:
0880A 2A                                    rol                          ;%xx000000 - attribute table bits, 
0880B 2A                                    rol                          ;%00xxxxxx - metatile number
0880C A8                                    tay                          ;rotate bits to d1-d0 and use as offset here
0880D B9 38 8A                              lda MetatileGraphics_Low,y   ;get address to graphics table from here
08810 85 06                                 sta $06
08812 B9 3C 8A                              lda MetatileGraphics_High,y
08815 85 07                                 sta $07
08817 BD A1 06                              lda MetatileBuffer,x         ;get metatile number again
0881A 0A                                    asl                          ;multiply by 4 and use as tile offset
0881B 0A                                    asl
0881C 85 02                                 sta $02
0881E AD 1F 07                              lda AreaParserTaskNum        ;get current task number for level processing and
08821 29 01                                 and #%00000001               ;mask out all but LSB, then invert LSB, multiply by 2
08823 49 01                                 eor #%00000001               ;to get the correct column position in the metatile,
08825 0A                                    asl                          ;then add to the tile offset so we can draw either side
08826 65 02                                 adc $02                      ;of the metatiles
08828 A8                                    tay
08829 A6 00                                 ldx $00                      ;use vram buffer offset from before as X
0882B B1 06                                 lda ($06),y
0882D 9D 44 03                              sta VRAM_Buffer2+3,x         ;get first tile number (top left or top right) and store
08830 C8                                    iny
08831 B1 06                                 lda ($06),y                  ;now get the second (bottom left or bottom right) and store
08833 9D 45 03                              sta VRAM_Buffer2+4,x
08836 A4 04                                 ldy $04                      ;get current attribute row
08838 A5 05                                 lda $05                      ;get LSB of current column where we're at, and
0883A D0 0E                                 bne RightCheck               ;branch if set (clear = left attrib, set = right)
0883C A5 01                                 lda $01                      ;get current row we're rendering
0883E 4A                                    lsr                          ;branch if LSB set (clear = top left, set = bottom left)
0883F B0 19                                 bcs LLeft
08841 26 03                                 rol $03                      ;rotate attribute bits 3 to the left
08843 26 03                                 rol $03                      ;thus in d1-d0, for upper left square
08845 26 03                                 rol $03
08847 4C 60 88                              jmp SetAttrib
0884A A5 01                     RightCheck: lda $01                      ;get LSB of current row we're rendering
0884C 4A                                    lsr                          ;branch if set (clear = top right, set = bottom right)
0884D B0 0F                                 bcs NextMTRow
0884F 46 03                                 lsr $03                      ;shift attribute bits 4 to the right
08851 46 03                                 lsr $03                      ;thus in d3-d2, for upper right square
08853 46 03                                 lsr $03
08855 46 03                                 lsr $03
08857 4C 60 88                              jmp SetAttrib
0885A 46 03                     LLeft:      lsr $03                      ;shift attribute bits 2 to the right
0885C 46 03                                 lsr $03                      ;thus in d5-d4 for lower left square
0885E E6 04                     NextMTRow:  inc $04                      ;move onto next attribute row  
08860 B9 F9 03                  SetAttrib:  lda AttributeBuffer,y        ;get previously saved bits from before
08863 05 03                                 ora $03                      ;if any, and put new bits, if any, onto
08865 99 F9 03                              sta AttributeBuffer,y        ;the old, and store
08868 E6 00                                 inc $00                      ;increment vram buffer offset by 2
0886A E6 00                                 inc $00
0886C A6 01                                 ldx $01                      ;get current gfx buffer row, and check for
0886E E8                                    inx                          ;the bottom of the screen
0886F E0 0D                                 cpx #$0d
08871 90 8D                                 bcc DrawMTLoop               ;if not there yet, loop back
08873 A4 00                                 ldy $00                      ;get current vram buffer offset, increment by 3
08875 C8                                    iny                          ;(for name table address and length bytes)
08876 C8                                    iny
08877 C8                                    iny
08878 A9 00                                 lda #$00
0887A 99 41 03                              sta VRAM_Buffer2,y           ;put null terminator at end of data for name table
0887D 8C 40 03                              sty VRAM_Buffer2_Offset      ;store new buffer offset
08880 EE 21 07                              inc CurrentNTAddr_Low        ;increment name table address low
08883 AD 21 07                              lda CurrentNTAddr_Low        ;check current low byte
08886 29 1F                                 and #%00011111               ;if no wraparound, just skip this part
08888 D0 0D                                 bne ExitDrawM
0888A A9 80                                 lda #$80                     ;if wraparound occurs, make sure low byte stays
0888C 8D 21 07                              sta CurrentNTAddr_Low        ;just under the status bar
0888F AD 20 07                              lda CurrentNTAddr_High       ;and then invert d2 of the name table address high
08892 49 04                                 eor #%00000100               ;to move onto the next appropriate name table
08894 8D 20 07                              sta CurrentNTAddr_High
08897 4C ED 88                  ExitDrawM:  jmp SetVRAMCtrl              ;jump to set VRAM address controller
0889A                           
0889A                           RenderAttributeTables:
0889A AD 21 07                               lda CurrentNTAddr_Low    ;get low byte of next name table address
0889D 29 1F                                  and #%00011111           ;to be written to, mask out all but 5 LSB,
0889F 38                                     sec                      ;subtract four 
088A0 E9 04                                  sbc #$04
088A2 29 1F                                  and #%00011111           ;mask out bits again and store
088A4 85 01                                  sta $01
088A6 AD 20 07                               lda CurrentNTAddr_High   ;get high byte and branch if borrow not set
088A9 B0 02                                  bcs SetATHigh
088AB 49 04                                  eor #%00000100           ;otherwise invert d2
088AD 29 04                     SetATHigh:   and #%00000100           ;mask out all other bits
088AF 09 23                                  ora #$23                 ;add $2300 (for attribute table) to the high byte
088B1 85 00                                  sta $00
088B3 A5 01                                  lda $01                  ;get low byte - 4, divide by 4, add offset for
088B5 4A                                     lsr                      ;attribute table and store
088B6 4A                                     lsr
088B7 69 C0                                  adc #$c0                 ;we should now have the appropriate block of
088B9 85 01                                  sta $01                  ;attribute table in our temp address
088BB A2 00                                  ldx #$00
088BD AC 40 03                               ldy VRAM_Buffer2_Offset  ;get buffer offset
088C0 A5 00                     AttribLoop:  lda $00
088C2 99 41 03                               sta VRAM_Buffer2,y       ;store high byte of attribute table address
088C5 A5 01                                  lda $01
088C7 18                                     clc                      ;get low byte, add 8 because we want to start
088C8 69 08                                  adc #$08                 ;below the status bar, and store
088CA 99 42 03                               sta VRAM_Buffer2+1,y
088CD 85 01                                  sta $01                  ;also store in temp again
088CF BD F9 03                               lda AttributeBuffer,x    ;fetch current attribute table byte and store
088D2 99 44 03                               sta VRAM_Buffer2+3,y     ;in the buffer
088D5 A9 01                                  lda #$01
088D7 99 43 03                               sta VRAM_Buffer2+2,y     ;store length of 1 in buffer
088DA 4A                                     lsr
088DB 9D F9 03                               sta AttributeBuffer,x    ;clear current byte in attribute buffer
088DE C8                                     iny                      ;increment buffer offset by 4 bytes
088DF C8                                     iny
088E0 C8                                     iny
088E1 C8                                     iny
088E2 E8                                     inx                      ;increment attribute offset and check to see
088E3 E0 07                                  cpx #$07                 ;if we're at the end yet
088E5 90 D9                                  bcc AttribLoop
088E7 99 41 03                               sta VRAM_Buffer2,y       ;put null terminator at the end
088EA 8C 40 03                               sty VRAM_Buffer2_Offset  ;store offset in case we want to do any more
088ED A9 06                     SetVRAMCtrl: lda #$06
088EF 8D 73 07                               sta VRAM_Buffer_AddrCtrl ;set VRAM address controller to second VRAM buffer
088F2 60                                     rts
088F3                           
088F3                           ;-------------------------------------------------------------------------------------
088F3                           ;$00 - used as temporary counter in ColorRotation
088F3                           
088F3                           ColorRotatePalette:
088F3 27 27 27 17 07 17                .db $27, $27, $27, $17, $07, $17
088F9                           
088F9                           BlankPalette:
088F9 3F 0C 04 FF FF FF FF 00          .db $3f, $0c, $04, $ff, $ff, $ff, $ff, $00
08901                           
08901                           ;used based on area type
08901                           Palette3Data:
08901 0F 07 12 0F                      .db $0f, $07, $12, $0f 
08905 0F 07 17 0F                      .db $0f, $07, $17, $0f
08909 0F 07 17 1C                      .db $0f, $07, $17, $1c
0890D 0F 07 17 00                      .db $0f, $07, $17, $00
08911                           
08911                           ColorRotation:
08911 A5 09                                   lda FrameCounter         ;get frame counter
08913 29 07                                   and #$07                 ;mask out all but three LSB
08915 D0 51                                   bne ExitColorRot         ;branch if not set to zero to do this every eighth frame
08917 AE 00 03                                ldx VRAM_Buffer1_Offset  ;check vram buffer offset
0891A E0 31                                   cpx #$31
0891C B0 4A                                   bcs ExitColorRot         ;if offset over 48 bytes, branch to leave
0891E A8                                      tay                      ;otherwise use frame counter's 3 LSB as offset here
0891F B9 F9 88                  GetBlankPal:  lda BlankPalette,y       ;get blank palette for palette 3
08922 9D 01 03                                sta VRAM_Buffer1,x       ;store it in the vram buffer
08925 E8                                      inx                      ;increment offsets
08926 C8                                      iny
08927 C0 08                                   cpy #$08
08929 90 F4                                   bcc GetBlankPal          ;do this until all bytes are copied
0892B AE 00 03                                ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
0892E A9 03                                   lda #$03
08930 85 00                                   sta $00                  ;set counter here
08932 AD 4E 07                                lda AreaType             ;get area type
08935 0A                                      asl                      ;multiply by 4 to get proper offset
08936 0A                                      asl
08937 A8                                      tay                      ;save as offset here
08938 B9 01 89                  GetAreaPal:   lda Palette3Data,y       ;fetch palette to be written based on area type
0893B 9D 04 03                                sta VRAM_Buffer1+3,x     ;store it to overwrite blank palette in vram buffer
0893E C8                                      iny
0893F E8                                      inx
08940 C6 00                                   dec $00                  ;decrement counter
08942 10 F4                                   bpl GetAreaPal           ;do this until the palette is all copied
08944 AE 00 03                                ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
08947 AC D4 06                                ldy ColorRotateOffset    ;get color cycling offset
0894A B9 F3 88                                lda ColorRotatePalette,y
0894D 9D 05 03                                sta VRAM_Buffer1+4,x     ;get and store current color in second slot of palette
08950 AD 00 03                                lda VRAM_Buffer1_Offset
08953 18                                      clc                      ;add seven bytes to vram buffer offset
08954 69 07                                   adc #$07
08956 8D 00 03                                sta VRAM_Buffer1_Offset
08959 EE D4 06                                inc ColorRotateOffset    ;increment color cycling offset
0895C AD D4 06                                lda ColorRotateOffset
0895F C9 06                                   cmp #$06                 ;check to see if it's still in range
08961 90 05                                   bcc ExitColorRot         ;if so, branch to leave
08963 A9 00                                   lda #$00
08965 8D D4 06                                sta ColorRotateOffset    ;otherwise, init to keep it in range
08968 60                        ExitColorRot: rts                      ;leave
08969                           
08969                           ;-------------------------------------------------------------------------------------
08969                           ;$00 - temp store for offset control bit
08969                           ;$01 - temp vram buffer offset
08969                           ;$02 - temp store for vertical high nybble in block buffer routine
08969                           ;$03 - temp adder for high byte of name table address
08969                           ;$04, $05 - name table address low/high
08969                           ;$06, $07 - block buffer address low/high
08969                           
08969                           BlockGfxData:
08969 45 45 47 47                      .db $45, $45, $47, $47
0896D 47 47 47 47                      .db $47, $47, $47, $47
08971 57 58 59 5A                      .db $57, $58, $59, $5a
08975 24 24 24 24                      .db $24, $24, $24, $24
08979 26 26 26 26                      .db $26, $26, $26, $26
0897D                           
0897D                           RemoveCoin_Axe:
0897D A0 41                                   ldy #$41                 ;set low byte so offset points to second vram buffer
0897F A9 03                                   lda #$03                 ;load offset for default blank metatile
08981 AE 4E 07                                ldx AreaType             ;check area type
08984 D0 02                                   bne WriteBlankMT         ;if not water type, use offset
08986 A9 04                                   lda #$04                 ;otherwise load offset for blank metatile used in water
08988 20 C7 89                  WriteBlankMT: jsr PutBlockMetatile     ;do a sub to write blank metatile to vram buffer
0898B A9 06                                   lda #$06
0898D 8D 73 07                                sta VRAM_Buffer_AddrCtrl ;set vram address controller to second vram buffer and leave
08990 60                                      rts
08991                           
08991                           ReplaceBlockMetatile:
08991 20 9D 89                         jsr WriteBlockMetatile    ;write metatile to vram buffer to replace block object
08994 EE F0 03                         inc Block_ResidualCounter ;increment unused counter (residual code)
08997 DE EC 03                         dec Block_RepFlag,x       ;decrement flag (residual code)
0899A 60                               rts                       ;leave
0899B                           
0899B                           DestroyBlockMetatile:
0899B A9 00                            lda #$00       ;force blank metatile if branched/jumped to this point
0899D                           
0899D                           WriteBlockMetatile:
0899D A0 03                                  ldy #$03                ;load offset for blank metatile
0899F C9 00                                  cmp #$00                ;check contents of A for blank metatile
089A1 F0 14                                  beq UseBOffset          ;branch if found (unconditional if destroying metatile)
089A3 A0 00                                  ldy #$00                ;load offset for brick metatile w/ line
089A5 C9 58                                  cmp #$58 
089A7 F0 0E                                  beq UseBOffset          ;use offset if metatile is brick with coins (w/ line)
089A9 C9 51                                  cmp #$51
089AB F0 0A                                  beq UseBOffset          ;use offset if metatile is breakable brick w/ line
089AD C8                                     iny                     ;increment offset for brick metatile w/o line
089AE C9 5E                                  cmp #$5e
089B0 F0 05                                  beq UseBOffset          ;use offset if metatile is brick with coins (w/o line)
089B2 C9 52                                  cmp #$52
089B4 F0 01                                  beq UseBOffset          ;use offset if metatile is breakable brick w/o line
089B6 C8                                     iny                     ;if any other metatile, increment offset for empty block
089B7 98                        UseBOffset:  tya                     ;put Y in A
089B8 AC 00 03                               ldy VRAM_Buffer1_Offset ;get vram buffer offset
089BB C8                                     iny                     ;move onto next byte
089BC 20 C7 89                               jsr PutBlockMetatile    ;get appropriate block data and write to vram buffer
089BF 88                        MoveVOffset: dey                     ;decrement vram buffer offset
089C0 98                                     tya                     ;add 10 bytes to it
089C1 18                                     clc
089C2 69 0A                                  adc #10
089C4 4C 74 85                               jmp SetVRAMOffset       ;branch to store as new vram buffer offset
089C7                           
089C7                           PutBlockMetatile:
089C7 86 00                                 stx $00               ;store control bit from SprDataOffset_Ctrl
089C9 84 01                                 sty $01               ;store vram buffer offset for next byte
089CB 0A                                    asl
089CC 0A                                    asl                   ;multiply A by four and use as X
089CD AA                                    tax
089CE A0 20                                 ldy #$20              ;load high byte for name table 0
089D0 A5 06                                 lda $06               ;get low byte of block buffer pointer
089D2 C9 D0                                 cmp #$d0              ;check to see if we're on odd-page block buffer
089D4 90 02                                 bcc SaveHAdder        ;if not, use current high byte
089D6 A0 24                                 ldy #$24              ;otherwise load high byte for name table 1
089D8 84 03                     SaveHAdder: sty $03               ;save high byte here
089DA 29 0F                                 and #$0f              ;mask out high nybble of block buffer pointer
089DC 0A                                    asl                   ;multiply by 2 to get appropriate name table low byte
089DD 85 04                                 sta $04               ;and then store it here
089DF A9 00                                 lda #$00
089E1 85 05                                 sta $05               ;initialize temp high byte
089E3 A5 02                                 lda $02               ;get vertical high nybble offset used in block buffer routine
089E5 18                                    clc
089E6 69 20                                 adc #$20              ;add 32 pixels for the status bar
089E8 0A                                    asl
089E9 26 05                                 rol $05               ;shift and rotate d7 onto d0 and d6 into carry
089EB 0A                                    asl
089EC 26 05                                 rol $05               ;shift and rotate d6 onto d0 and d5 into carry
089EE 65 04                                 adc $04               ;add low byte of name table and carry to vertical high nybble
089F0 85 04                                 sta $04               ;and store here
089F2 A5 05                                 lda $05               ;get whatever was in d7 and d6 of vertical high nybble
089F4 69 00                                 adc #$00              ;add carry
089F6 18                                    clc
089F7 65 03                                 adc $03               ;then add high byte of name table
089F9 85 05                                 sta $05               ;store here
089FB A4 01                                 ldy $01               ;get vram buffer offset to be used
089FD BD 69 89                  RemBridge:  lda BlockGfxData,x    ;write top left and top right
08A00 99 03 03                              sta VRAM_Buffer1+2,y  ;tile numbers into first spot
08A03 BD 6A 89                              lda BlockGfxData+1,x
08A06 99 04 03                              sta VRAM_Buffer1+3,y
08A09 BD 6B 89                              lda BlockGfxData+2,x  ;write bottom left and bottom
08A0C 99 08 03                              sta VRAM_Buffer1+7,y  ;right tiles numbers into
08A0F BD 6C 89                              lda BlockGfxData+3,x  ;second spot
08A12 99 09 03                              sta VRAM_Buffer1+8,y
08A15 A5 04                                 lda $04
08A17 99 01 03                              sta VRAM_Buffer1,y    ;write low byte of name table
08A1A 18                                    clc                   ;into first slot as read
08A1B 69 20                                 adc #$20              ;add 32 bytes to value
08A1D 99 06 03                              sta VRAM_Buffer1+5,y  ;write low byte of name table
08A20 A5 05                                 lda $05               ;plus 32 bytes into second slot
08A22 99 00 03                              sta VRAM_Buffer1-1,y  ;write high byte of name
08A25 99 05 03                              sta VRAM_Buffer1+4,y  ;table address to both slots
08A28 A9 02                                 lda #$02
08A2A 99 02 03                              sta VRAM_Buffer1+1,y  ;put length of 2 in
08A2D 99 07 03                              sta VRAM_Buffer1+6,y  ;both slots
08A30 A9 00                                 lda #$00
08A32 99 0A 03                              sta VRAM_Buffer1+9,y  ;put null terminator at end
08A35 A6 00                                 ldx $00               ;get offset control bit here
08A37 60                                    rts                   ;and leave
08A38                           
08A38                           ;-------------------------------------------------------------------------------------
08A38                           ;METATILE GRAPHICS TABLE
08A38                           
08A38                           MetatileGraphics_Low:
08A38 40 DC A4 D8                 .db <Palette0_MTiles, <Palette1_MTiles, <Palette2_MTiles, <Palette3_MTiles
08A3C                           
08A3C                           MetatileGraphics_High:
08A3C 8A 8A 8B 8B                 .db >Palette0_MTiles, >Palette1_MTiles, >Palette2_MTiles, >Palette3_MTiles
08A40                           
08A40                           Palette0_MTiles:
08A40 24 24 24 24                 .db $24, $24, $24, $24 ;blank
08A44 27 27 27 27                 .db $27, $27, $27, $27 ;black metatile
08A48 24 24 24 35                 .db $24, $24, $24, $35 ;bush left
08A4C 36 25 37 25                 .db $36, $25, $37, $25 ;bush middle
08A50 24 38 24 24                 .db $24, $38, $24, $24 ;bush right
08A54 24 30 30 26                 .db $24, $30, $30, $26 ;mountain left
08A58 26 26 34 26                 .db $26, $26, $34, $26 ;mountain left bottom/middle center
08A5C 24 31 24 32                 .db $24, $31, $24, $32 ;mountain middle top
08A60 33 26 24 33                 .db $33, $26, $24, $33 ;mountain right
08A64 34 26 26 26                 .db $34, $26, $26, $26 ;mountain right bottom
08A68 26 26 26 26                 .db $26, $26, $26, $26 ;mountain middle bottom
08A6C 24 C0 24 C0                 .db $24, $c0, $24, $c0 ;bridge guardrail
08A70 24 7F 7F 24                 .db $24, $7f, $7f, $24 ;chain
08A74 B8 BA B9 BB                 .db $b8, $ba, $b9, $bb ;tall tree top, top half
08A78 B8 BC B9 BD                 .db $b8, $bc, $b9, $bd ;short tree top
08A7C BA BC BB BD                 .db $ba, $bc, $bb, $bd ;tall tree top, bottom half
08A80 60 64 61 65                 .db $60, $64, $61, $65 ;warp pipe end left, points up
08A84 62 66 63 67                 .db $62, $66, $63, $67 ;warp pipe end right, points up
08A88 60 64 61 65                 .db $60, $64, $61, $65 ;decoration pipe end left, points up
08A8C 62 66 63 67                 .db $62, $66, $63, $67 ;decoration pipe end right, points up
08A90 68 68 69 69                 .db $68, $68, $69, $69 ;pipe shaft left
08A94 26 26 6A 6A                 .db $26, $26, $6a, $6a ;pipe shaft right
08A98 4B 4C 4D 4E                 .db $4b, $4c, $4d, $4e ;tree ledge left edge
08A9C 4D 4F 4D 4F                 .db $4d, $4f, $4d, $4f ;tree ledge middle
08AA0 4D 4E 50 51                 .db $4d, $4e, $50, $51 ;tree ledge right edge
08AA4 F5 FA F3 F4                 .db $f5, $fa, $f3, $f4 ;mushroom left edge
08AA8 F6 FB F7 FC                 .db $f6, $fb, $f7, $fc ;mushroom middle
08AAC F8 FD F9 FE                 .db $f8, $fd, $f9, $fe ;mushroom right edge
08AB0 86 8A 87 8B                 .db $86, $8a, $87, $8b ;sideways pipe end top
08AB4 88 8C 88 8C                 .db $88, $8c, $88, $8c ;sideways pipe shaft top
08AB8 89 8D 69 69                 .db $89, $8d, $69, $69 ;sideways pipe joint top
08ABC 8E 91 8F 92                 .db $8e, $91, $8f, $92 ;sideways pipe end bottom
08AC0 26 93 26 93                 .db $26, $93, $26, $93 ;sideways pipe shaft bottom
08AC4 90 94 69 69                 .db $90, $94, $69, $69 ;sideways pipe joint bottom
08AC8 A4 E9 EA EB                 .db $a4, $e9, $ea, $eb ;seaplant
08ACC 24 24 24 24                 .db $24, $24, $24, $24 ;blank, used on bricks or blocks that are hit
08AD0 24 2F 24 3D                 .db $24, $2f, $24, $3d ;flagpole ball
08AD4 A2 A2 A3 A3                 .db $a2, $a2, $a3, $a3 ;flagpole shaft
08AD8 24 24 24 24                 .db $24, $24, $24, $24 ;blank, used in conjunction with vines
08ADC                           
08ADC                           Palette1_MTiles:
08ADC A2 A2 A3 A3                 .db $a2, $a2, $a3, $a3 ;vertical rope
08AE0 99 24 99 24                 .db $99, $24, $99, $24 ;horizontal rope
08AE4 24 A2 3E 3F                 .db $24, $a2, $3e, $3f ;left pulley
08AE8 5B 5C 24 A3                 .db $5b, $5c, $24, $a3 ;right pulley
08AEC 24 24 24 24                 .db $24, $24, $24, $24 ;blank used for balance rope
08AF0 9D 47 9E 47                 .db $9d, $47, $9e, $47 ;castle top
08AF4 47 47 27 27                 .db $47, $47, $27, $27 ;castle window left
08AF8 47 47 47 47                 .db $47, $47, $47, $47 ;castle brick wall
08AFC 27 27 47 47                 .db $27, $27, $47, $47 ;castle window right
08B00 A9 47 AA 47                 .db $a9, $47, $aa, $47 ;castle top w/ brick
08B04 9B 27 9C 27                 .db $9b, $27, $9c, $27 ;entrance top
08B08 27 27 27 27                 .db $27, $27, $27, $27 ;entrance bottom
08B0C 52 52 52 52                 .db $52, $52, $52, $52 ;green ledge stump
08B10 80 A0 81 A1                 .db $80, $a0, $81, $a1 ;fence
08B14 BE BE BF BF                 .db $be, $be, $bf, $bf ;tree trunk
08B18 75 BA 76 BB                 .db $75, $ba, $76, $bb ;mushroom stump top
08B1C BA BA BB BB                 .db $ba, $ba, $bb, $bb ;mushroom stump bottom
08B20 45 47 45 47                 .db $45, $47, $45, $47 ;breakable brick w/ line 
08B24 47 47 47 47                 .db $47, $47, $47, $47 ;breakable brick 
08B28 45 47 45 47                 .db $45, $47, $45, $47 ;breakable brick (not used)
08B2C 45 47 45 47                 .db $45, $47, $45, $47 ;brick with line (power-up)
08B30 45 47 45 47                 .db $45, $47, $45, $47 ;brick with line (poison shroom)
08B34 45 47 45 47                 .db $45, $47, $45, $47 ;brick with line (vine)
08B38 45 47 45 47                 .db $45, $47, $45, $47 ;brick with line (star)
08B3C 45 47 45 47                 .db $45, $47, $45, $47 ;brick with line (coins)
08B40 45 47 45 47                 .db $45, $47, $45, $47 ;brick with line (1-up)
08B44 47 47 47 47                 .db $47, $47, $47, $47 ;brick (power-up)
08B48 47 47 47 47                 .db $47, $47, $47, $47 ;brick (poison shroom)
08B4C 47 47 47 47                 .db $47, $47, $47, $47 ;brick (vine)
08B50 47 47 47 47                 .db $47, $47, $47, $47 ;brick (star)
08B54 47 47 47 47                 .db $47, $47, $47, $47 ;brick (coins)
08B58 47 47 47 47                 .db $47, $47, $47, $47 ;brick (1-up)
08B5C 24 24 24 24                 .db $24, $24, $24, $24 ;hidden block (1 coin)
08B60 24 24 24 24                 .db $24, $24, $24, $24 ;hidden block (1-up)
08B64 24 24 24 24                 .db $24, $24, $24, $24 ;hidden block (poison shroom)
08B68 24 24 24 24                 .db $24, $24, $24, $24 ;hidden block (power-up)
08B6C AB AC AD AE                 .db $ab, $ac, $ad, $ae ;solid block (3-d block)
08B70 5D 5E 5D 5E                 .db $5d, $5e, $5d, $5e ;solid block (white wall)
08B74 C1 24 C1 24                 .db $c1, $24, $c1, $24 ;bridge
08B78 C6 C8 C7 C9                 .db $c6, $c8, $c7, $c9 ;bullet bill cannon barrel
08B7C CA CC CB CD                 .db $ca, $cc, $cb, $cd ;bullet bill cannon top
08B80 2A 2A 40 40                 .db $2a, $2a, $40, $40 ;bullet bill cannon bottom
08B84 24 24 24 24                 .db $24, $24, $24, $24 ;blank used for jumpspring
08B88 24 47 24 47                 .db $24, $47, $24, $47 ;half brick used for jumpspring
08B8C 82 83 84 85                 .db $82, $83, $84, $85 ;solid block (water level, green rock)
08B90 B4 B6 B5 B7                 .db $b4, $b6, $b5, $b7 ;cracked rock terrain
08B94 24 47 24 47                 .db $24, $47, $24, $47 ;half brick (not used)
08B98 86 8A 87 8B                 .db $86, $8a, $87, $8b ;water pipe top
08B9C 8E 91 8F 92                 .db $8e, $91, $8f, $92 ;water pipe bottom
08BA0 24 2F 24 3D                 .db $24, $2f, $24, $3d ;flag ball (residual object)
08BA4                           
08BA4                           Palette2_MTiles:
08BA4 24 24 24 35                 .db $24, $24, $24, $35 ;cloud left
08BA8 36 25 37 25                 .db $36, $25, $37, $25 ;cloud middle
08BAC 24 38 24 24                 .db $24, $38, $24, $24 ;cloud right
08BB0 24 24 39 24                 .db $24, $24, $39, $24 ;cloud bottom left
08BB4 3A 24 3B 24                 .db $3a, $24, $3b, $24 ;cloud bottom middle
08BB8 3C 24 24 24                 .db $3c, $24, $24, $24 ;cloud bottom right
08BBC 41 26 41 26                 .db $41, $26, $41, $26 ;water/lava top
08BC0 26 26 26 26                 .db $26, $26, $26, $26 ;water/lava
08BC4 B0 B1 B2 B3                 .db $b0, $b1, $b2, $b3 ;cloud level terrain
08BC8 77 79 77 79                 .db $77, $79, $77, $79 ;bowser's bridge
08BCC 6B 70 2C 2D                 .db $6b, $70, $2c, $2d ;cloud ledge left edge
08BD0 6C 71 6D 72                 .db $6c, $71, $6d, $72 ;cloud ledge middle
08BD4 6E 73 6F 74                 .db $6e, $73, $6f, $74 ;cloud ledge right edge
08BD8                           
08BD8                           Palette3_MTiles:
08BD8 53 55 54 56                 .db $53, $55, $54, $56 ;question block (coin)
08BDC 53 55 54 56                 .db $53, $55, $54, $56 ;question block (power-up)
08BE0 53 55 54 56                 .db $53, $55, $54, $56 ;question block (poison shroom)
08BE4 A5 A7 A6 A8                 .db $a5, $a7, $a6, $a8 ;coin
08BE8 C2 C4 C3 C5                 .db $c2, $c4, $c3, $c5 ;underwater coin
08BEC 57 59 58 5A                 .db $57, $59, $58, $5a ;empty block
08BF0 7B 7D 7C 7E                 .db $7b, $7d, $7c, $7e ;axe
08BF4                           
08BF4                           ;------------------------------------------------------------------------------------
08BF4                           
08BF4                           WaterPaletteData:
08BF4 3F 00 20                    .db $3f, $00, $20
08BF7 0F 15 12 25                 .db $0f, $15, $12, $25  
08BFB 0F 3A 1A 0F                 .db $0f, $3a, $1a, $0f
08BFF 0F 30 12 0F                 .db $0f, $30, $12, $0f
08C03 0F 27 12 0F                 .db $0f, $27, $12, $0f
08C07 22 16 27 18                 .db $22, $16, $27, $18
08C0B 0F 10 30 27                 .db $0f, $10, $30, $27
08C0F 0F 16 30 27                 .db $0f, $16, $30, $27
08C13 0F 0F 30 10                 .db $0f, $0f, $30, $10
08C17 00                          .db $00
08C18                           
08C18                           GroundPaletteData:
08C18 3F 00 20                    .db $3f, $00, $20
08C1B 0F 29 1A 0F                 .db $0f, $29, $1a, $0f
08C1F 0F 36 17 0F                 .db $0f, $36, $17, $0f
08C23 0F 30 21 0F                 .db $0f, $30, $21, $0f
08C27 0F 27 17 0F                 .db $0f, $27, $17, $0f
08C2B 0F 16 27 18                 .db $0f, $16, $27, $18
08C2F 0F 1A 30 27                 .db $0f, $1a, $30, $27
08C33 0F 16 30 27                 .db $0f, $16, $30, $27
08C37 0F 0F 36 17                 .db $0f, $0f, $36, $17
08C3B 00                          .db $00
08C3C                           
08C3C                           UndergroundPaletteData:
08C3C 3F 00 20                    .db $3f, $00, $20
08C3F 0F 29 1A 09                 .db $0f, $29, $1a, $09
08C43 0F 3C 1C 0F                 .db $0f, $3c, $1c, $0f
08C47 0F 30 21 1C                 .db $0f, $30, $21, $1c
08C4B 0F 27 17 1C                 .db $0f, $27, $17, $1c
08C4F 0F 16 27 18                 .db $0f, $16, $27, $18
08C53 0F 1C 36 17                 .db $0f, $1c, $36, $17
08C57 0F 16 30 27                 .db $0f, $16, $30, $27
08C5B 0F 0C 3C 1C                 .db $0f, $0c, $3c, $1c
08C5F 00                          .db $00
08C60                           
08C60                           CastlePaletteData:
08C60 3F 00 20                    .db $3f, $00, $20
08C63 0F 30 10 00                 .db $0f, $30, $10, $00
08C67 0F 30 10 00                 .db $0f, $30, $10, $00
08C6B 0F 30 16 00                 .db $0f, $30, $16, $00
08C6F 0F 27 17 00                 .db $0f, $27, $17, $00
08C73 0F 16 27 18                 .db $0f, $16, $27, $18
08C77 0F 1C 36 17                 .db $0f, $1c, $36, $17
08C7B 0F 16 30 27                 .db $0f, $16, $30, $27
08C7F 0F 00 30 10                 .db $0f, $00, $30, $10
08C83 00                          .db $00
08C84                           
08C84                           DaySnowPaletteData:
08C84 3F 00 04                    .db $3f, $00, $04
08C87 22 30 00 10                 .db $22, $30, $00, $10
08C8B 00                          .db $00
08C8C                           
08C8C                           NightSnowPaletteData:
08C8C 3F 00 04                    .db $3f, $00, $04
08C8F 0F 30 00 10                 .db $0f, $30, $00, $10
08C93 00                          .db $00
08C94                           
08C94                           MushroomPaletteData:
08C94 3F 00 04                    .db $3f, $00, $04
08C97 22 27 16 0F                 .db $22, $27, $16, $0f
08C9B 00                          .db $00
08C9C                           
08C9C                           BowserPaletteData:
08C9C 3F 14 04                    .db $3f, $14, $04
08C9F 0F 1A 30 27                 .db $0f, $1a, $30, $27
08CA3 00                          .db $00
08CA4                           
08CA4                           MarioThankYouMsg:
08CA4 25 48 10                    .db $25, $48, $10
08CA7 1D 11 0A 17 14 24 22 18     .db $1d, $11, $0a, $17, $14, $24, $22, $18
08CAF 1E 24 16 0A 1B 12 18 2B     .db $1e, $24, $16, $0a, $1b, $12, $18, $2b
08CB7 00                          .db $00
08CB8                           
08CB8                           LuigiThankYouMsg:
08CB8 25 48 10                    .db $25, $48, $10
08CBB 1D 11 0A 17 14 24 22 18     .db $1d, $11, $0a, $17, $14, $24, $22, $18
08CC3 1E 24 15 1E 12 10 12 2B     .db $1e, $24, $15, $1e, $12, $10, $12, $2b
08CCB 00                          .db $00
08CCC                           
08CCC                           MushroomRetainerMsg:
08CCC 25 C5 16                    .db $25, $c5, $16
08CCF 0B 1E 1D 24 18 1E 1B 24     .db $0b, $1e, $1d, $24, $18, $1e, $1b, $24
08CD7 19 1B 12 17 0C 0E 1C 1C     .db $19, $1b, $12, $17, $0c, $0e, $1c, $1c
08CDF 24 12 1C 24 12 17           .db $24, $12, $1c, $24, $12, $17
08CE5 26 05 0F                    .db $26, $05, $0f
08CE8 0A 17 18 1D 11 0E 1B 24     .db $0a, $17, $18, $1d, $11, $0e, $1b, $24
08CF0 0C 0A 1C 1D 15 0E 2B        .db $0c, $0a, $1c, $1d, $15, $0e, $2b
08CF7 00                          .db $00
08CF8                           
08CF8                           ;------------------------------------------------------------------------------------
08CF8                           
08CF8                           JumpEngine:
08CF8 0A                               asl          ;shift bit from contents of A
08CF9 A8                               tay
08CFA 68                               pla          ;pull saved return address from stack
08CFB 85 04                            sta $04      ;save to indirect
08CFD 68                               pla
08CFE 85 05                            sta $05
08D00 C8                               iny
08D01 B1 04                            lda ($04),y  ;load pointer from indirect
08D03 85 06                            sta $06      ;note that if an RTS is performed in next routine
08D05 C8                               iny          ;it will return to the execution before the sub
08D06 B1 04                            lda ($04),y  ;that called this routine
08D08 85 07                            sta $07
08D0A 6C 06 00                         jmp ($0006)  ;jump to the address we loaded
08D0D                           
08D0D                           ;------------------------------------------------------------------------------------
08D0D                           
08D0D                           InitializeNameTables:
08D0D AD 02 20                                lda PPU_STATUS            ;reset flip-flop
08D10 AD 78 07                                lda Mirror_PPU_CTRL       ;load mirror of first ppu control reg
08D13 09 08                                   ora #%00001000            ;set background for first 4k and sprites for second 4k
08D15 29 E8                                   and #%11101000            ;clear rest of lower nybble, leave higher alone
08D17 20 E1 8D                                jsr WritePPUReg1
08D1A A9 24                                   lda #$24                  ;set vram address to start of name table 1
08D1C 20 21 8D                                jsr WriteNTAddr
08D1F A9 20                                   lda #$20                  ;and then set it to name table 0
08D21 8D 06 20                  WriteNTAddr:  sta PPU_ADDRESS
08D24 A9 00                                   lda #$00
08D26 8D 06 20                                sta PPU_ADDRESS
08D29 A2 04                                   ldx #$04                  ;clear name table with blank tile $24
08D2B A0 C0                                   ldy #$c0
08D2D A9 24                                   lda #$24
08D2F 8D 07 20                  InitNTLoop:   sta PPU_DATA              ;count out exactly 768 tiles
08D32 88                                      dey
08D33 D0 FA                                   bne InitNTLoop
08D35 CA                                      dex
08D36 D0 F7                                   bne InitNTLoop
08D38 A0 40                                   ldy #64                   ;now to clear the attribute table (with zero this time)
08D3A 8A                                      txa
08D3B 8D 00 03                                sta VRAM_Buffer1_Offset   ;init vram buffer 1 offset
08D3E 8D 01 03                                sta VRAM_Buffer1          ;init vram buffer 1
08D41 8D 07 20                  InitATLoop:   sta PPU_DATA
08D44 88                                      dey
08D45 D0 FA                                   bne InitATLoop
08D47 8D 3F 07                                sta HorizontalScroll      ;reset scroll variables
08D4A 8D 40 07                                sta VerticalScroll
08D4D 4C DA 8D                                jmp InitScroll            ;initialize scroll registers to zero
08D50                           
08D50                           ;------------------------------------------------------------------------------------
08D50                           
08D50                           ReadJoypads: 
08D50 A9 01                                   lda #$01               ;reset and clear strobe of joypad ports
08D52 8D 16 40                                sta JOYPAD_PORT
08D55 4A                                      lsr
08D56 AA                                      tax                    ;start with joypad 1's port
08D57 8D 16 40                                sta JOYPAD_PORT
08D5A 20 5E 8D                                jsr ReadPortBits
08D5D E8                                      inx                    ;increment for joypad 2's port
08D5E A0 08                     ReadPortBits: ldy #$08
08D60 48                        PortLoop:     pha                    ;push previous bit onto stack
08D61 BD 16 40                                lda JOYPAD_PORT,x      ;read current bit on joypad port
08D64 85 00                                   sta $00                ;check d1 and d0 of port output
08D66 4A                                      lsr                    ;this is necessary on the old
08D67 05 00                                   ora $00                ;famicom systems in japan
08D69 4A                                      lsr
08D6A 68                                      pla                    ;read bits from stack
08D6B 2A                                      rol                    ;rotate bit from carry flag
08D6C 88                                      dey
08D6D D0 F1                                   bne PortLoop           ;count down bits left
08D6F 9D FC 06                                sta SavedJoypadBits,x  ;save controller status here always
08D72 48                                      pha
08D73 29 30                                   and #%00110000         ;check for select or start
08D75 3D 4A 07                                and JoypadBitMask,x    ;if neither saved state nor current state
08D78 F0 07                                   beq Save8Bits          ;have any of these two set, branch
08D7A 68                                      pla
08D7B 29 CF                                   and #%11001111         ;otherwise store without select
08D7D 9D FC 06                                sta SavedJoypadBits,x  ;or start bits and leave
08D80 60                                      rts
08D81 68                        Save8Bits:    pla
08D82 9D 4A 07                                sta JoypadBitMask,x    ;save with all bits in another place and leave
08D85 60                                      rts
08D86                           
08D86                           ;------------------------------------------------------------------------------------
08D86                           
08D86                           WriteBufferToScreen:
08D86 8D 06 20                                 sta PPU_ADDRESS           ;store high byte of vram address
08D89 C8                                       iny
08D8A B1 00                                    lda ($00),y               ;load next byte (second)
08D8C 8D 06 20                                 sta PPU_ADDRESS           ;store low byte of vram address
08D8F C8                                       iny
08D90 B1 00                                    lda ($00),y               ;load next byte (third)
08D92 0A                                       asl                       ;shift to left and save in stack
08D93 48                                       pha
08D94 AD 78 07                                 lda Mirror_PPU_CTRL
08D97 09 04                                    ora #%00000100            ;set ppu to increment by 32 by default
08D99 B0 02                                    bcs SetupWrites           ;if d7 of third byte was clear, ppu will
08D9B 29 FB                                    and #%11111011            ;only increment by 1
08D9D 20 E1 8D                  SetupWrites:   jsr WritePPUReg1          ;write to register
08DA0 68                                       pla                       ;pull from stack and shift to left again
08DA1 0A                                       asl
08DA2 90 03                                    bcc GetLength             ;if d6 of third byte was clear, do not repeat byte
08DA4 09 02                                    ora #%00000010            ;otherwise set d1 and increment Y
08DA6 C8                                       iny
08DA7 4A                        GetLength:     lsr                       ;shift back to the right to get proper length
08DA8 4A                                       lsr                       ;note that d1 will now be in carry
08DA9 AA                                       tax
08DAA B0 01                     OutputToVRAM:  bcs RepeatByte            ;if carry set, repeat loading the same byte
08DAC C8                                       iny                       ;otherwise increment Y to load next byte
08DAD B1 00                     RepeatByte:    lda ($00),y               ;load more data from buffer and write to vram
08DAF 8D 07 20                                 sta PPU_DATA
08DB2 CA                                       dex                       ;done writing?
08DB3 D0 F5                                    bne OutputToVRAM
08DB5 38                                       sec          
08DB6 98                                       tya
08DB7 65 00                                    adc $00                   ;add end length plus one to the indirect at $00
08DB9 85 00                                    sta $00                   ;to allow this routine to read another set of updates
08DBB A9 00                                    lda #$00
08DBD 65 01                                    adc $01
08DBF 85 01                                    sta $01
08DC1 A9 3F                                    lda #$3f                  ;sets vram address to palette memory
08DC3 8D 06 20                                 sta PPU_ADDRESS
08DC6 A9 00                                    lda #$00
08DC8 8D 06 20                                 sta PPU_ADDRESS
08DCB 8D 06 20                                 sta PPU_ADDRESS           ;then reinitializes it for some reason
08DCE 8D 06 20                                 sta PPU_ADDRESS
08DD1 AE 02 20                  UpdateScreen:  ldx PPU_STATUS            ;reset flip-flop
08DD4 A0 00                                    ldy #$00                  ;load first byte from indirect as a pointer
08DD6 B1 00                                    lda ($00),y  
08DD8 D0 AC                                    bne WriteBufferToScreen   ;if byte is zero we have no further updates to make here
08DDA 8D 05 20                  InitScroll:    sta PPU_SCROLL            ;store contents of A into scroll registers
08DDD 8D 05 20                                 sta PPU_SCROLL            ;and end whatever subroutine led us here
08DE0 60                                       rts
08DE1                           
08DE1                           ;------------------------------------------------------------------------------------
08DE1                           
08DE1                           WritePPUReg1:
08DE1 8D 00 20                                sta PPU_CTRL              ;write contents of A to PPU register 1
08DE4 8D 78 07                                sta Mirror_PPU_CTRL       ;and its mirror
08DE7 60                                      rts
08DE8                           
08DE8                           ;------------------------------------------------------------------------------------
08DE8                           ;$00 - used to store status bar nybbles
08DE8                           ;$02 - used as temp vram offset
08DE8                           ;$03 - used to store length of status bar number
08DE8                           
08DE8                           ;status bar name table offset and length data
08DE8                           StatusBarData:
08DE8 EF 06                           .db $ef, $06 ; top score display on title screen
08DEA 62 06                           .db $62, $06 ; player score
08DEC 6D 02                           .db $6d, $02 ; coin tally
08DEE 7A 03                           .db $7a, $03 ; game timer
08DF0                           
08DF0                           StatusBarOffset:
08DF0 06 0C 12 18                     .db $06, $0c, $12, $18
08DF4                           
08DF4                           PrintStatusBarNumbers:
08DF4 85 00                           sta $00            ;store player-specific offset
08DF6 20 FF 8D                        jsr OutputNumbers  ;use first nybble to print the coin display
08DF9 A5 00                           lda $00            ;move high nybble to low
08DFB 4A                              lsr                ;and print the score display
08DFC 4A                              lsr
08DFD 4A                              lsr
08DFE 4A                              lsr
08DFF                           
08DFF                           OutputNumbers:
08DFF 18                                     clc                      ;add 1 to low nybble
08E00 69 01                                  adc #$01
08E02 29 0F                                  and #%00001111           ;mask out high nybble
08E04 C9 06                                  cmp #$06
08E06 B0 44                                  bcs ExitOutputN
08E08 48                                     pha                      ;save incremented value to stack for now and
08E09 0A                                     asl                      ;multiply by 2 to use as offset
08E0A A8                                     tay
08E0B AE 00 03                               ldx VRAM_Buffer1_Offset  ;get current buffer pointer
08E0E A9 20                                  lda #$20                 ;put at top of screen by default
08E10 C0 00                                  cpy #$00                 ;are we writing top score on title screen?
08E12 D0 02                                  bne SetupNums
08E14 A9 22                                  lda #$22                 ;if so, put further down on the screen
08E16 9D 01 03                  SetupNums:   sta VRAM_Buffer1,x
08E19 B9 E8 8D                               lda StatusBarData,y      ;write vram address low and length of thing
08E1C 9D 02 03                               sta VRAM_Buffer1+1,x     ;we're printing to the buffer
08E1F B9 E9 8D                               lda StatusBarData+1,y
08E22 9D 03 03                               sta VRAM_Buffer1+2,x
08E25 85 03                                  sta $03                  ;save length byte in counter
08E27 86 02                                  stx $02                  ;and buffer pointer elsewhere for now
08E29 68                                     pla                      ;pull original incremented value from stack
08E2A AA                                     tax
08E2B BD F0 8D                               lda StatusBarOffset,x    ;load offset to value we want to write
08E2E 38                                     sec
08E2F F9 E9 8D                               sbc StatusBarData+1,y    ;subtract from length byte we read before
08E32 A8                                     tay                      ;use value as offset to display digits
08E33 A6 02                                  ldx $02
08E35 B9 D7 07                  DigitPLoop:  lda DisplayDigits,y      ;write digits to the buffer
08E38 9D 04 03                               sta VRAM_Buffer1+3,x    
08E3B E8                                     inx
08E3C C8                                     iny
08E3D C6 03                                  dec $03                  ;do this until all the digits are written
08E3F D0 F4                                  bne DigitPLoop
08E41 A9 00                                  lda #$00                 ;put null terminator at end
08E43 9D 04 03                               sta VRAM_Buffer1+3,x
08E46 E8                                     inx                      ;increment buffer pointer by 3
08E47 E8                                     inx
08E48 E8                                     inx
08E49 8E 00 03                               stx VRAM_Buffer1_Offset  ;store it in case we want to use it again
08E4C 60                        ExitOutputN: rts
08E4D                           
08E4D                           DigitsMathRoutine:
08E4D AD 70 07                              lda OperMode              ;check mode of operation
08E50 F0 16                                 beq EraseDMods            ;if in attract mode, branch to lock score
08E52 A2 05                                 ldx #$05
08E54 BD 34 01                  AddModLoop: lda DigitModifier,x       ;load digit amount to increment
08E57 18                                    clc
08E58 79 D7 07                              adc DisplayDigits,y       ;add to current digit
08E5B 30 16                                 bmi BorrowOne             ;if result is a negative number, branch to subtract
08E5D C9 0A                                 cmp #10
08E5F B0 19                                 bcs CarryOne              ;if digit greater than $09, branch to add
08E61 99 D7 07                  StoreNewD:  sta DisplayDigits,y       ;store as new score or game timer digit
08E64 88                                    dey                       ;move onto next digits in score or game timer
08E65 CA                                    dex                       ;and digit amounts to increment
08E66 10 EC                                 bpl AddModLoop            ;loop back if we're not done yet
08E68 A9 00                     EraseDMods: lda #$00                  ;now we need to erase the digit modifiers
08E6A A2 06                                 ldx #$06                  ;start with the last digit
08E6C 9D 33 01                  EraseMLoop: sta DigitModifier-1,x     ;initialize the digit amounts to increment
08E6F CA                                    dex
08E70 10 FA                                 bpl EraseMLoop            ;do this until they're all reset, then leave
08E72 60                                    rts
08E73                           
08E73 DE 33 01                  BorrowOne:  dec DigitModifier-1,x     ;decrement the previous digit, then put $09 in
08E76 A9 09                                 lda #$09                  ;the game timer digit we're currently on to "borrow
08E78 D0 E7                                 bne StoreNewD             ;the one", then do an unconditional branch back
08E7A 38                        CarryOne:   sec                       ;subtract ten from our digit to make it a
08E7B E9 0A                                 sbc #10                   ;proper BCD number, then increment the digit
08E7D FE 33 01                              inc DigitModifier-1,x     ;preceding current digit to "carry the one" properly
08E80 4C 61 8E                              jmp StoreNewD             ;go back to just after we branched here
08E83                           
08E83                           UpdateTopScore:
08E83 A2 05                                   ldx #$05                 ;start with the lowest digit
08E85 A0 05                                   ldy #$05
08E87 38                                      sec           
08E88 BD DD 07                  GetScoreDiff: lda PlayerScoreDisplay,x ;subtract the regular score digit from each high score digit
08E8B F9 D7 07                                sbc TopScoreDisplay,y    ;from lowest to highest, if any top score digit exceeds
08E8E CA                                      dex                      ;the player score digit, borrow will be set until a subsequent
08E8F 88                                      dey                      ;subtraction clears it (player digit is higher than top)
08E90 10 F6                                   bpl GetScoreDiff      
08E92 90 0E                                   bcc NoTopSc              ;check to see if borrow is still set, if so, no new high score
08E94 E8                                      inx                      ;increment X and Y once to the start of the score
08E95 C8                                      iny
08E96 BD DD 07                  CopyScore:    lda PlayerScoreDisplay,x ;store player's score digits into high score memory area
08E99 99 D7 07                                sta TopScoreDisplay,y
08E9C E8                                      inx
08E9D C8                                      iny
08E9E C0 06                                   cpy #$06                 ;do this until we have stored them all
08EA0 90 F4                                   bcc CopyScore
08EA2 60                        NoTopSc:      rts
08EA3                           
08EA3                           ;-------------------------------------------------------------------------------------
08EA3                           
08EA3                           DefaultSprOffsets:
08EA3 04 30 48 60 78 90 A8 C0         .db $04, $30, $48, $60, $78, $90, $a8, $c0
08EAB D8 E8 24 F8 FC 28 2C            .db $d8, $e8, $24, $f8, $fc, $28, $2c
08EB2                           
08EB2                           ;-------------------------------------------------------------------------------------
08EB2                           
08EB2                           InitializeArea:
08EB2 A0 4B                                    ldy #$4b                 ;clear all memory again, only as far as $074b
08EB4 20 92 8F                                 jsr InitializeMemory     ;this is only necessary in game mode
08EB7 A2 21                                    ldx #$21
08EB9 A9 00                                    lda #$00
08EBB 9D 80 07                  ClrTimersLoop: sta Timers,x             ;clear out timer memory
08EBE CA                                       dex
08EBF 10 FA                                    bpl ClrTimersLoop
08EC1 AD 5B 07                                 lda HalfwayPage
08EC4 AC 52 07                                 ldy AltEntranceControl   ;if AltEntranceControl not set, use halfway page, if any found
08EC7 F0 03                                    beq StartPage
08EC9 AD 51 07                                 lda EntrancePage         ;otherwise use saved entry page number here
08ECC 8D 1A 07                  StartPage:     sta ScreenLeft_PageLoc   ;set as value here
08ECF 8D 25 07                                 sta CurrentPageLoc       ;also set as current page
08ED2 8D 28 07                                 sta BackloadingFlag      ;set flag here if halfway page or saved entry page number found
08ED5 20 A3 9C                                 jsr GetScreenPosition    ;get pixel coordinates for screen borders
08ED8 A0 20                                    ldy #$20                 ;if on odd numbered page, use $2480 as start of rendering
08EDA 29 01                                    and #%00000001           ;otherwise use $2080, this address used later as name table
08EDC F0 02                                    beq SetInitNTHigh        ;address for rendering of game area
08EDE A0 24                                    ldy #$24
08EE0 8C 20 07                  SetInitNTHigh: sty CurrentNTAddr_High   ;store name table address
08EE3 A0 80                                    ldy #$80
08EE5 8C 21 07                                 sty CurrentNTAddr_Low
08EE8 0A                                       asl                      ;store LSB of page number in high nybble
08EE9 0A                                       asl                      ;of block buffer column position
08EEA 0A                                       asl
08EEB 0A                                       asl
08EEC 8D A0 06                                 sta BlockBufferColumnPos
08EEF CE 30 07                                 dec AreaObjectLength     ;set area object lengths for all empty
08EF2 CE 31 07                                 dec AreaObjectLength+1
08EF5 CE 32 07                                 dec AreaObjectLength+2
08EF8 A9 0B                                    lda #$0b                 ;set value for renderer to update 12 column sets
08EFA 8D 1E 07                                 sta ColumnSets           ;12 column sets = 24 metatile columns = 1 1/2 screens
08EFD 20 BF FE                                 jsr RunGetAreaDataAddrs  ;get enemy and level addresses and load header
08F00 AC 6A 07                                 ldy PrimaryHardMode      ;primary hard mode set?
08F03 D0 24                                    bne SetSecHard           ;yes, set secondary hard mode as well
08F05 AD 5F 07                                 lda WorldNumber          ;check world number
08F08 AC FB 07                                 ldy HardWorldFlag        ;check to see if we're playing 2J levels
08F0B D0 0F                                    bne ChkSecHard           ;if so, activate the secondary only past 4-4
08F0D C9 04                                    cmp #World5              ;if less than 5, do not activate secondary
08F0F 90 1B                                    bcc CheckHalfway
08F11 D0 16                                    bne SetSecHard           ;if not equal to, then world > 5, thus activate
08F13 AD 5C 07                                 lda LevelNumber          ;otherwise, world 5, so check level number
08F16 C9 02                                    cmp #Level3              ;if 1 or 2, do not set secondary hard mode flag
08F18 90 12                                    bcc CheckHalfway
08F1A B0 0D                                    bcs SetSecHard
08F1C C9 03                     ChkSecHard:    cmp #World4              ;if less than 4, do not activate secondary
08F1E 90 0C                                    bcc CheckHalfway
08F20 D0 07                                    bne SetSecHard           ;if not equal to, then world > 4, thus activate
08F22 AD 5C 07                                 lda LevelNumber          ;otherwise, world 4, so check level number
08F25 C9 03                                    cmp #Level4              ;if not 4, do not set secondary hard mode flag
08F27 90 03                                    bcc CheckHalfway
08F29 EE CC 06                  SetSecHard:    inc SecondaryHardMode    ;set secondary hard mode flag for SMB1 5-3/SMB2J 4-4 and beyond
08F2C AD 5B 07                  CheckHalfway:  lda HalfwayPage
08F2F F0 05                                    beq DoneInitArea
08F31 A9 02                                    lda #$02                 ;if halfway page set, overwrite start position from header
08F33 8D 10 07                                 sta PlayerEntranceCtrl
08F36 A9 80                     DoneInitArea:  lda #Silence             ;silence music
08F38 85 FB                                    sta AreaMusicQueue
08F3A A9 01                                    lda #$01                 ;disable screen output
08F3C 8D 74 07                                 sta DisableScreenFlag
08F3F EE 72 07                                 inc OperMode_Task        ;increment task for this mode
08F42 60                                       rts
08F43                           
08F43                           ;-------------------------------------------------------------------------------------
08F43                           
08F43                           SecondaryGameSetup:
08F43 A9 00                            lda #$00
08F45 8D 74 07                         sta DisableScreenFlag    ;reenable screen, reset some flags
08F48 8D F9 07                         sta WindFlag
08F4B 8D F6 07                         sta FlagpoleMusicFlag
08F4E A8                               tay
08F4F 99 00 03                  ClearVRLoop: sta VRAM_Buffer1-1,y      ;clear buffer at $0300-$03ff
08F52 C8                                     iny
08F53 D0 FA                                  bne ClearVRLoop
08F55 8D 59 07                               sta GameTimerExpiredFlag  ;clear game timer exp flag
08F58 8D 69 07                               sta DisableIntermediate   ;clear skip lives display flag
08F5B 8D 28 07                               sta BackloadingFlag       ;clear value here
08F5E A9 FF                                  lda #$ff
08F60 8D A0 03                               sta BalPlatformAlignment  ;initialize balance platform assignment flag
08F63 AD 1A 07                               lda ScreenLeft_PageLoc    ;get left side page location
08F66 29 01                                  and #$01
08F68 8D 7A 07                               sta NameTableSelect
08F6B 20 B7 8F                               jsr GetAreaMusic
08F6E A9 38                                  lda #$38                  ;load sprite shuffle amounts to be used later
08F70 8D E3 06                               sta SprShuffleAmt+2
08F73 A9 48                                  lda #$48
08F75 8D E2 06                               sta SprShuffleAmt+1
08F78 A9 58                                  lda #$58
08F7A 8D E1 06                               sta SprShuffleAmt
08F7D A2 0E                                  ldx #$0e                  ;load default OAM offsets
08F7F BD A3 8E                  ShufAmtLoop: lda DefaultSprOffsets,x
08F82 9D E4 06                               sta SprDataOffset,x
08F85 CA                                     dex                       ;do this until they're all set
08F86 10 F7                                  bpl ShufAmtLoop
08F88 20 68 91                               jsr DoNothing             ;do slightly less of nothing than in super mario bros 1
08F8B EE 22 07                               inc IRQUpdateFlag
08F8E EE 72 07                               inc OperMode_Task
08F91 60                                     rts
08F92                           ;-------------------------------------------------------------------------------------
08F92                           
08F92                           InitializeMemory:
08F92 A2 07                                   ldx #$07          ;set initial high byte to $0700-$07ff
08F94 A9 00                                   lda #$00          ;set initial low byte to start of page (at $00 of page)
08F96 85 06                                   sta $06
08F98 86 07                     InitPageLoop: stx $07
08F9A E0 01                     InitByteLoop: cpx #$01          ;check to see if we're on the stack ($0100-$01ff)
08F9C D0 08                                   bne InitByte      ;if not, go ahead anyway
08F9E C0 60                                   cpy #$60          ;otherwise, check to see if we're at $0160-$01ff
08FA0 B0 06                                   bcs SkipByte      ;if so, skip write
08FA2 C0 09                                   cpy #$09          ;otherwise, check to see if we're at $0100-$0108
08FA4 90 02                                   bcc SkipByte      ;if so, skip write
08FA6 91 06                     InitByte:     sta ($06),y       ;otherwise, initialize memory
08FA8 88                        SkipByte:     dey
08FA9 C0 FF                                   cpy #$ff          ;do this until all bytes in page have been erased
08FAB D0 ED                                   bne InitByteLoop
08FAD CA                                      dex               ;go onto the next page
08FAE 10 E8                                   bpl InitPageLoop  ;do this until all desired pages of memory have been erased
08FB0 60                                      rts
08FB1                           
08FB1                           ;-------------------------------------------------------------------------------------
08FB1                           
08FB1                           MusicSelectData:
08FB1 02 01 04 08                     .db WaterMusic, GroundMusic, UndergroundMusic, CastleMusic
08FB5 10 20                           .db CloudMusic, PipeIntroMusic
08FB7                           
08FB7                           GetAreaMusic:
08FB7 AD 70 07                               lda OperMode           ;if in attract mode, leave
08FBA F0 23                                  beq ExitGetM
08FBC AD 52 07                               lda AltEntranceControl ;check for specific alternate mode of entry
08FBF C9 02                                  cmp #$02               ;if found, branch without checking starting position
08FC1 F0 0D                                  beq ChkAreaType        ;from area object data header
08FC3 A0 05                                  ldy #$05               ;select music for pipe intro scene by default
08FC5 AD 10 07                               lda PlayerEntranceCtrl ;check value from level header for certain values
08FC8 C9 06                                  cmp #$06
08FCA F0 0E                                  beq StoreMusic         ;load music for pipe intro scene if header
08FCC C9 07                                  cmp #$07               ;start position either value $06 or $07
08FCE F0 0A                                  beq StoreMusic
08FD0 AC 4E 07                  ChkAreaType: ldy AreaType           ;load area type as offset for music bit
08FD3 AD 43 07                               lda CloudTypeOverride
08FD6 F0 02                                  beq StoreMusic         ;check for cloud type override
08FD8 A0 04                                  ldy #$04               ;select music for cloud type level if found
08FDA B9 B1 8F                  StoreMusic:  lda MusicSelectData,y  ;otherwise select appropriate music for level type
08FDD 85 FB                                  sta AreaMusicQueue     ;store in queue and leave
08FDF 60                        ExitGetM:    rts
08FE0                           
08FE0                           ;-------------------------------------------------------------------------------------
08FE0                           
08FE0                           PlayerStarting_X_Pos:
08FE0 28 18                           .db $28, $18
08FE2 38 28                           .db $38, $28
08FE4                           
08FE4                           AltYPosOffset:
08FE4 08 00                           .db $08, $00
08FE6                           
08FE6                           PlayerStarting_Y_Pos:
08FE6 00 20 B0 50 00 00 B0 B0         .db $00, $20, $b0, $50, $00, $00, $b0, $b0
08FEE F0                              .db $f0
08FEF                           
08FEF                           PlayerBGPriorityData:
08FEF 00 20 00 00 00 00 00 00         .db $00, $20, $00, $00, $00, $00, $00, $00
08FF7                           
08FF7                           GameTimerData:
08FF7 20                              .db $20 ;dummy byte, used as part of bg priority data
08FF8 04 03 02                        .db $04, $03, $02
08FFB                           
08FFB                           Entrance_GameTimerSetup:
08FFB AD 1A 07                            lda ScreenLeft_PageLoc      ;set current page for area objects
08FFE 85 6D                               sta Player_PageLoc          ;as page location for player
09000 A9 28                               lda #$28                    ;store value here
09002 8D 0A 07                            sta VerticalForceDown       ;for fractional movement downwards if necessary
09005 A9 01                               lda #$01                    ;set high byte of player position and
09007 85 33                               sta PlayerFacingDir         ;set facing direction so that player faces right
09009 85 B5                               sta Player_Y_HighPos
0900B A9 00                               lda #$00                    ;set player state to on the ground by default
0900D 85 1D                               sta Player_State
0900F CE 90 04                            dec Player_CollisionBits    ;initialize player's collision bits
09012 A0 00                               ldy #$00                    ;initialize halfway page
09014 8C 5B 07                            sty HalfwayPage      
09017 AD 4E 07                            lda AreaType                ;check area type
0901A D0 01                               bne ChkStPos                ;if water type, set swimming flag, otherwise do not set
0901C C8                                  iny
0901D 8C 04 07                  ChkStPos: sty SwimmingFlag
09020 AE 10 07                            ldx PlayerEntranceCtrl      ;get starting position loaded from header
09023 AC 52 07                            ldy AltEntranceControl      ;check alternate mode of entry flag for 0 or 1
09026 F0 07                               beq SetStPos
09028 C0 01                               cpy #$01
0902A F0 03                               beq SetStPos
0902C BE E2 8F                            ldx AltYPosOffset-2,y       ;if not 0 or 1, override start pos from header with alt offset
0902F B9 E0 8F                  SetStPos: lda PlayerStarting_X_Pos,y  ;load appropriate horizontal position
09032 85 86                               sta Player_X_Position       ;and vertical positions for the player, using
09034 BD E6 8F                            lda PlayerStarting_Y_Pos,x  ;AltEntranceControl as offset for horizontal and either
09037 85 CE                               sta Player_Y_Position       ;the original offset from the header or alt offset for vertical
09039 BD EF 8F                            lda PlayerBGPriorityData,x
0903C 8D C4 03                            sta Player_SprAttrib        ;set player sprite attributes using offset in X
0903F 20 24 85                            jsr GetPlayerColors         ;get appropriate player palette
09042 AC 15 07                            ldy GameTimerSetting        ;get timer control value from header
09045 F0 1A                               beq ChkOverR                ;if set to zero, branch (do not use dummy byte for this)
09047 AD 57 07                            lda FetchNewGameTimerFlag   ;do we need to set the game timer? if not, use 
0904A F0 15                               beq ChkOverR                ;old game timer setting
0904C B9 F7 8F                            lda GameTimerData,y         ;if game timer is set and game timer flag is also set,
0904F 8D EC 07                            sta GameTimerDisplay        ;use value of game timer control for first digit of game timer
09052 A9 01                               lda #$01
09054 8D EE 07                            sta GameTimerDisplay+2      ;set last digit of game timer to 1
09057 4A                                  lsr
09058 8D ED 07                            sta GameTimerDisplay+1      ;set second digit of game timer
0905B 8D 57 07                            sta FetchNewGameTimerFlag   ;clear flag for game timer reset
0905E 8D 9F 07                            sta StarInvincibleTimer     ;clear star mario timer
09061 AC 58 07                  ChkOverR: ldy JoypadOverride          ;if controller bits not set, branch to skip this part
09064 F0 14                               beq ChkSwimE
09066 A9 03                               lda #$03                    ;set player state to climbing
09068 85 1D                               sta Player_State
0906A A2 00                               ldx #$00                    ;set offset for first slot, for block object
0906C 20 95 AA                            jsr InitBlock_XY_Pos
0906F A9 F0                               lda #$f0                    ;set vertical coordinate for block object
09071 85 D7                               sta Block_Y_Position
09073 A2 05                               ldx #$05                    ;set offset in X for last enemy object buffer slot
09075 A0 00                               ldy #$00                    ;set offset in Y for object coordinates used earlier
09077 20 FE A5                            jsr Setup_Vine              ;do a sub to grow vine
0907A AC 4E 07                  ChkSwimE: ldy AreaType                ;if level not water-type,
0907D D0 03                               bne SetPESub                ;skip this subroutine
0907F 20 C6 A3                            jsr SetupBubble             ;otherwise, execute sub to set up air bubbles
09082 A9 07                     SetPESub: lda #$07                    ;set to run player entrance subroutine
09084 85 0E                               sta GameEngineSubroutine    ;on the next frame of game engine
09086 60                                  rts
09087                           
09087                           ;-------------------------------------------------------------------------------------
09087                           
09087                           ;page numbers are in order from level numbers 1 to 4
09087                           HalfwayPageNybbles:
09087 56 40                           .db $56, $40 ;SMB1 levels
09089 65 70                           .db $65, $70
0908B 66 40                           .db $66, $40
0908D 66 40                           .db $66, $40
0908F 66 40                           .db $66, $40
09091 66 60                           .db $66, $60
09093 65 70                           .db $65, $70
09095 00 00                           .db $00, $00
09097 00 00                           .db $00, $00
09099                           
09099 66 60                           .db $66, $60 ;SMB2J levels
0909B 88 60                           .db $88, $60
0909D 66 70                           .db $66, $70
0909F 77 60                           .db $77, $60
090A1 D6 00                           .db $d6, $00
090A3 77 80                           .db $77, $80
090A5 70 B0                           .db $70, $b0
090A7 00 00                           .db $00, $00
090A9 00 00                           .db $00, $00
090AB 76 50                           .db $76, $50
090AD 65 50                           .db $65, $50
090AF 75 B0                           .db $75, $b0
090B1 00 00                           .db $00, $00
090B3                           
090B3                           PlayerLoseLife:
090B3 EE 74 07                               inc DisableScreenFlag    ;disable screen and IRQs
090B6 A9 00                                  lda #$00
090B8 8D 22 07                               sta IRQUpdateFlag
090BB A9 80                                  lda #Silence             ;silence music
090BD 85 FC                                  sta EventMusicQueue
090BF CE 5A 07                               dec NumberofLives        ;take one life from player
090C2 10 0B                                  bpl StillInGame          ;if player still has lives, branch
090C4 A9 00                                  lda #$00
090C6 8D 72 07                               sta OperMode_Task        ;initialize mode task,
090C9 A9 03                                  lda #GameOverMode        ;switch to game over mode
090CB 8D 70 07                               sta OperMode             ;and leave
090CE 60                                     rts
090CF AD 5F 07                  StillInGame: lda WorldNumber          ;retrieve world number for offset
090D2 AC FB 07                               ldy HardWorldFlag        ;check if playing 2J levels
090D5 F0 03                                  beq NrmlWorlds           ;if not, use world number as-is
090D7 18                                     clc                      ;otherwise add nine for correct halfway pages
090D8 69 09                                  adc #$09
090DA 0A                        NrmlWorlds:  asl                      ;multiply by 2 to get offset
090DB AA                                     tax
090DC AD 5C 07                               lda LevelNumber          ;if in level 3 or 4, increment
090DF 29 02                                  and #$02                 ;offset by one byte, otherwise
090E1 F0 01                                  beq GetHalfway           ;leave offset alone
090E3 E8                                     inx
090E4 BC 87 90                  GetHalfway:  ldy HalfwayPageNybbles,x ;get halfway page number with offset
090E7 AD 5C 07                               lda LevelNumber          ;check area number's LSB
090EA 4A                                     lsr
090EB 98                                     tya                      ;if in level 2 or 4, use lower nybble
090EC B0 04                                  bcs MaskHPNyb
090EE 4A                                     lsr                      ;move higher nybble to lower if
090EF 4A                                     lsr                      ;level number is 1 or 3
090F0 4A                                     lsr
090F1 4A                                     lsr
090F2 29 0F                     MaskHPNyb:   and #%00001111           ;mask out all but lower nybble
090F4 CD 1A 07                               cmp ScreenLeft_PageLoc
090F7 F0 04                                  beq SetHalfway           ;left side of screen must be at the halfway page,
090F9 90 02                                  bcc SetHalfway           ;otherwise player must start at the
090FB A9 00                                  lda #$00                 ;beginning of the level
090FD 8D 5B 07                  SetHalfway:  sta HalfwayPage          ;store as halfway page for player
09100 4C 4A 91                               jmp ContinueGame         ;continue the game
09103                           
09103                           ;-------------------------------------------------------------------------------------
09103                           
09103                           GameOverSubs:
09103 AD 72 07                        lda OperMode_Task
09106 20 F8 8C                        jsr JumpEngine
09109                           
09109 0F 91                           .dw SetupGameOver
0910B 94 84                           .dw ScreenRoutines
0910D 25 91                           .dw RunGameOver
0910F                           
0910F                           ;-------------------------------------------------------------------------------------
0910F                           
0910F                           SetupGameOver:
0910F A9 00                           lda #$00
09111 8D 3C 07                        sta ScreenRoutineTask
09114 8D 22 07                        sta IRQUpdateFlag
09117 8D F8 07                        sta ContinueMenuSelect ;set continue as default choice
0911A A9 02                           lda #$02
0911C 85 FC                           sta EventMusicQueue    ;play game over music
0911E EE 74 07                        inc DisableScreenFlag
09121 EE 72 07                        inc OperMode_Task
09124 60                              rts
09125                           
09125                           RunGameOver:
09125 A9 00                            lda #$00
09127 8D 74 07                         sta DisableScreenFlag
0912A AD F5 07                         lda GameOverMsgFlag   ;if message flag set, branch to end the game
0912D D0 03                            bne WDEnd
0912F 4C 9D E2                         jmp GameOverMenu      ;otherwise run game over menu
09132 AD A0 07                  WDEnd: lda ScreenTimer
09135 D0 12                            bne ExRGO
09137                           
09137                           TerminateGame:
09137 A9 80                            lda #Silence          ;silence music
09139 85 FC                            sta EventMusicQueue
0913B A9 00                            lda #$00
0913D 8D 72 07                         sta OperMode_Task     ;reset to attract mode and leave
09140 8D A0 07                         sta ScreenTimer
09143 8D 70 07                         sta OperMode
09146 8D F5 07                         sta GameOverMsgFlag   ;reset game over message flag
09149 60                        ExRGO: rts
0914A                           
0914A                           ContinueGame:
0914A 20 AF FE                             jsr RunLoadAreaPointer    ;update level pointer with
0914D A9 01                                lda #$01                  ;actual world and area numbers, then
0914F 8D 54 07                             sta PlayerSize            ;reset player's size, status, and
09152 EE 57 07                             inc FetchNewGameTimerFlag ;set game timer flag to reload
09155 A9 00                                lda #$00                  ;game timer from header
09157 8D 47 07                             sta TimerControl          ;also set flag for timers to count again
0915A 8D 56 07                             sta PlayerStatus
0915D 85 0E                                sta GameEngineSubroutine  ;reset task for game core
0915F 8D 72 07                             sta OperMode_Task         ;set modes and leave
09162 A9 01                                lda #$01                  ;if in game over mode, switch back to
09164 8D 70 07                             sta OperMode              ;game mode, because game is still on
09167 60                        GameIsOn:  rts
09168                           
09168                           ;-------------------------------------------------------------------------------------
09168                           
09168                           DoNothing:
09168 A9 FF                           lda #$ff       ;this is residual code, this value is
0916A 8D C9 06                        sta $06c9      ;not used anywhere in the program
0916D 60                              rts
0916E                           
0916E                           ;-------------------------------------------------------------------------------------
0916E                           
0916E                           AreaParserTaskHandler:
0916E AC 1F 07                                ldy AreaParserTaskNum     ;check number of tasks here
09171 D0 05                                   bne DoAPTasks             ;if already set, go ahead
09173 A0 08                                   ldy #$08
09175 8C 1F 07                                sty AreaParserTaskNum     ;otherwise, set eight by default
09178 88                        DoAPTasks:    dey
09179 98                                      tya
0917A 20 86 91                                jsr AreaParserTasks
0917D CE 1F 07                                dec AreaParserTaskNum     ;if all tasks not complete do not
09180 D0 03                                   bne SkipATRender          ;render attribute table yet
09182 20 9A 88                                jsr RenderAttributeTables
09185 60                        SkipATRender: rts
09186                           
09186                           AreaParserTasks:
09186 20 F8 8C                        jsr JumpEngine
09189                           
09189 99 91                           .dw IncrementColumnPos
0918B DE 87                           .dw RenderAreaGraphics
0918D DE 87                           .dw RenderAreaGraphics
0918F BA 92                           .dw AreaParserCore
09191 99 91                           .dw IncrementColumnPos
09193 DE 87                           .dw RenderAreaGraphics
09195 DE 87                           .dw RenderAreaGraphics
09197 BA 92                           .dw AreaParserCore
09199                           
09199                           ;-------------------------------------------------------------------------------------
09199                           
09199                           IncrementColumnPos:
09199 EE 26 07                             inc CurrentColumnPos     ;increment column where we're at
0919C AD 26 07                             lda CurrentColumnPos
0919F 29 0F                                and #%00001111           ;mask out higher nybble
091A1 D0 06                                bne NoColWrap
091A3 8D 26 07                             sta CurrentColumnPos     ;if no bits left set, wrap back to zero (0-f)
091A6 EE 25 07                             inc CurrentPageLoc       ;and increment page number where we're at
091A9 EE A0 06                  NoColWrap: inc BlockBufferColumnPos ;increment column offset where we're at
091AC AD A0 06                             lda BlockBufferColumnPos
091AF 29 1F                                and #%00011111           ;mask out all but 5 LSB (0-1f)
091B1 8D A0 06                             sta BlockBufferColumnPos ;and save
091B4 60                                   rts
091B5                           
091B5                           ;-------------------------------------------------------------------------------------
091B5                           ;$00 - used as counter, store for low nybble for background, ceiling byte for terrain
091B5                           ;$01 - used to store floor byte for terrain
091B5                           ;$07 - used to store terrain metatile
091B5                           ;$06-$07 - used to store block buffer address
091B5                           
091B5                           BSceneDataOffsets:
091B5 00 30 60                        .db $00, $30, $60 
091B8                           
091B8                           BackSceneryData:
091B8 93 00 00 11 12 12 13 00      .db $93, $00, $00, $11, $12, $12, $13, $00 ;clouds
091C0 00 51 52 53 00 00 00 00      .db $00, $51, $52, $53, $00, $00, $00, $00
091C8 00 00 01 02 02 03 00 00      .db $00, $00, $01, $02, $02, $03, $00, $00
091D0 00 00 00 00 91 92 93 00      .db $00, $00, $00, $00, $91, $92, $93, $00
091D8 00 00 00 51 52 53 41 42      .db $00, $00, $00, $51, $52, $53, $41, $42
091E0 43 00 00 00 00 00 91 92      .db $43, $00, $00, $00, $00, $00, $91, $92
091E8                           
091E8 97 87 88 89 99 00 00 00      .db $97, $87, $88, $89, $99, $00, $00, $00 ;mountains and bushes
091F0 11 12 13 A4 A5 A5 A5 A6      .db $11, $12, $13, $a4, $a5, $a5, $a5, $a6
091F8 97 98 99 01 02 03 00 A4      .db $97, $98, $99, $01, $02, $03, $00, $a4
09200 A5 A6 00 11 12 12 12 13      .db $a5, $a6, $00, $11, $12, $12, $12, $13
09208 00 00 00 00 01 02 02 03      .db $00, $00, $00, $00, $01, $02, $02, $03
09210 00 A4 A5 A5 A6 00 00 00      .db $00, $a4, $a5, $a5, $a6, $00, $00, $00
09218                           
09218 11 12 12 13 00 00 00 00      .db $11, $12, $12, $13, $00, $00, $00, $00 ;trees and fences
09220 00 00 00 9C 00 8B AA AA      .db $00, $00, $00, $9c, $00, $8b, $aa, $aa
09228 AA AA 11 12 13 8B 00 9C      .db $aa, $aa, $11, $12, $13, $8b, $00, $9c
09230 9C 00 00 01 02 03 11 12      .db $9c, $00, $00, $01, $02, $03, $11, $12
09238 12 13 00 00 00 00 AA AA      .db $12, $13, $00, $00, $00, $00, $aa, $aa
09240 9C AA 00 8B 00 01 02 03      .db $9c, $aa, $00, $8b, $00, $01, $02, $03
09248                           
09248                           BackSceneryMetatiles:
09248 80 83 00                     .db $80, $83, $00 ;cloud left
0924B 81 84 00                     .db $81, $84, $00 ;cloud middle
0924E 82 85 00                     .db $82, $85, $00 ;cloud right
09251 02 00 00                     .db $02, $00, $00 ;bush left
09254 03 00 00                     .db $03, $00, $00 ;bush middle
09257 04 00 00                     .db $04, $00, $00 ;bush right
0925A 00 05 06                     .db $00, $05, $06 ;mountain left
0925D 07 06 0A                     .db $07, $06, $0a ;mountain middle
09260 00 08 09                     .db $00, $08, $09 ;mountain right
09263 4D 00 00                     .db $4d, $00, $00 ;fence
09266 0D 0F 4E                     .db $0d, $0f, $4e ;tall tree
09269 0E 4E 4E                     .db $0e, $4e, $4e ;short tree
0926C                           
0926C                           FSceneDataOffsets:
0926C 00 0D 1A                        .db $00, $0d, $1a
0926F                           
0926F                           ForeSceneryData:
0926F 86 87 87 87 87 87 87         .db $86, $87, $87, $87, $87, $87, $87   ;in water
09276 87 87 87 87 6C 6C            .db $87, $87, $87, $87, $6c, $6c
0927C                           
0927C 00 00 00 00 00 45 47         .db $00, $00, $00, $00, $00, $45, $47   ;wall
09283 47 47 47 47 00 00            .db $47, $47, $47, $47, $00, $00
09289                           
09289 00 00 00 00 00 00 00         .db $00, $00, $00, $00, $00, $00, $00   ;over water
09290 00 00 00 00 86 87            .db $00, $00, $00, $00, $86, $87
09296                           
09296                           TerrainMetatiles:
09296 6C 6D 52 65                     .db $6c, $6d, $52, $65
0929A                           
0929A                           TerrainRenderBits:
0929A 00 00                           .db %00000000, %00000000 ;no ceiling or floor
0929C 00 18                           .db %00000000, %00011000 ;no ceiling, floor 2
0929E 01 18                           .db %00000001, %00011000 ;ceiling 1, floor 2
092A0 07 18                           .db %00000111, %00011000 ;ceiling 3, floor 2
092A2 0F 18                           .db %00001111, %00011000 ;ceiling 4, floor 2
092A4 FF 18                           .db %11111111, %00011000 ;ceiling 8, floor 2
092A6 01 1F                           .db %00000001, %00011111 ;ceiling 1, floor 5
092A8 07 1F                           .db %00000111, %00011111 ;ceiling 3, floor 5
092AA 0F 1F                           .db %00001111, %00011111 ;ceiling 4, floor 5
092AC 81 1F                           .db %10000001, %00011111 ;ceiling 1, floor 6
092AE 01 00                           .db %00000001, %00000000 ;ceiling 1, no floor
092B0 8F 1F                           .db %10001111, %00011111 ;ceiling 4, floor 6
092B2 F1 1F                           .db %11110001, %00011111 ;ceiling 1, floor 9
092B4 F9 18                           .db %11111001, %00011000 ;ceiling 1, middle 5, floor 2
092B6 F1 18                           .db %11110001, %00011000 ;ceiling 1, middle 4, floor 2
092B8 FF 1F                           .db %11111111, %00011111 ;completely solid top to bottom
092BA                           
092BA                           AreaParserCore:
092BA AD 28 07                        lda BackloadingFlag       ;check to see if we are starting right of start
092BD F0 03                           beq RenderSceneryTerrain  ;if not, go ahead and render background, foreground and terrain
092BF 20 C6 93                        jsr ProcessAreaData       ;otherwise skip ahead and load level data
092C2                           
092C2                           RenderSceneryTerrain:
092C2 A2 0C                               ldx #$0c
092C4 A9 00                               lda #$00
092C6 9D A1 06                  ClrMTBuf: sta MetatileBuffer,x       ;clear out metatile buffer
092C9 CA                                  dex
092CA 10 FA                               bpl ClrMTBuf
092CC AC 42 07                            ldy BackgroundScenery      ;do we need to render the background scenery?
092CF F0 42                               beq RendFore               ;if not, skip to check the foreground
092D1 AD 25 07                            lda CurrentPageLoc         ;otherwise check for every third page
092D4 C9 03                     ThirdP:   cmp #$03
092D6 30 05                               bmi RendBack               ;if less than three we're there
092D8 38                                  sec
092D9 E9 03                               sbc #$03                   ;if 3 or more, subtract 3 and 
092DB 10 F7                               bpl ThirdP                 ;do an unconditional branch
092DD 0A                        RendBack: asl                        ;move results to higher nybble
092DE 0A                                  asl
092DF 0A                                  asl
092E0 0A                                  asl
092E1 79 B4 91                            adc BSceneDataOffsets-1,y  ;add to it offset loaded from here
092E4 6D 26 07                            adc CurrentColumnPos       ;add to the result our current column position
092E7 AA                                  tax
092E8 BD B8 91                            lda BackSceneryData,x      ;load data from sum of offsets
092EB F0 26                               beq RendFore               ;if zero, no scenery for that part
092ED 48                                  pha
092EE 29 0F                               and #$0f                   ;save to stack and clear high nybble
092F0 38                                  sec
092F1 E9 01                               sbc #$01                   ;subtract one (because low nybble is $01-$0c)
092F3 85 00                               sta $00                    ;save low nybble
092F5 0A                                  asl                        ;multiply by three (shift to left and add result to old one)
092F6 65 00                               adc $00                    ;note that since d7 was nulled, the carry flag is always clear
092F8 AA                                  tax                        ;save as offset for background scenery metatile data
092F9 68                                  pla                        ;get high nybble from stack, move low
092FA 4A                                  lsr
092FB 4A                                  lsr
092FC 4A                                  lsr
092FD 4A                                  lsr
092FE A8                                  tay                        ;use as second offset (used to determine height)
092FF A9 03                               lda #$03                   ;use previously saved memory location for counter
09301 85 00                               sta $00
09303 BD 48 92                  SceLoop1: lda BackSceneryMetatiles,x ;load metatile data from offset of (lsb - 1) * 3
09306 99 A1 06                            sta MetatileBuffer,y       ;store into buffer from offset of (msb / 16)
09309 E8                                  inx
0930A C8                                  iny
0930B C0 0B                               cpy #$0b                   ;if at this location, leave loop
0930D F0 04                               beq RendFore
0930F C6 00                               dec $00                    ;decrement until counter expires, barring exception
09311 D0 F0                               bne SceLoop1
09313 AE 41 07                  RendFore: ldx ForegroundScenery      ;check for foreground data needed or not
09316 F0 13                               beq RendTerr               ;if not, skip this part
09318 BC 6B 92                            ldy FSceneDataOffsets-1,x  ;load offset from location offset by header value, then
0931B A2 00                               ldx #$00                   ;reinit X
0931D B9 6F 92                  SceLoop2: lda ForeSceneryData,y      ;load data until counter expires
09320 F0 03                               beq NoFore                 ;do not store if zero found
09322 9D A1 06                            sta MetatileBuffer,x
09325 C8                        NoFore:   iny
09326 E8                                  inx
09327 E0 0D                               cpx #$0d                   ;store up to end of metatile buffer
09329 D0 F2                               bne SceLoop2
0932B AC 4E 07                  RendTerr: ldy AreaType               ;check world type for water level
0932E D0 0C                               bne TerMTile               ;if not water level, skip this part
09330 AD 5F 07                            lda WorldNumber            ;check world number, if not world number eight
09333 C9 07                               cmp #World8                ;then skip this part
09335 D0 05                               bne TerMTile
09337 A9 65                               lda #$65                   ;if set as water level and world number eight,
09339 4C 46 93                            jmp StoreMT                ;use castle wall metatile as terrain type
0933C B9 96 92                  TerMTile: lda TerrainMetatiles,y     ;otherwise get appropriate metatile for area type
0933F AC 43 07                            ldy CloudTypeOverride      ;check for cloud type override
09342 F0 02                               beq StoreMT                ;if not set, keep value otherwise
09344 A9 88                               lda #$88                   ;use cloud block terrain
09346 85 07                     StoreMT:  sta $07                    ;store value here
09348 A2 00                               ldx #$00                   ;initialize X, use as metatile buffer offset
0934A AD 27 07                            lda TerrainControl         ;use yet another value from the header
0934D 0A                                  asl                        ;multiply by 2 and use as yet another offset
0934E A8                                  tay
0934F B9 9A 92                  TerrLoop: lda TerrainRenderBits,y    ;get one of the terrain rendering bit data
09352 85 00                               sta $00
09354 C8                                  iny                        ;increment Y and use as offset next time around
09355 84 01                               sty $01
09357 AD 43 07                            lda CloudTypeOverride      ;skip if value here is zero
0935A F0 0A                               beq NoCloud2
0935C E0 00                               cpx #$00                   ;otherwise, check if we're doing the ceiling byte
0935E F0 06                               beq NoCloud2
09360 A5 00                               lda $00                    ;if not, mask out all but d3
09362 29 08                               and #%00001000
09364 85 00                               sta $00
09366 A0 00                     NoCloud2: ldy #$00                   ;start at beginning of bitmasks
09368 B9 9C B4                  TerrBChk: lda Bitmasks,y             ;load bitmask, then perform AND on contents of first byte
0936B 24 00                               bit $00
0936D F0 05                               beq NextTBit               ;if not set, skip this part (do not write terrain to buffer)
0936F A5 07                               lda $07
09371 9D A1 06                            sta MetatileBuffer,x       ;load terrain type metatile number and store into buffer here
09374 E8                        NextTBit: inx                        ;continue until end of buffer
09375 E0 0D                               cpx #$0d
09377 F0 18                               beq RendBBuf               ;if we're at the end, break out of this loop
09379 AD 4E 07                            lda AreaType               ;check world type for underground area
0937C C9 02                               cmp #$02
0937E D0 08                               bne EndUChk                ;if not underground, skip this part
09380 E0 0B                               cpx #$0b
09382 D0 04                               bne EndUChk                ;if we're at the bottom of the screen, override
09384 A9 6D                               lda #$6d                   ;old terrain type with ground level terrain type
09386 85 07                               sta $07
09388 C8                        EndUChk:  iny                        ;increment bitmasks offset in Y
09389 C0 08                               cpy #$08
0938B D0 DB                               bne TerrBChk               ;if not all bits checked, loop back    
0938D A4 01                               ldy $01
0938F D0 BE                               bne TerrLoop               ;unconditional branch, use Y to load next byte
09391 20 C6 93                  RendBBuf: jsr ProcessAreaData        ;do the area data loading routine now
09394 AD A0 06                            lda BlockBufferColumnPos
09397 20 35 9B                            jsr GetBlockBufferAddr     ;get block buffer address from where we're at
0939A A2 00                               ldx #$00
0939C A0 00                               ldy #$00                   ;init index regs and start at beginning of smaller buffer
0939E 84 00                     ChkMTLow: sty $00
093A0 BD A1 06                            lda MetatileBuffer,x       ;load stored metatile number
093A3 29 C0                               and #%11000000             ;mask out all but 2 MSB
093A5 0A                                  asl
093A6 2A                                  rol                        ;make %xx000000 into %000000xx
093A7 2A                                  rol
093A8 A8                                  tay                        ;use as offset in Y
093A9 BD A1 06                            lda MetatileBuffer,x       ;reload original unmasked value here
093AC D9 C2 93                            cmp BlockBuffLowBounds,y   ;check for certain values depending on bits set
093AF B0 02                               bcs StrBlock               ;if equal or greater, branch
093B1 A9 00                               lda #$00                   ;if less, init value before storing
093B3 A4 00                     StrBlock: ldy $00                    ;get offset for block buffer
093B5 91 06                               sta ($06),y                ;store value into block buffer
093B7 98                                  tya
093B8 18                                  clc                        ;add 16 (move down one row) to offset
093B9 69 10                               adc #$10
093BB A8                                  tay
093BC E8                                  inx                        ;increment column value
093BD E0 0D                               cpx #$0d
093BF 90 DD                               bcc ChkMTLow               ;continue until we pass last row, then leave
093C1 60                                  rts
093C2                           
093C2                           ;numbers lower than these with the same attribute bits
093C2                           ;will not be stored in the block buffer
093C2                           BlockBuffLowBounds:
093C2 10 51 88 C0                     .db $10, $51, $88, $c0
093C6                           
093C6                           ;-------------------------------------------------------------------------------------
093C6                           ;$00 - used to store area object identifier
093C6                           ;$07 - used as adder to find proper area object code
093C6                           
093C6                           ProcessAreaData:
093C6 A2 02                                 ldx #$02                 ;start at the end of area object buffer
093C8 86 08                     ProcADLoop: stx ObjectOffset
093CA A9 00                                 lda #$00                 ;reset flag
093CC 8D 29 07                              sta BehindAreaParserFlag
093CF AC 2C 07                              ldy AreaDataOffset       ;get offset of area data pointer
093D2 B1 E7                                 lda (AreaData),y         ;get first byte of area object
093D4 C9 FD                                 cmp #$fd                 ;if end-of-area, skip all this crap
093D6 F0 4B                                 beq RdyDecode
093D8 BD 30 07                              lda AreaObjectLength,x   ;check area object buffer flag
093DB 10 46                                 bpl RdyDecode            ;if buffer not negative, branch, otherwise
093DD C8                                    iny
093DE B1 E7                                 lda (AreaData),y         ;get second byte of area object
093E0 0A                                    asl                      ;check for page select bit (d7), branch if not set
093E1 90 0B                                 bcc Chk1Row13
093E3 AD 2B 07                              lda AreaObjectPageSel    ;check page select
093E6 D0 06                                 bne Chk1Row13
093E8 EE 2B 07                              inc AreaObjectPageSel    ;if not already set, set it now
093EB EE 2A 07                              inc AreaObjectPageLoc    ;and increment page location
093EE 88                        Chk1Row13:  dey
093EF B1 E7                                 lda (AreaData),y         ;reread first byte of level object
093F1 29 0F                                 and #$0f                 ;mask out high nybble
093F3 C9 0D                                 cmp #$0d                 ;row 13?
093F5 D0 1B                                 bne Chk1Row14
093F7 C8                                    iny                      ;if so, reread second byte of level object
093F8 B1 E7                                 lda (AreaData),y
093FA 88                                    dey                      ;decrement to get ready to read first byte
093FB 29 40                                 and #%01000000           ;check for d6 set (if not, object is page control)
093FD D0 1C                                 bne CheckRear
093FF AD 2B 07                              lda AreaObjectPageSel    ;if page select is set, do not reread
09402 D0 17                                 bne CheckRear
09404 C8                                    iny                      ;if d6 not set, reread second byte
09405 B1 E7                                 lda (AreaData),y
09407 29 1F                                 and #%00011111           ;mask out all but 5 LSB and store in page control
09409 8D 2A 07                              sta AreaObjectPageLoc
0940C EE 2B 07                              inc AreaObjectPageSel    ;increment page select
0940F 4C 2C 94                              jmp NextAObj
09412 C9 0E                     Chk1Row14:  cmp #$0e                 ;row 14?
09414 D0 05                                 bne CheckRear
09416 AD 28 07                              lda BackloadingFlag      ;check flag for saved page number and branch if set
09419 D0 08                                 bne RdyDecode            ;to render the object (otherwise bg might not look right)
0941B AD 2A 07                  CheckRear:  lda AreaObjectPageLoc    ;check to see if current page of level object is
0941E CD 25 07                              cmp CurrentPageLoc       ;behind current page of renderer
09421 90 06                                 bcc SetBehind            ;if so branch
09423 20 53 94                  RdyDecode:  jsr DecodeAreaData       ;do sub and do not turn on flag
09426 4C 2F 94                              jmp ChkLength
09429 EE 29 07                  SetBehind:  inc BehindAreaParserFlag ;turn on flag if object is behind renderer
0942C 20 47 94                  NextAObj:   jsr IncAreaObjOffset     ;increment buffer offset and move on
0942F A6 08                     ChkLength:  ldx ObjectOffset         ;get buffer offset
09431 BD 30 07                              lda AreaObjectLength,x   ;check object length for anything stored here
09434 30 03                                 bmi ProcLoopb            ;if not, branch to handle loopback
09436 DE 30 07                              dec AreaObjectLength,x   ;otherwise decrement length or get rid of it
09439 CA                        ProcLoopb:  dex                      ;decrement buffer offset
0943A 10 8C                                 bpl ProcADLoop           ;and loopback unless exceeded buffer
0943C AD 29 07                              lda BehindAreaParserFlag ;check for flag set if objects were behind renderer
0943F D0 85                                 bne ProcessAreaData      ;branch if true to load more level data, otherwise
09441 AD 28 07                              lda BackloadingFlag      ;check for flag set if starting right of page $00
09444 D0 80                                 bne ProcessAreaData      ;branch if true to load more level data, otherwise leave
09446 60                        EndAParse:  rts
09447                           
09447                           IncAreaObjOffset:
09447 EE 2C 07                        inc AreaDataOffset    ;increment offset of level pointer
0944A EE 2C 07                        inc AreaDataOffset
0944D A9 00                           lda #$00              ;reset page select
0944F 8D 2B 07                        sta AreaObjectPageSel
09452 60                              rts
09453                           
09453                           DecodeAreaData:
09453 BD 30 07                            lda AreaObjectLength,x     ;check current buffer flag
09456 30 03                               bmi Chk1stB
09458 BC 2D 07                            ldy AreaObjOffsetBuffer,x  ;if not, get offset from buffer
0945B A2 10                     Chk1stB:  ldx #$10                   ;load offset of 16 for special row 15
0945D B1 E7                               lda (AreaData),y           ;get first byte of level object again
0945F C9 FD                               cmp #$fd
09461 F0 E3                               beq EndAParse              ;if end of level, leave this routine
09463 29 0F                               and #$0f                   ;otherwise, mask out low nybble
09465 C9 0F                               cmp #$0f                   ;row 15?
09467 F0 08                               beq ChkRow14               ;if so, keep the offset of 16
09469 A2 08                               ldx #$08                   ;otherwise load offset of 8 for special row 12
0946B C9 0C                               cmp #$0c                   ;row 12?
0946D F0 02                               beq ChkRow14               ;if so, keep the offset value of 8
0946F A2 00                               ldx #$00                   ;otherwise nullify value by default
09471 86 07                     ChkRow14: stx $07                    ;store whatever value we just loaded here
09473 A6 08                               ldx ObjectOffset           ;get object offset again
09475 C9 0E                               cmp #$0e                   ;row 14?
09477 D0 08                               bne ChkRow13
09479 A9 00                               lda #$00                   ;if so, load offset with $00
0947B 85 07                               sta $07
0947D A9 36                               lda #$36                   ;and load A with another value
0947F D0 53                               bne NormObj                ;unconditional branch
09481 C9 0D                     ChkRow13: cmp #$0d                   ;row 13?
09483 D0 1B                               bne ChkSRows
09485 A9 28                               lda #$28                   ;if so, load offset with 40
09487 85 07                               sta $07
09489 C8                                  iny                        ;get next byte
0948A B1 E7                               lda (AreaData),y
0948C 29 40                               and #%01000000             ;mask out all but d6 (page control obj bit)
0948E F0 63                               beq LeavePar               ;if d6 clear, branch to leave (we handled this earlier)
09490 B1 E7                               lda (AreaData),y           ;otherwise, get byte again
09492 29 7F                               and #%01111111             ;mask out d7
09494 C9 4B                               cmp #$4b                   ;check for loop command in low nybble
09496 D0 03                               bne Mask2MSB               ;(plus d6 set for object other than page control)
09498 EE 45 07                            inc LoopCommand            ;if loop command, set loop command flag
0949B 29 3F                     Mask2MSB: and #%00111111             ;mask out d7 and d6
0949D 4C D4 94                            jmp NormObj                ;and jump
094A0 C9 0C                     ChkSRows: cmp #$0c                   ;row 12-15?
094A2 B0 27                               bcs SpecObj
094A4 C8                                  iny                        ;if not, get second byte of level object
094A5 B1 E7                               lda (AreaData),y
094A7 29 70                               and #%01110000             ;mask out all but d6-d4
094A9 D0 0B                               bne LrgObj                 ;if any bits set, branch to handle large object
094AB A9 18                               lda #$18
094AD 85 07                               sta $07                    ;otherwise set offset of 24 for small object
094AF B1 E7                               lda (AreaData),y           ;reload second byte of level object
094B1 29 0F                               and #%00001111             ;mask out higher nybble and jump
094B3 4C D4 94                            jmp NormObj
094B6 85 00                     LrgObj:   sta $00                    ;store value here (branch for large objects)
094B8 C9 70                               cmp #$70                   ;check for vertical pipe object
094BA D0 0A                               bne NotWPipe
094BC B1 E7                               lda (AreaData),y           ;if not, reload second byte
094BE 29 08                               and #%00001000             ;mask out all but d3 (usage control bit)
094C0 F0 04                               beq NotWPipe               ;if d3 clear, branch to get original value
094C2 A9 00                               lda #$00                   ;otherwise, nullify value for warp pipe
094C4 85 00                               sta $00
094C6 A5 00                     NotWPipe: lda $00                    ;get value and jump ahead
094C8 4C D0 94                            jmp MoveAOId
094CB C8                        SpecObj:  iny                        ;branch here for rows 12-15
094CC B1 E7                               lda (AreaData),y
094CE 29 70                               and #%01110000             ;get next byte and mask out all but d6-d4
094D0 4A                        MoveAOId: lsr                        ;move d6-d4 to lower nybble
094D1 4A                                  lsr
094D2 4A                                  lsr
094D3 4A                                  lsr
094D4 85 00                     NormObj:  sta $00                    ;store value here (branch for small objects and rows 13 and 14)
094D6 BD 30 07                            lda AreaObjectLength,x     ;is there something stored here already?
094D9 10 42                               bpl RunAObj                ;if so, branch to do its particular sub
094DB AD 2A 07                            lda AreaObjectPageLoc      ;otherwise check to see if the object we've loaded is on the
094DE CD 25 07                            cmp CurrentPageLoc         ;same page as the renderer, and if so, branch
094E1 F0 11                               beq InitRear
094E3 AC 2C 07                            ldy AreaDataOffset         ;if not, get old offset of level pointer
094E6 B1 E7                               lda (AreaData),y           ;and reload first byte
094E8 29 0F                               and #%00001111
094EA C9 0E                               cmp #$0e                   ;row 14?
094EC D0 05                               bne LeavePar
094EE AD 28 07                            lda BackloadingFlag        ;if so, check backloading flag
094F1 D0 21                               bne StrAObj                ;if set, branch to render object, else leave
094F3 60                        LeavePar: rts
094F4 AD 28 07                  InitRear: lda BackloadingFlag        ;check backloading flag to see if it's been initialized
094F7 F0 0B                               beq BackColC               ;branch to column-wise check
094F9 A9 00                               lda #$00                   ;if not, initialize both backloading and 
094FB 8D 28 07                            sta BackloadingFlag        ;behind-renderer flags and leave
094FE 8D 29 07                            sta BehindAreaParserFlag
09501 85 08                               sta ObjectOffset
09503 60                        LoopCmdE: rts
09504 AC 2C 07                  BackColC: ldy AreaDataOffset         ;get first byte again
09507 B1 E7                               lda (AreaData),y
09509 29 F0                               and #%11110000             ;mask out low nybble and move high to low
0950B 4A                                  lsr
0950C 4A                                  lsr
0950D 4A                                  lsr
0950E 4A                                  lsr
0950F CD 26 07                            cmp CurrentColumnPos       ;is this where we're at?
09512 D0 DF                               bne LeavePar               ;if not, branch to leave
09514 AD 2C 07                  StrAObj:  lda AreaDataOffset         ;if so, load area obj offset and store in buffer
09517 9D 2D 07                            sta AreaObjOffsetBuffer,x
0951A 20 47 94                            jsr IncAreaObjOffset       ;do sub to increment to next object data
0951D A5 00                     RunAObj:  lda $00                    ;get stored value and add offset to it
0951F 18                                  clc                        ;then use the jump engine with current contents of A
09520 65 07                               adc $07
09522 20 F8 8C                            jsr JumpEngine
09525                           
09525 2B 98                      .dw VerticalPipe
09527 5A 96                      .dw AreaStyleObject
09529 7C 99                      .dw RowOfBricks
0952B 8C 99                      .dw RowOfSolidBlocks
0952D 40 99                      .dw RowOfCoins
0952F 9E 99                      .dw ColumnOfBricks
09531 A7 99                      .dw ColumnOfSolidBlocks
09533 2B 98                      .dw VerticalPipe
09535                           
09535 91 9A                      .dw Hole_Empty
09537 00 97                      .dw PulleyRopeObject
09539 C7 98                      .dw Bridge_High
0953B CA 98                      .dw Bridge_Middle
0953D CD 98                      .dw Bridge_Low
0953F A5 98                      .dw Hole_Water
09541 B6 98                      .dw QuestionBlockRow_High
09543 B9 98                      .dw QuestionBlockRow_Low
09545                           
09545 1E 99                      .dw EndlessRope
09547 25 99                      .dw BalancePlatRope
09549 4C 97                      .dw CastleObject
0954B 05 9A                      .dw StaircaseObject
0954D F1 97                      .dw ExitPipe
0954F E2 98                      .dw FlagBalls_Residual
09551 FD E5                      .dw UpsideDownPipe_High
09553 02 E6                      .dw UpsideDownPipe_Low
09555                           
09555 5E 9A                      .dw QuestionBlock
09557 5E 9A                      .dw QuestionBlock
09559 5E 9A                      .dw QuestionBlock
0955B 5E 9A                      .dw QuestionBlock
0955D 51 9A                      .dw Hidden1UpBlock
0955F 5E 9A                      .dw QuestionBlock
09561 5E 9A                      .dw QuestionBlock
09563 69 9A                      .dw BrickWithItem
09565 69 9A                      .dw BrickWithItem
09567 69 9A                      .dw BrickWithItem
09569 69 9A                      .dw BrickWithItem
0956B 64 9A                      .dw BrickWithCoins
0956D 69 9A                      .dw BrickWithItem
0956F B5 97                      .dw WaterPipe
09571 67 99                      .dw EmptyBlock
09573 21 9A                      .dw Jumpspring
09575                           
09575 C8 97                      .dw IntroPipe
09577 EC 98                      .dw FlagpoleObject
09579 57 99                      .dw AxeObj
0957B 5C 99                      .dw ChainObj
0957D 4F 99                      .dw CastleBridgeObj
0957F C0 95                      .dw ScrollLockObject_Warp
09581 27 96                      .dw ScrollLockObject
09583 27 96                      .dw ScrollLockObject
09585 45 96                      .dw AreaFrenzy
09587 45 96                      .dw AreaFrenzy
09589 45 96                      .dw AreaFrenzy
0958B 03 95                      .dw LoopCmdE
0958D 55 E7                      .dw WindOn                ;these two are in SM2DATA2 and SM2DATA4
0958F 59 E7                      .dw WindOff
09591                           
09591 93 95                      .dw AlterAreaAttributes
09593                           
09593                           ;-------------------------------------------------------------------------------------
09593                           ;(these apply to all area object subroutines in this section unless otherwise stated)
09593                           ;$00 - used to store offset used to find object code
09593                           ;$07 - starts with adder from area parser, used to store row offset
09593                           
09593                           AlterAreaAttributes:
09593 BC 2D 07                           ldy AreaObjOffsetBuffer,x ;load offset for level object data saved in buffer
09596 C8                                 iny                       ;load second byte
09597 B1 E7                              lda (AreaData),y
09599 48                                 pha                       ;save in stack for now
0959A 29 40                              and #%01000000
0959C D0 12                              bne Alter2                ;branch if d6 is set
0959E 68                                 pla
0959F 48                                 pha                       ;pull and push offset to copy to A
095A0 29 0F                              and #%00001111            ;mask out high nybble and store as
095A2 8D 27 07                           sta TerrainControl        ;new terrain height type bits
095A5 68                                 pla
095A6 29 30                              and #%00110000            ;pull and mask out all but d5 and d4
095A8 4A                                 lsr                       ;move bits to lower nybble and store
095A9 4A                                 lsr                       ;as new background scenery bits
095AA 4A                                 lsr
095AB 4A                                 lsr
095AC 8D 42 07                           sta BackgroundScenery     ;then leave
095AF 60                                 rts
095B0 68                        Alter2:  pla
095B1 29 07                              and #%00000111            ;mask out all but 3 LSB
095B3 C9 04                              cmp #$04                  ;if four or greater, set color control bits
095B5 90 05                              bcc SetFore               ;and nullify foreground scenery bits
095B7 8D 44 07                           sta BackgroundColorCtrl
095BA A9 00                              lda #$00
095BC 8D 41 07                  SetFore: sta ForegroundScenery     ;otherwise set new foreground scenery bits
095BF 60                                 rts
095C0                           
095C0                           ;--------------------------------
095C0                           
095C0                           ScrollLockObject_Warp:
095C0 AD FB 07                           lda HardWorldFlag        ;playing SMB1 levels?
095C3 F0 1E                              beq WarpsForSMB1Levels   ;yes, use alternate handler for warp zone control
095C5 AD 5F 07                           lda WorldNumber          ;if on worlds A-D, skip ahead to next part
095C8 C9 09                              cmp #WorldA
095CA B0 26                              bcs WarpWorldsAThruD     ;note d7 is set in all entries to prevent zero condition
095CC A2 83                              ldx #$83                 ;use base number for warp to world 2
095CE AD 5F 07                           lda WorldNumber          ;from happening in warp zone code elsewhere
095D1 D0 27                              bne WarpWorlds2Thru8     ;if not on world 1, branch to handle a different way
095D3 AC 4E 07                           ldy AreaType             ;check to see if on ground level type
095D6 88                                 dey                      ;branch if so to add one to the number
095D7 F0 06                              beq W1Warp2
095D9 AD 4F 07                           lda AreaAddrsLOffset     ;if on first underground level, branch to use base number
095DC F0 02                              beq W1Warp1
095DE E8                                 inx                      ;otherwise add two to the number and use it
095DF E8                        W1Warp2: inx
095E0 4C 1B 96                  W1Warp1: jmp BaseW
095E3                           
095E3                           WarpsForSMB1Levels:
095E3 A2 80                           ldx #$80                 ;use base number for warp to worlds 4-3-2
095E5 AD 5F 07                        lda WorldNumber          ;from happening in warp zone code elsewhere
095E8 F0 31                           beq BaseW                ;if on world 1, use 4-3-2 warp
095EA AC 4E 07                        ldy AreaType             ;otherwise check area type for ground area
095ED 88                              dey
095EE D0 2A                           bne W5Warp2              ;if not, use world 5 warp
095F0 F0 27                           beq W5Warp3              ;if found, use 8-7-6 warp
095F2                           
095F2                           WarpWorldsAThruD:
095F2 A9 8A                           lda #$8a                 ;use base number for worlds A-D
095F4 18                              clc
095F5 6D 5C 07                        adc LevelNumber          ;add level number itself to it
095F8 D0 22                           bne DumpWarpCtrl         ;then branch to use it
095FA                           
095FA                           WarpWorlds2Thru8:
095FA A2 86                           ldx #$86                 ;use base number for worlds 2-8
095FC AD 5F 07                        lda WorldNumber
095FF C9 02                           cmp #World3              ;branch if on world 3 to use
09601 F0 18                           beq BaseW
09603 E8                              inx                      ;otherwise add one to the number
09604 C9 04                           cmp #World5              ;if not on world 5, branch to add 3 more
09606 D0 10                           bne W678Warp
09608 AD 4F 07                        lda AreaAddrsLOffset
0960B C9 0B                           cmp #$0b                 ;if on the 12th ground area, branch to use
0960D F0 0C                           beq BaseW                ;(in normal map data this corresponds to world 5-1)
0960F AC 4E 07                        ldy AreaType             ;check to see if on ground level type
09612 88                              dey                      ;branch if so to add 2 more to the number
09613 F0 04                           beq W5Warp3
09615 4C 1A 96                        jmp W5Warp2              ;otherwise add 1 more
09618                           
09618 E8                        W678Warp: inx                  ;add 1, 2, or 3 to base number or use as-is
09619 E8                        W5Warp3:  inx                  ;depending on where branched
0961A E8                        W5Warp2:  inx
0961B 8A                        BaseW:    txa
0961C                           
0961C                           DumpWarpCtrl:
0961C 8D D6 06                        sta WarpZoneControl      ;set warp zone control
0961F 20 A4 87                        jsr WriteWarpZoneMessage
09622 A9 0D                           lda #$0d                 ;kill piranha plants
09624 20 30 96                        jsr KillEnemies
09627                           
09627                           ScrollLockObject:
09627 AD 23 07                        lda ScrollLock      ;invert scroll lock to turn it on
0962A 49 01                           eor #%00000001
0962C 8D 23 07                        sta ScrollLock
0962F 60                              rts
09630                           
09630                           ;--------------------------------
09630                           ;$00 - used to store enemy identifier in KillEnemies
09630                           
09630                           KillEnemies:
09630 85 00                                sta $00           ;store identifier here
09632 A9 00                                lda #$00
09634 A2 04                                ldx #$04          ;check for identifier in enemy object buffer
09636 B4 16                     KillELoop: ldy Enemy_ID,x
09638 C4 00                                cpy $00           ;if not found, branch
0963A D0 02                                bne NoKillE
0963C 95 0F                                sta Enemy_Flag,x  ;if found, deactivate enemy object flag
0963E CA                        NoKillE:   dex               ;do this until all slots are checked
0963F 10 F5                                bpl KillELoop
09641 60                                   rts
09642                           
09642                           ;--------------------------------
09642                           
09642                           FrenzyIDData:
09642 14 17 18                        .db FlyCheepCheepFrenzy, BBill_CCheep_Frenzy, Stop_Frenzy
09645                           
09645 A6 00                     AreaFrenzy:  ldx $00               ;use area object identifier bit as offset
09647 BD 3A 96                               lda FrenzyIDData-8,x  ;note that it starts at 8, thus weird address here
0964A A0 05                                  ldy #$05
0964C 88                        FreCompLoop: dey                   ;check regular slots of enemy object buffer
0964D 30 07                                  bmi ExitAFrenzy       ;if all slots checked and enemy object not found, branch to store
0964F D9 16 00                               cmp Enemy_ID,y    ;check for enemy object in buffer versus frenzy object
09652 D0 F8                                  bne FreCompLoop
09654 A9 00                                  lda #$00              ;if enemy object already present, nullify queue and leave
09656 8D CD 06                  ExitAFrenzy: sta EnemyFrenzyQueue  ;store enemy into frenzy queue
09659 60                                     rts
0965A                           
0965A                           
0965A                           ;--------------------------------
0965A                           ;$06 - used by CloudLedge to store length
0965A                           
0965A                           AreaStyleObject:
0965A AD 33 07                        lda AreaStyle        ;load level object style and jump to the right sub
0965D 20 F8 8C                        jsr JumpEngine 
09660 66 96                           .dw TreeLedge        ;also used for cloud bonus levels
09662 92 96                           .dw MushroomOrCloudLedge
09664 B7 99                           .dw BulletBillCannon
09666                           
09666                           TreeLedge:
09666 20 0F 9B                            jsr GetLrgObjAttrib     ;get row and length of green ledge
09669 BD 30 07                            lda AreaObjectLength,x  ;check length counter for expiration
0966C F0 1F                               beq EndTreeL   
0966E 10 11                               bpl MidTreeL
09670 98                                  tya
09671 9D 30 07                            sta AreaObjectLength,x  ;store lower nybble into buffer flag as length of ledge
09674 AD 25 07                            lda CurrentPageLoc
09677 0D 26 07                            ora CurrentColumnPos    ;are we at the start of the level?
0967A F0 05                               beq MidTreeL
0967C A9 16                               lda #$16                ;render start of tree ledge
0967E 4C F6 96                            jmp NoUnder
09681 A6 07                     MidTreeL: ldx $07
09683 A9 17                               lda #$17                ;render middle of tree ledge
09685 9D A1 06                            sta MetatileBuffer,x    ;note that this is also used if ledge position is
09688 A9 4C                               lda #$4c                ;at the start of level for continuous effect
0968A 4C F0 96                            jmp AllUnder            ;now render the part underneath
0968D A9 18                     EndTreeL: lda #$18                ;render end of tree ledge
0968F 4C F6 96                            jmp NoUnder
09692                           
09692                           MushroomOrCloudLedge:
09692 AD FB 07                            lda HardWorldFlag       ;are we playing 2J levels?
09695 F0 27                               beq MushroomLedge       ;no, use mushroom platforms
09697                           
09697                           ;note: This is the style utilized by world 8-3 and part of world 8-2, and not to
09697                           ;be confused with the cloud-type bonus levels full of coins found throughout the game.
09697                           CloudLedge:
09697 20 00 9B                            jsr ChkLrgObjLength        ;get cloud dimensions 
0969A 84 06                               sty $06                    ;store length here for now
0969C 90 0C                               bcc EndCloud
0969E BD 30 07                            lda AreaObjectLength,x     ;divide length by 2 and store elsewhere
096A1 4A                                  lsr
096A2 9D 36 07                            sta MushroomLedgeHalfLen,x
096A5 A9 8A                               lda #$8a                   ;render start of cloud
096A7 4C F6 96                            jmp NoUnder
096AA A9 8C                     EndCloud: lda #$8c                   ;if at the end, render end of cloud
096AC BC 30 07                            ldy AreaObjectLength,x
096AF F0 45                               beq NoUnder
096B1 BD 36 07                            lda MushroomLedgeHalfLen,x ;get divided length and store where length
096B4 85 06                               sta $06                    ;was stored originally
096B6 A6 07                               ldx $07
096B8 A9 8B                               lda #$8b
096BA 9D A1 06                            sta MetatileBuffer,x       ;render middle of cloud
096BD 60                                  rts
096BE                           
096BE                           MushroomLedge:
096BE 20 00 9B                            jsr ChkLrgObjLength        ;get shroom dimensions
096C1 84 06                               sty $06                    ;store length here for now
096C3 90 0C                               bcc EndMushL
096C5 BD 30 07                            lda AreaObjectLength,x     ;divide length by 2 and store elsewhere
096C8 4A                                  lsr
096C9 9D 36 07                            sta MushroomLedgeHalfLen,x
096CC A9 19                               lda #$19                   ;render start of mushroom
096CE 4C F6 96                            jmp NoUnder
096D1 A9 1B                     EndMushL: lda #$1b                   ;if at the end, render end of mushroom
096D3 BC 30 07                            ldy AreaObjectLength,x
096D6 F0 1E                               beq NoUnder
096D8 BD 36 07                            lda MushroomLedgeHalfLen,x ;get divided length and store where length
096DB 85 06                               sta $06                    ;was stored originally
096DD A6 07                               ldx $07
096DF A9 1A                               lda #$1a
096E1 9D A1 06                            sta MetatileBuffer,x       ;render middle of mushroom
096E4 C4 06                               cpy $06                    ;are we smack dab in the center?
096E6 D0 2C                               bne MushLExit              ;if not, branch to leave
096E8 E8                                  inx
096E9 A9 4F                               lda #$4f
096EB 9D A1 06                            sta MetatileBuffer,x       ;render stem top of mushroom underneath the middle
096EE A9 50                               lda #$50
096F0 E8                        AllUnder: inx
096F1 A0 0F                               ldy #$0f                   ;set $0f to render all way down
096F3 4C CD 9A                            jmp RenderUnderPart        ;now render the support of the tree ledge
096F6 A6 07                     NoUnder:  ldx $07                    ;load row of ledge
096F8 A0 00                               ldy #$00                   ;set 0 for no bottom on this part
096FA 4C CD 9A                            jmp RenderUnderPart
096FD                           
096FD                           ;--------------------------------
096FD                           
096FD                           ;tiles used by pulleys and rope object
096FD                           PulleyRopeMetatiles:
096FD 42 41 43                        .db $42, $41, $43
09700                           
09700                           PulleyRopeObject:
09700 20 00 9B                             jsr ChkLrgObjLength       ;get length of pulley/rope object
09703 A0 00                                ldy #$00                  ;initialize metatile offset
09705 B0 07                                bcs RenderPul             ;if starting, render left pulley
09707 C8                                   iny
09708 BD 30 07                             lda AreaObjectLength,x    ;if not at the end, render rope
0970B D0 01                                bne RenderPul
0970D C8                                   iny                       ;otherwise render right pulley
0970E B9 FD 96                  RenderPul: lda PulleyRopeMetatiles,y
09711 8D A1 06                             sta MetatileBuffer        ;render at the top of the screen
09714 60                        MushLExit: rts                       ;and leave
09715                           
09715                           ;--------------------------------
09715                           ;$06 - used to store upper limit of rows for CastleObject
09715                           
09715                           CastleMetatiles:
09715 00 45 45 45 00                  .db $00, $45, $45, $45, $00
0971A 00 48 47 46 00                  .db $00, $48, $47, $46, $00
0971F 45 49 49 49 45                  .db $45, $49, $49, $49, $45
09724 47 47 4A 47 47                  .db $47, $47, $4a, $47, $47
09729 47 47 4B 47 47                  .db $47, $47, $4b, $47, $47
0972E 49 49 49 49 49                  .db $49, $49, $49, $49, $49
09733 47 4A 47 4A 47                  .db $47, $4a, $47, $4a, $47
09738 47 4B 47 4B 47                  .db $47, $4b, $47, $4b, $47
0973D 47 47 47 47 47                  .db $47, $47, $47, $47, $47
09742 4A 47 4A 47 4A                  .db $4a, $47, $4a, $47, $4a
09747 4B 47 4B 47 4B                  .db $4b, $47, $4b, $47, $4b
0974C                           
0974C                           CastleObject:
0974C 20 0F 9B                              jsr GetLrgObjAttrib      ;save lower nybble as starting row
0974F 84 07                                 sty $07                  ;if starting row is above $0a, game will crash!!!
09751 A0 04                                 ldy #$04
09753 20 03 9B                              jsr ChkLrgObjFixedLength ;load length of castle if not already loaded
09756 8A                                    txa                  
09757 48                                    pha                      ;save obj buffer offset to stack
09758 BC 30 07                              ldy AreaObjectLength,x   ;use current length as offset for castle data
0975B A6 07                                 ldx $07                  ;begin at starting row
0975D A9 0B                                 lda #$0b
0975F 85 06                                 sta $06                  ;load upper limit of number of rows to print
09761 B9 15 97                  CRendLoop:  lda CastleMetatiles,y    ;load current byte using offset
09764 9D A1 06                              sta MetatileBuffer,x
09767 E8                                    inx                      ;store in buffer and increment buffer offset
09768 A5 06                                 lda $06
0976A F0 07                                 beq ChkCFloor            ;have we reached upper limit yet?
0976C C8                                    iny                      ;if not, increment column-wise
0976D C8                                    iny                      ;to byte in next row
0976E C8                                    iny
0976F C8                                    iny
09770 C8                                    iny
09771 C6 06                                 dec $06                  ;move closer to upper limit
09773 E0 0B                     ChkCFloor:  cpx #$0b                 ;have we reached the row just before floor?
09775 D0 EA                                 bne CRendLoop            ;if not, go back and do another row
09777 68                                    pla
09778 AA                                    tax                      ;get obj buffer offset from before
09779 AD 25 07                              lda CurrentPageLoc
0977C F0 36                                 beq ExitCastle           ;if we're at page 0, we do not need to do anything else
0977E BD 30 07                              lda AreaObjectLength,x   ;check length
09781 C9 01                                 cmp #$01                 ;if length almost about to expire, put brick at floor
09783 F0 2A                                 beq PlayerStop
09785 A4 07                                 ldy $07                  ;check starting row for tall castle ($00)
09787 D0 04                                 bne NotTall
09789 C9 03                                 cmp #$03                 ;if found, then check to see if we're at the second column
0978B F0 22                                 beq PlayerStop
0978D C9 02                     NotTall:    cmp #$02                 ;if not tall castle, check to see if we're at the third column
0978F D0 23                                 bne ExitCastle           ;if we aren't and the castle is tall, don't create flag yet
09791 20 1F 9B                              jsr GetAreaObjXPosition  ;otherwise, obtain and save horizontal pixel coordinate
09794 48                                    pha
09795 20 98 98                              jsr FindEmptyEnemySlot   ;find an empty place on the enemy object buffer
09798 68                                    pla
09799 95 87                                 sta Enemy_X_Position,x   ;then write horizontal coordinate for star flag
0979B AD 25 07                              lda CurrentPageLoc
0979E 95 6E                                 sta Enemy_PageLoc,x      ;set page location for star flag
097A0 A9 01                                 lda #$01
097A2 95 B6                                 sta Enemy_Y_HighPos,x    ;set vertical high byte
097A4 95 0F                                 sta Enemy_Flag,x         ;set flag for buffer
097A6 A9 90                                 lda #$90
097A8 95 CF                                 sta Enemy_Y_Position,x   ;set vertical coordinate
097AA A9 31                                 lda #StarFlagObject      ;set star flag value in buffer itself
097AC 95 16                                 sta Enemy_ID,x
097AE 60                                    rts
097AF A0 52                     PlayerStop: ldy #$52                 ;put brick at floor to stop player at end of level
097B1 8C AB 06                              sty MetatileBuffer+10    ;this is only done if we're on the second column
097B4 60                        ExitCastle: rts
097B5                           
097B5                           ;--------------------------------
097B5                           
097B5                           WaterPipe:
097B5 20 0F 9B                        jsr GetLrgObjAttrib     ;get row and lower nybble
097B8 BC 30 07                        ldy AreaObjectLength,x  ;get length (residual code, water pipe is 1 col thick)
097BB A6 07                           ldx $07                 ;get row
097BD A9 6F                           lda #$6f
097BF 9D A1 06                        sta MetatileBuffer,x    ;draw something here and below it
097C2 A9 70                           lda #$70
097C4 9D A2 06                        sta MetatileBuffer+1,x
097C7 60                              rts
097C8                           
097C8                           ;--------------------------------
097C8                           ;$05 - used to store length of vertical shaft in RenderSidewaysPipe
097C8                           ;$06 - used to store leftover horizontal length in RenderSidewaysPipe
097C8                           ; and vertical length in VerticalPipe and GetPipeHeight
097C8                           
097C8                           IntroPipe:
097C8 A0 03                                    ldy #$03                 ;check if length set, if not set, set it
097CA 20 03 9B                                 jsr ChkLrgObjFixedLength
097CD A0 0A                                    ldy #$0a                 ;set fixed value and render the sideways part
097CF 20 F9 97                                 jsr RenderSidewaysPipe
097D2 B0 10                                    bcs NoBlankP             ;if carry flag set, not time to draw vertical pipe part
097D4 A2 06                                    ldx #$06                 ;blank everything above the vertical pipe part
097D6 A9 00                     VPipeSectLoop: lda #$00                 ;all the way to the top of the screen
097D8 9D A1 06                                 sta MetatileBuffer,x     ;because otherwise it will look like exit pipe
097DB CA                                       dex
097DC 10 F8                                    bpl VPipeSectLoop
097DE B9 23 98                                 lda VerticalPipeData,y   ;draw the end of the vertical pipe part
097E1 8D A8 06                                 sta MetatileBuffer+7
097E4 60                        NoBlankP:      rts
097E5                           
097E5                           SidePipeShaftData:
097E5 15 14                           .db $15, $14  ;used to control whether or not vertical pipe shaft
097E7 00 00                           .db $00, $00  ;is drawn, and if so, controls the metatile number
097E9                           SidePipeTopPart:
097E9 15 1E                           .db $15, $1e  ;top part of sideways part of pipe
097EB 1D 1C                           .db $1d, $1c
097ED                           SidePipeBottomPart: 
097ED 15 21                           .db $15, $21  ;bottom part of sideways part of pipe
097EF 20 1F                           .db $20, $1f
097F1                           
097F1                           ExitPipe:
097F1 A0 03                           ldy #$03                 ;check if length set, if not set, set it
097F3 20 03 9B                        jsr ChkLrgObjFixedLength
097F6 20 0F 9B                        jsr GetLrgObjAttrib      ;get vertical length, then plow on through RenderSidewaysPipe
097F9                           
097F9                           RenderSidewaysPipe:
097F9 88                                      dey                       ;decrement twice to make room for shaft at bottom
097FA 88                                      dey                       ;and store here for now as vertical length
097FB 84 05                                   sty $05
097FD BC 30 07                                ldy AreaObjectLength,x    ;get length left over and store here
09800 84 06                                   sty $06
09802 A6 05                                   ldx $05                   ;get vertical length plus one, use as buffer offset
09804 E8                                      inx
09805 B9 E5 97                                lda SidePipeShaftData,y   ;check for value $00 based on horizontal offset
09808 C9 00                                   cmp #$00
0980A F0 08                                   beq DrawSidePart          ;if found, do not draw the vertical pipe shaft
0980C A2 00                                   ldx #$00
0980E A4 05                                   ldy $05                   ;init buffer offset and get vertical length
09810 20 CD 9A                                jsr RenderUnderPart       ;and render vertical shaft using tile number in A
09813 18                                      clc                       ;clear carry flag to be used by IntroPipe
09814 A4 06                     DrawSidePart: ldy $06                   ;render side pipe part at the bottom
09816 B9 E9 97                                lda SidePipeTopPart,y
09819 9D A1 06                                sta MetatileBuffer,x      ;note that the pipe parts are stored
0981C B9 ED 97                                lda SidePipeBottomPart,y  ;backwards horizontally
0981F 9D A2 06                                sta MetatileBuffer+1,x
09822 60                                      rts
09823                           
09823                           VerticalPipeData:
09823 11 10                           .db $11, $10 ;used by pipes that lead somewhere
09825 15 14                           .db $15, $14
09827 13 12                           .db $13, $12 ;used by decoration pipes
09829 15 14                           .db $15, $14
0982B                           
0982B                           VerticalPipe:
0982B 20 68 98                            jsr GetPipeHeight
0982E A5 00                               lda $00                  ;check to see if value was nullified earlier
09830 F0 04                               beq WarpPipe             ;(if d3, the usage control bit of second byte, was set)
09832 C8                                  iny
09833 C8                                  iny
09834 C8                                  iny
09835 C8                                  iny                      ;add four if usage control bit was not set
09836 98                        WarpPipe: tya                      ;save value in stack
09837 48                                  pha
09838 AD FB 07                            lda HardWorldFlag        ;are we playing 2J levels?
0983B D0 08                               bne PutPlant             ;if we are, always try to add piranha plant
0983D AD 60 07                            lda AreaNumber           ;otherwise check if we're in SMB1 world 1-1
09840 0D 5F 07                            ora WorldNumber          ;if at world 1-1, do not add piranha plant ever
09843 F0 0F                               beq DrawPipe
09845 BC 30 07                  PutPlant: ldy AreaObjectLength,x   ;if on second column of pipe, branch
09848 F0 0A                               beq DrawPipe             ;(because we only need to do this once)
0984A 20 98 98                            jsr FindEmptyEnemySlot   ;check for an empty moving data buffer space
0984D B0 05                               bcs DrawPipe             ;if not found, too many enemies, thus skip
0984F A9 0D                               lda #PiranhaPlant
09851 20 79 98                            jsr SetupPiranhaPlant
09854                           
09854 68                        DrawPipe: pla                      ;get value saved earlier and use as Y
09855 A8                                  tay
09856 A6 07                               ldx $07                  ;get buffer offset
09858 B9 23 98                            lda VerticalPipeData,y   ;draw the appropriate pipe with the Y we loaded earlier
0985B 9D A1 06                            sta MetatileBuffer,x     ;render the top of the pipe
0985E E8                                  inx
0985F B9 25 98                            lda VerticalPipeData+2,y ;render the rest of the pipe
09862 A4 06                               ldy $06                  ;subtract one from length and render the part underneath
09864 88                                  dey
09865 4C CD 9A                            jmp RenderUnderPart
09868                           
09868                           GetPipeHeight:
09868 A0 01                           ldy #$01       ;check for length loaded, if not, load
0986A 20 03 9B                        jsr ChkLrgObjFixedLength ;pipe length of 2 (horizontal)
0986D 20 0F 9B                        jsr GetLrgObjAttrib
09870 98                              tya            ;get saved lower nybble as height
09871 29 07                           and #$07       ;save only the three lower bits as
09873 85 06                           sta $06        ;vertical length, then load Y with
09875 BC 30 07                        ldy AreaObjectLength,x    ;length left over
09878 60                              rts
09879                           
09879                           SetupPiranhaPlant:
09879 95 16                               sta Enemy_ID,x
0987B 20 1F 9B                            jsr GetAreaObjXPosition  ;get horizontal pixel coordinate
0987E 18                                  clc
0987F 69 08                               adc #$08                 ;add eight to put the piranha plant in the center
09881 95 87                               sta Enemy_X_Position,x   ;store as enemy's horizontal coordinate
09883 AD 25 07                            lda CurrentPageLoc       ;add carry to current page number
09886 69 00                               adc #$00
09888 95 6E                               sta Enemy_PageLoc,x      ;store as enemy's page coordinate
0988A A9 01                               lda #$01
0988C 95 B6                               sta Enemy_Y_HighPos,x
0988E 95 0F                               sta Enemy_Flag,x         ;activate enemy flag
09890 20 27 9B                            jsr GetAreaObjYPosition  ;get piranha plant's vertical coordinate and store here
09893 95 CF                               sta Enemy_Y_Position,x
09895 4C 99 B5                            jmp InitPiranhaPlant
09898                           
09898                           FindEmptyEnemySlot:
09898 A2 00                                   ldx #$00          ;start at first enemy slot
0989A 18                        EmptyChkLoop: clc               ;clear carry flag by default
0989B B5 0F                                   lda Enemy_Flag,x  ;check enemy buffer for nonzero
0989D F0 05                                   beq ExitEmptyChk  ;if zero, leave
0989F E8                                      inx
098A0 E0 05                                   cpx #$05          ;if nonzero, check next value
098A2 D0 F6                                   bne EmptyChkLoop
098A4 60                        ExitEmptyChk: rts               ;if all values nonzero, carry flag is set
098A5                           
098A5                           ;--------------------------------
098A5                           
098A5                           Hole_Water:
098A5 20 00 9B                        jsr ChkLrgObjLength   ;get low nybble and save as length
098A8 A9 86                           lda #$86              ;render waves
098AA 8D AB 06                        sta MetatileBuffer+10
098AD A2 0B                           ldx #$0b
098AF A0 01                           ldy #$01              ;now render the water underneath
098B1 A9 87                           lda #$87
098B3 4C CD 9A                        jmp RenderUnderPart
098B6                           
098B6                           QuestionBlockRow_High:
098B6 A9 03                           lda #$03              ;start on the fourth row
098B8 2C                              .db $2c               ;BIT instruction opcode
098B9                           
098B9                           QuestionBlockRow_Low:
098B9 A9 07                           lda #$07             ;start on the eighth row
098BB 48                              pha                  ;save whatever row to the stack for now
098BC 20 00 9B                        jsr ChkLrgObjLength  ;get low nybble and save as length
098BF 68                              pla
098C0 AA                              tax                  ;render question boxes with coins
098C1 A9 C0                           lda #$c0
098C3 9D A1 06                        sta MetatileBuffer,x
098C6 60                              rts
098C7                           
098C7                           ;--------------------------------
098C7                           
098C7                           Bridge_High:
098C7 A9 06                           lda #$06  ;start on the seventh row from top of screen
098C9 2C                              .db $2c   ;BIT instruction opcode
098CA                           
098CA                           Bridge_Middle:
098CA A9 07                           lda #$07  ;start on the eighth row
098CC 2C                              .db $2c   ;BIT instruction opcode
098CD                           
098CD                           Bridge_Low:
098CD A9 09                           lda #$09             ;start on the tenth row
098CF 48                              pha                  ;save whatever row to the stack for now
098D0 20 00 9B                        jsr ChkLrgObjLength  ;get low nybble and save as length
098D3 68                              pla
098D4 AA                              tax                  ;render bridge railing
098D5 A9 0B                           lda #$0b
098D7 9D A1 06                        sta MetatileBuffer,x
098DA E8                              inx
098DB A0 00                           ldy #$00             ;now render the bridge itself
098DD A9 66                           lda #$66
098DF 4C CD 9A                        jmp RenderUnderPart
098E2                           
098E2                           ;--------------------------------
098E2                           
098E2                           FlagBalls_Residual:
098E2 20 0F 9B                        jsr GetLrgObjAttrib  ;get low nybble from object byte
098E5 A2 02                           ldx #$02             ;render flag balls on third row from top
098E7 A9 71                           lda #$71             ;of screen downwards based on low nybble
098E9 4C CD 9A                        jmp RenderUnderPart
098EC                           
098EC                           ;--------------------------------
098EC                           
098EC                           FlagpoleObject:
098EC A9 24                           lda #$24                 ;render flagpole ball on top
098EE 8D A1 06                        sta MetatileBuffer
098F1 A2 01                           ldx #$01                 ;now render the flagpole shaft
098F3 A0 08                           ldy #$08
098F5 A9 25                           lda #$25
098F7 20 CD 9A                        jsr RenderUnderPart
098FA A9 64                           lda #$64                 ;render solid block at the bottom
098FC 8D AB 06                        sta MetatileBuffer+10
098FF 20 1F 9B                        jsr GetAreaObjXPosition
09902 38                              sec                      ;get pixel coordinate of where the flagpole is,
09903 E9 08                           sbc #$08                 ;subtract eight pixels and use as horizontal
09905 85 8C                           sta Enemy_X_Position+5   ;coordinate for the flag
09907 AD 25 07                        lda CurrentPageLoc
0990A E9 00                           sbc #$00                 ;subtract borrow from page location and use as
0990C 85 73                           sta Enemy_PageLoc+5      ;page location for the flag
0990E A9 30                           lda #$30
09910 85 D4                           sta Enemy_Y_Position+5   ;set vertical coordinate for flag
09912 A9 B0                           lda #$b0
09914 8D 0D 01                        sta FlagpoleFNum_Y_Pos   ;set initial vertical coordinate for flagpole's floatey number
09917 A9 30                           lda #FlagpoleFlagObject
09919 85 1B                           sta Enemy_ID+5           ;set flag identifier, note that identifier and coordinates
0991B E6 14                           inc Enemy_Flag+5         ;use last space in enemy object buffer
0991D 60                              rts
0991E                           
0991E                           ;--------------------------------
0991E                           
0991E                           EndlessRope:
0991E A2 00                           ldx #$00       ;render rope from the top to the bottom of screen
09920 A0 0F                           ldy #$0f
09922 4C 37 99                        jmp DrawRope
09925                           
09925                           BalancePlatRope:
09925 8A                                  txa                 ;save object buffer offset for now
09926 48                                  pha
09927 A2 01                               ldx #$01            ;blank out all from second row to the bottom
09929 A0 0F                               ldy #$0f            ;with blank used for balance platform rope
0992B A9 44                               lda #$44
0992D 20 CD 9A                            jsr RenderUnderPart
09930 68                                  pla                 ;get back object buffer offset
09931 AA                                  tax
09932 20 0F 9B                            jsr GetLrgObjAttrib ;get vertical length from lower nybble
09935 A2 01                               ldx #$01
09937 A9 40                     DrawRope: lda #$40            ;render the actual rope
09939 4C CD 9A                            jmp RenderUnderPart
0993C                           
0993C                           ;--------------------------------
0993C                           
0993C                           CoinMetatileData:
0993C C4 C3 C3 C3                     .db $c4, $c3, $c3, $c3
09940                           
09940                           RowOfCoins:
09940 AC 4E 07                        ldy AreaType            ;get area type
09943 B9 3C 99                        lda CoinMetatileData,y  ;load appropriate coin metatile
09946 4C 92 99                        jmp GetRow
09949                           
09949                           ;--------------------------------
09949                           
09949                           C_ObjectRow:
09949 06 07 08                        .db $06, $07, $08
0994C                           
0994C                           C_ObjectMetatile:
0994C C6 0C 89                        .db $c6, $0c, $89
0994F                           
0994F                           CastleBridgeObj:
0994F A0 0C                           ldy #$0c                  ;load length of 13 columns
09951 20 03 9B                        jsr ChkLrgObjFixedLength
09954 4C 5C 99                        jmp ChainObj
09957                           
09957                           AxeObj:
09957 A9 08                           lda #$08                  ;load bowser's palette into sprite portion of palette
09959 8D 73 07                        sta VRAM_Buffer_AddrCtrl
0995C                           
0995C                           ChainObj:
0995C A4 00                           ldy $00                   ;get value loaded earlier from decoder
0995E BE 47 99                        ldx C_ObjectRow-2,y       ;get appropriate row and metatile for object
09961 B9 4A 99                        lda C_ObjectMetatile-2,y
09964 4C 6E 99                        jmp ColObj
09967                           
09967                           EmptyBlock:
09967 20 0F 9B                          jsr GetLrgObjAttrib  ;get row location
0996A A6 07                             ldx $07
0996C A9 C5                             lda #$c5
0996E A0 00                     ColObj: ldy #$00             ;column length of 1
09970 4C CD 9A                          jmp RenderUnderPart
09973                           
09973                           ;--------------------------------
09973                           
09973                           SolidBlockMetatiles:
09973 6C 64 64 65                     .db $6c, $64, $64, $65
09977                           
09977                           BrickMetatiles:
09977 22 51 52 52                     .db $22, $51, $52, $52
0997B 88                              .db $88 ;used only by row of bricks object
0997C                           
0997C                           RowOfBricks:
0997C AC 4E 07                              ldy AreaType           ;load area type obtained from area offset pointer
0997F AD 43 07                              lda CloudTypeOverride  ;check for cloud type override
09982 F0 02                                 beq DrawBricks
09984 A0 04                                 ldy #$04               ;if cloud type, override area type
09986 B9 77 99                  DrawBricks: lda BrickMetatiles,y   ;get appropriate metatile
09989 4C 92 99                              jmp GetRow             ;and go render it
0998C                           
0998C                           RowOfSolidBlocks:
0998C AC 4E 07                           ldy AreaType               ;load area type obtained from area offset pointer
0998F B9 73 99                           lda SolidBlockMetatiles,y  ;get metatile
09992 48                        GetRow:  pha                        ;store metatile here
09993 20 00 9B                           jsr ChkLrgObjLength        ;get row number, load length
09996 A6 07                     DrawRow: ldx $07
09998 A0 00                              ldy #$00                   ;set vertical height of 1
0999A 68                                 pla
0999B 4C CD 9A                           jmp RenderUnderPart        ;render object
0999E                           
0999E                           ColumnOfBricks:
0999E AC 4E 07                        ldy AreaType          ;load area type obtained from area offset
099A1 B9 77 99                        lda BrickMetatiles,y  ;get metatile (no cloud override as for row)
099A4 4C AD 99                        jmp GetRow2
099A7                           
099A7                           ColumnOfSolidBlocks:
099A7 AC 4E 07                           ldy AreaType               ;load area type obtained from area offset
099AA B9 73 99                           lda SolidBlockMetatiles,y  ;get metatile
099AD 48                        GetRow2: pha                        ;save metatile to stack for now
099AE 20 0F 9B                           jsr GetLrgObjAttrib        ;get length and row
099B1 68                                 pla                        ;restore metatile
099B2 A6 07                              ldx $07                    ;get starting row
099B4 4C CD 9A                           jmp RenderUnderPart        ;now render the column
099B7                           
099B7                           ;--------------------------------
099B7                           
099B7                           BulletBillCannon:
099B7 20 0F 9B                               jsr GetLrgObjAttrib      ;get row and length of bullet bill cannon
099BA A6 07                                  ldx $07                  ;start at first row
099BC A9 67                                  lda #$67                 ;render bullet bill cannon
099BE 9D A1 06                               sta MetatileBuffer,x
099C1 E8                                     inx
099C2 88                                     dey                      ;done yet?
099C3 30 0E                                  bmi SetupCannon
099C5 A9 68                                  lda #$68                 ;if not, render middle part
099C7 9D A1 06                               sta MetatileBuffer,x
099CA E8                                     inx
099CB 88                                     dey                      ;done yet?
099CC 30 05                                  bmi SetupCannon
099CE A9 69                                  lda #$69                 ;if not, render bottom until length expires
099D0 20 CD 9A                               jsr RenderUnderPart
099D3 AE 6A 04                  SetupCannon: ldx Cannon_Offset        ;get offset for data used by cannons and whirlpools
099D6 20 27 9B                               jsr GetAreaObjYPosition  ;get proper vertical coordinate for cannon
099D9 9D 77 04                               sta Cannon_Y_Position,x  ;and store it here
099DC AD 25 07                               lda CurrentPageLoc
099DF 9D 6B 04                               sta Cannon_PageLoc,x     ;store page number for cannon here
099E2 20 1F 9B                               jsr GetAreaObjXPosition  ;get proper horizontal coordinate for cannon
099E5 9D 71 04                               sta Cannon_X_Position,x  ;and store it here
099E8 E8                                     inx
099E9 E0 06                                  cpx #$06                 ;increment and check offset
099EB 90 02                                  bcc StrCOffset           ;if not yet reached sixth cannon, branch to save offset
099ED A2 00                                  ldx #$00                 ;otherwise initialize it
099EF 8E 6A 04                  StrCOffset:  stx Cannon_Offset        ;save new offset and leave
099F2 60                                     rts
099F3                           
099F3                           ;--------------------------------
099F3                           
099F3                           StaircaseHeightData:
099F3 07 07 06 05 04 03 02 01..       .db $07, $07, $06, $05, $04, $03, $02, $01, $00
099FC                           
099FC                           StaircaseRowData:
099FC 03 03 04 05 06 07 08 09..       .db $03, $03, $04, $05, $06, $07, $08, $09, $0a
09A05                           
09A05                           StaircaseObject:
09A05 20 00 9B                             jsr ChkLrgObjLength       ;check and load length
09A08 90 05                                bcc NextStair             ;if length already loaded, skip init part
09A0A A9 09                                lda #$09                  ;start past the end for the bottom
09A0C 8D 34 07                             sta StaircaseControl      ;of the staircase
09A0F CE 34 07                  NextStair: dec StaircaseControl      ;move onto next step (or first if starting)
09A12 AC 34 07                             ldy StaircaseControl
09A15 BE FC 99                             ldx StaircaseRowData,y    ;get starting row and height to render
09A18 B9 F3 99                             lda StaircaseHeightData,y
09A1B A8                                   tay
09A1C A9 64                                lda #$64                  ;now render solid block staircase
09A1E 4C CD 9A                             jmp RenderUnderPart
09A21                           
09A21                           ;--------------------------------
09A21                           
09A21                           Jumpspring:
09A21 20 0F 9B                        jsr GetLrgObjAttrib
09A24 20 98 98                        jsr FindEmptyEnemySlot      ;find empty space in enemy object buffer
09A27 B0 27                           bcs NoJs                    ;if none, cancel (potentially problematic!)
09A29 20 1F 9B                        jsr GetAreaObjXPosition     ;get horizontal coordinate for jumpspring
09A2C 95 87                           sta Enemy_X_Position,x      ;and store
09A2E AD 25 07                        lda CurrentPageLoc          ;store page location of jumpspring
09A31 95 6E                           sta Enemy_PageLoc,x
09A33 20 27 9B                        jsr GetAreaObjYPosition     ;get vertical coordinate for jumpspring
09A36 95 CF                           sta Enemy_Y_Position,x      ;and store
09A38 95 58                           sta Jumpspring_FixedYPos,x  ;store as permanent coordinate here
09A3A A9 32                           lda #JumpspringObject
09A3C 95 16                           sta Enemy_ID,x              ;write jumpspring object to enemy object buffer
09A3E A0 01                           ldy #$01
09A40 94 B6                           sty Enemy_Y_HighPos,x       ;store vertical high byte
09A42 F6 0F                           inc Enemy_Flag,x            ;set flag for enemy object buffer
09A44 A6 07                           ldx $07
09A46 A9 6A                           lda #$6a                    ;draw metatiles in two rows where jumpspring is
09A48 9D A1 06                        sta MetatileBuffer,x
09A4B A9 6B                           lda #$6b
09A4D 9D A2 06                        sta MetatileBuffer+1,x
09A50 60                        NoJs: rts
09A51                           
09A51                           ;--------------------------------
09A51                           ;$07 - used to save ID of brick object
09A51                           
09A51                           Hidden1UpBlock:
09A51 AD 5D 07                        lda Hidden1UpFlag  ;if flag not set, do not render object
09A54 F0 36                           beq ExitDecBlock
09A56 A9 00                           lda #$00           ;if set, init for the next one
09A58 8D 5D 07                        sta Hidden1UpFlag
09A5B 4C 69 9A                        jmp BrickWithItem  ;jump to code shared with unbreakable bricks
09A5E                           
09A5E                           QuestionBlock:
09A5E 20 86 9A                        jsr GetAreaObjectID ;get value from level decoder routine
09A61 4C 7C 9A                        jmp DrawQBlk        ;go to render it
09A64                           
09A64                           BrickWithCoins:
09A64 A9 00                           lda #$00                 ;initialize multi-coin timer flag
09A66 8D BC 06                        sta BrickCoinTimerFlag
09A69                           
09A69                           BrickWithItem:
09A69 20 86 9A                            jsr GetAreaObjectID         ;save area object ID
09A6C 84 07                               sty $07              
09A6E A9 00                               lda #$00                    ;load default adder for bricks with lines
09A70 AC 4E 07                            ldy AreaType                ;check level type for ground level
09A73 88                                  dey
09A74 F0 02                               beq BWithL                  ;if ground type, do not start with 6
09A76 A9 06                               lda #$06                    ;otherwise use adder for bricks without lines
09A78 18                        BWithL:   clc                         ;add object ID to adder
09A79 65 07                               adc $07
09A7B A8                                  tay                         ;use as offset for metatile
09A7C B9 04 AB                  DrawQBlk: lda BrickQBlockMetatiles,y  ;get appropriate metatile for brick (question block
09A7F 48                                  pha                         ;if branched to here from question block routine)
09A80 20 0F 9B                            jsr GetLrgObjAttrib         ;get row from location byte
09A83 4C 96 99                            jmp DrawRow                 ;now render the object
09A86                           
09A86                           GetAreaObjectID:
09A86 A5 00                                   lda $00    ;get value saved from area parser routine
09A88 38                                      sec
09A89 E9 00                                   sbc #$00   ;possibly residual code
09A8B A8                                      tay        ;save to Y
09A8C 60                        ExitDecBlock: rts
09A8D                           
09A8D                           ;--------------------------------
09A8D                           
09A8D                           HoleMetatiles:
09A8D 87 00 00 00                     .db $87, $00, $00, $00
09A91                           
09A91                           Hole_Empty:
09A91 20 00 9B                              jsr ChkLrgObjLength          ;get lower nybble and save as length
09A94 90 2D                                 bcc NoWhirlP                 ;skip this part if length already loaded
09A96 AD 4E 07                              lda AreaType                 ;check for water type level
09A99 D0 28                                 bne NoWhirlP                 ;if not water type, skip this part
09A9B AE 6A 04                              ldx Whirlpool_Offset         ;get offset for data used by cannons and whirlpools
09A9E 20 1F 9B                              jsr GetAreaObjXPosition      ;get proper vertical coordinate of where we're at
09AA1 38                                    sec
09AA2 E9 10                                 sbc #$10                     ;subtract 16 pixels
09AA4 9D 71 04                              sta Whirlpool_LeftExtent,x   ;store as left extent of whirlpool
09AA7 AD 25 07                              lda CurrentPageLoc           ;get page location of where we're at
09AAA E9 00                                 sbc #$00                     ;subtract borrow
09AAC 9D 6B 04                              sta Whirlpool_PageLoc,x      ;save as page location of whirlpool
09AAF C8                                    iny
09AB0 C8                                    iny                          ;increment length by 2
09AB1 98                                    tya
09AB2 0A                                    asl                          ;multiply by 16 to get size of whirlpool
09AB3 0A                                    asl                          ;note that whirlpool will always be
09AB4 0A                                    asl                          ;two blocks bigger than actual size of hole
09AB5 0A                                    asl                          ;and extend one block beyond each edge
09AB6 9D 77 04                              sta Whirlpool_Length,x       ;save size of whirlpool here
09AB9 E8                                    inx
09ABA E0 05                                 cpx #$05                     ;increment and check offset
09ABC 90 02                                 bcc StrWOffset               ;if not yet reached fifth whirlpool, branch to save offset
09ABE A2 00                                 ldx #$00                     ;otherwise initialize it
09AC0 8E 6A 04                  StrWOffset: stx Whirlpool_Offset         ;save new offset here
09AC3 AE 4E 07                  NoWhirlP:   ldx AreaType                 ;get appropriate metatile, then
09AC6 BD 8D 9A                              lda HoleMetatiles,x          ;render the hole proper
09AC9 A2 08                                 ldx #$08
09ACB A0 0F                                 ldy #$0f                     ;start at ninth row and go to bottom, run RenderUnderPart
09ACD                           
09ACD                           ;--------------------------------
09ACD                           
09ACD                           RenderUnderPart:
09ACD 8C 35 07                               sty AreaObjectHeight  ;store vertical length to render
09AD0 BC A1 06                               ldy MetatileBuffer,x  ;check current spot to see if there's something
09AD3 F0 1C                                  beq DrawThisRow       ;we need to keep, if nothing, go ahead
09AD5 C0 17                                  cpy #$17
09AD7 F0 1B                                  beq WaitOneRow        ;if middle part (tree ledge), wait until next row
09AD9 C0 1A                                  cpy #$1a
09ADB F0 17                                  beq WaitOneRow        ;if middle part (mushroom ledge), wait until next row
09ADD C0 8B                                  cpy #$8b
09ADF F0 13                                  beq WaitOneRow        ;if middle part (cloud ledge), wait until next row
09AE1 C0 C0                                  cpy #$c0
09AE3 F0 0C                                  beq DrawThisRow       ;if question block w/ coin, overwrite
09AE5 C0 C0                                  cpy #$c0
09AE7 B0 0B                                  bcs WaitOneRow        ;if any other metatile with palette 3, wait until next row
09AE9 C0 6D                                  cpy #$6d
09AEB D0 04                                  bne DrawThisRow       ;if cracked rock terrain, overwrite
09AED C9 50                                  cmp #$50
09AEF F0 03                                  beq WaitOneRow        ;if stem top of mushroom, wait
09AF1 9D A1 06                  DrawThisRow: sta MetatileBuffer,x  ;render contents of A from routine that called this
09AF4 E8                        WaitOneRow:  inx
09AF5 E0 0D                                  cpx #$0d              ;stop rendering if we're at the bottom of the screen
09AF7 B0 06                                  bcs ExitUPartR
09AF9 AC 35 07                               ldy AreaObjectHeight  ;decrement, and stop rendering if there is no more length
09AFC 88                                     dey
09AFD 10 CE                                  bpl RenderUnderPart
09AFF 60                        ExitUPartR:  rts
09B00                           
09B00                           
09B00                           ChkLrgObjLength:
09B00 20 0F 9B                          jsr GetLrgObjAttrib     ;get row location and size (length if branched to from here)
09B03                           
09B03                           ChkLrgObjFixedLength:
09B03 BD 30 07                          lda AreaObjectLength,x  ;check for set length counter
09B06 18                                clc                     ;clear carry flag for not just starting
09B07 10 05                             bpl LenSet              ;if counter not set, load it, otherwise leave alone
09B09 98                                tya                     ;save length into length counter
09B0A 9D 30 07                          sta AreaObjectLength,x
09B0D 38                                sec                     ;set carry flag if just starting
09B0E 60                        LenSet: rts
09B0F                           
09B0F                           GetLrgObjAttrib:
09B0F BC 2D 07                        ldy AreaObjOffsetBuffer,x ;get offset saved from area obj decoding routine
09B12 B1 E7                           lda (AreaData),y          ;get first byte of level object
09B14 29 0F                           and #%00001111
09B16 85 07                           sta $07                   ;save row location
09B18 C8                              iny
09B19 B1 E7                           lda (AreaData),y          ;get next byte, save lower nybble (length or height)
09B1B 29 0F                           and #%00001111            ;as Y, then leave
09B1D A8                              tay
09B1E 60                              rts
09B1F                           
09B1F                           ;--------------------------------
09B1F                           
09B1F                           GetAreaObjXPosition:
09B1F AD 26 07                        lda CurrentColumnPos    ;multiply current offset where we're at by 16
09B22 0A                              asl                     ;to obtain horizontal pixel coordinate
09B23 0A                              asl
09B24 0A                              asl
09B25 0A                              asl
09B26 60                              rts
09B27                           
09B27                           ;--------------------------------
09B27                           
09B27                           GetAreaObjYPosition:
09B27 A5 07                           lda $07  ;multiply value by 16
09B29 0A                              asl
09B2A 0A                              asl      ;this will give us the proper vertical pixel coordinate
09B2B 0A                              asl
09B2C 0A                              asl
09B2D 18                              clc
09B2E 69 20                           adc #32  ;add 32 pixels for the status bar
09B30 60                              rts
09B31                           
09B31                           ;-------------------------------------------------------------------------------------
09B31                           ;$06-$07 - used to store block buffer address used as indirect
09B31                           
09B31                           BlockBufferAddr:
09B31 00 D0                           .db <Block_Buffer_1, <Block_Buffer_2
09B33 05 05                           .db >Block_Buffer_1, >Block_Buffer_2
09B35                           
09B35                           GetBlockBufferAddr:
09B35 48                              pha                      ;take value of A, save
09B36 4A                              lsr                      ;move high nybble to low
09B37 4A                              lsr
09B38 4A                              lsr
09B39 4A                              lsr
09B3A A8                              tay                      ;use nybble as pointer to high byte
09B3B B9 33 9B                        lda BlockBufferAddr+2,y  ;of indirect here
09B3E 85 07                           sta $07
09B40 68                              pla
09B41 29 0F                           and #%00001111           ;pull from stack, mask out high nybble
09B43 18                              clc
09B44 79 31 9B                        adc BlockBufferAddr,y    ;add to low byte
09B47 85 06                           sta $06                  ;store here and leave
09B49 60                              rts
09B4A                           
09B4A                           ;-------------------------------------------------------------------------------------
09B4A                           
09B4A                           GameModeSubs:
09B4A AD 72 07                        lda OperMode_Task
09B4D 20 F8 8C                        jsr JumpEngine
09B50                           
09B50 2C E2                           .dw GameModeDiskRoutines
09B52 B2 8E                           .dw InitializeArea
09B54 94 84                           .dw ScreenRoutines
09B56 43 8F                           .dw SecondaryGameSetup
09B58 5A 9B                           .dw GameCoreRoutine
09B5A                           
09B5A                           GameCoreRoutine:
09B5A 20 B5 9C                        jsr GameRoutines           ;execute one of many possible subs
09B5D AD 72 07                        lda OperMode_Task          ;check major task of operating mode
09B60 C9 04                           cmp #$04                   ;if we are supposed to be here,
09B62 B0 01                           bcs GameEngine             ;branch to the game engine itself
09B64 60                              rts
09B65                           
09B65                           GameEngine:
09B65 20 DF A2                                jsr ProcFireball_Bubble    ;process fireballs and air bubbles
09B68 A2 00                                   ldx #$00
09B6A 86 08                     ProcELoop:    stx ObjectOffset           ;put incremented offset in X as enemy object offset
09B6C 20 68 AD                                jsr EnemiesAndLoopsCore    ;process enemy objects
09B6F 20 E0 83                                jsr FloateyNumbersRoutine  ;process floatey numbers
09B72 E8                                      inx
09B73 E0 06                                   cpx #$06                   ;do these two subroutines until the whole buffer is done
09B75 D0 F3                                   bne ProcELoop
09B77 20 8D E0                                jsr GetPlayerOffscreenBits ;get offscreen bits for player object
09B7A 20 37 E0                                jsr RelativePlayerPosition ;get relative coordinates for player object
09B7D 20 EC DD                                jsr PlayerGfxHandler       ;draw the player
09B80 20 F5 AB                                jsr BlockObjMT_Updater     ;replace block objects with metatiles if necessary
09B83 A2 01                                   ldx #$01
09B85 86 08                                   stx ObjectOffset           ;set offset for second
09B87 20 91 AB                                jsr BlockObjectsCore       ;process second block object
09B8A CA                                      dex
09B8B 86 08                                   stx ObjectOffset           ;set offset for first
09B8D 20 91 AB                                jsr BlockObjectsCore       ;process first block object
09B90 20 B5 A8                                jsr MiscObjectsCore        ;process misc objects (hammer, jumping coins)
09B93 20 DB A6                                jsr ProcessCannons         ;process bullet bill cannons
09B96 20 70 A4                                jsr ProcessWhirlpools      ;process whirlpools
09B99 20 0D A5                                jsr FlagpoleRoutine        ;process the flagpole
09B9C 20 0A A4                                jsr RunGameTimer           ;count down the game timer
09B9F 20 11 89                                jsr ColorRotation          ;cycle one of the background colors
09BA2 AD F7 07                                lda FileListNumber
09BA5 F0 03                                   beq NoWind                 ;if in SMB1 levels or 2J worlds 1-4, skip ahead
09BA7 20 E7 E6                                jsr SimulateWind           ;otherwise, simulate wind where needed
09BAA A5 B5                     NoWind:       lda Player_Y_HighPos
09BAC C9 02                                   cmp #$02                   ;if player is below the screen, don't bother with the music
09BAE 10 11                                   bpl NoChgMus
09BB0 AD 9F 07                                lda StarInvincibleTimer    ;if star mario invincibility timer at zero,
09BB3 F0 1E                                   beq ClrPlrPal              ;skip this part
09BB5 C9 04                                   cmp #$04
09BB7 D0 08                                   bne NoChgMus               ;if not yet at a certain point, continue
09BB9 AD 7F 07                                lda IntervalTimerControl   ;if interval timer not yet expired,
09BBC D0 03                                   bne NoChgMus               ;branch ahead, don't bother with the music
09BBE 20 B7 8F                                jsr GetAreaMusic           ;to re-attain appropriate level music
09BC1 AC 9F 07                  NoChgMus:     ldy StarInvincibleTimer    ;get invincibility timer
09BC4 A5 09                                   lda FrameCounter           ;get frame counter
09BC6 C0 08                                   cpy #$08                   ;if timer still above certain point,
09BC8 B0 02                                   bcs CycleTwo               ;branch to cycle player's palette quickly
09BCA 4A                                      lsr                        ;otherwise, divide by 8 to cycle every eighth frame
09BCB 4A                                      lsr
09BCC 4A                        CycleTwo:     lsr                        ;if branched here, divide by 2 to cycle every other frame
09BCD 20 F3 9E                                jsr CyclePlayerPalette     ;do sub to cycle the palette (note: shares fire flower code)
09BD0 4C D6 9B                                jmp SaveAB                 ;then skip this sub to finish up the game engine
09BD3 20 05 9F                  ClrPlrPal:    jsr ResetPalStar           ;do sub to clear player's palette bits in attributes
09BD6 A5 0A                     SaveAB:       lda A_B_Buttons            ;save current A and B button
09BD8 85 0D                                   sta PreviousA_B_Buttons    ;into temp variable to be used on next frame
09BDA A9 00                                   lda #$00
09BDC 85 0C                                   sta Left_Right_Buttons     ;nullify left and right buttons temp variable
09BDE AD 73 07                  UpdScrollVar: lda VRAM_Buffer_AddrCtrl
09BE1 C9 06                                   cmp #$06                   ;if vram address controller set to 6
09BE3 F0 1C                                   beq ExitEng                ;then branch to leave
09BE5 AD 1F 07                                lda AreaParserTaskNum      ;otherwise check number of tasks
09BE8 D0 14                                   bne RunParser
09BEA AD 3D 07                                lda ScrollThirtyTwo        ;get horizontal scroll in 0-31 or $00-$20 range
09BED C9 20                                   cmp #$20                   ;check to see if exceeded $21
09BEF 30 10                                   bmi ExitEng                ;branch to leave if not
09BF1 AD 3D 07                                lda ScrollThirtyTwo
09BF4 E9 20                                   sbc #$20                   ;otherwise subtract $20 to set appropriately
09BF6 8D 3D 07                                sta ScrollThirtyTwo        ;and store
09BF9 A9 00                                   lda #$00                   ;reset vram buffer offset used in conjunction with
09BFB 8D 40 03                                sta VRAM_Buffer2_Offset    ;level graphics buffer in second VRAM buffer
09BFE 20 6E 91                  RunParser:    jsr AreaParserTaskHandler  ;update the name table with more level graphics
09C01 60                        ExitEng:      rts                        ;and after all that, we're finally done!
09C02                           
09C02                           ScrollHandler:
09C02 AD FF 06                              lda Player_X_Scroll       ;load value saved here
09C05 18                                    clc
09C06 6D A1 03                              adc Platform_X_Scroll     ;add value used by left/right platforms
09C09 8D FF 06                              sta Player_X_Scroll       ;save as new value here to impose force on scroll
09C0C AD 23 07                              lda ScrollLock            ;check scroll lock flag
09C0F D0 55                                 bne InitScrlAmt           ;skip a bunch of code here if set
09C11 AD 55 07                              lda Player_Pos_ForScroll
09C14 C9 50                                 cmp #$50                  ;check player's horizontal screen position
09C16 90 4E                                 bcc InitScrlAmt           ;if less than 80 pixels to the right, branch
09C18 AD 85 07                              lda SideCollisionTimer    ;if timer related to player's side collision
09C1B D0 49                                 bne InitScrlAmt           ;not expired, branch
09C1D AC FF 06                              ldy Player_X_Scroll       ;get value and decrement by one
09C20 88                                    dey                       ;if value originally set to zero or otherwise
09C21 30 43                                 bmi InitScrlAmt           ;negative for left movement, branch
09C23 C8                                    iny
09C24 C0 02                                 cpy #$02                  ;if value $01, branch and do not decrement
09C26 90 01                                 bcc ChkNearMid
09C28 88                                    dey                       ;otherwise decrement by one
09C29 AD 55 07                  ChkNearMid: lda Player_Pos_ForScroll
09C2C C9 70                                 cmp #$70                  ;check player's horizontal screen position
09C2E 90 03                                 bcc ScrollScreen          ;if less than 112 pixels to the right, branch
09C30 AC FF 06                              ldy Player_X_Scroll       ;otherwise get original value undecremented
09C33                           
09C33                           ScrollScreen:
09C33 AD 7B 07                                lda IRQAckFlag
09C36 D0 FB                                   bne ScrollScreen           ;loop if IRQ has not yet happened
09C38 98                                      tya
09C39 8D 75 07                                sta ScrollAmount           ;save value here
09C3C 18                                      clc
09C3D 6D 3D 07                                adc ScrollThirtyTwo        ;add to value already set here
09C40 8D 3D 07                                sta ScrollThirtyTwo        ;save as new value here
09C43 98                                      tya
09C44 18                                      clc
09C45 6D 1C 07                                adc ScreenLeft_X_Pos       ;add to left side coordinate
09C48 8D 1C 07                                sta ScreenLeft_X_Pos       ;save as new left side coordinate
09C4B 8D 3F 07                                sta HorizontalScroll       ;save here also
09C4E AD 1A 07                                lda ScreenLeft_PageLoc
09C51 69 00                                   adc #$00                   ;add carry to page location for left
09C53 8D 1A 07                                sta ScreenLeft_PageLoc     ;side of the screen
09C56 29 01                                   and #$01                   ;get LSB of page location
09C58 8D 7A 07                                sta NameTableSelect        ;save as name table select for later use
09C5B 20 A3 9C                                jsr GetScreenPosition
09C5E A9 08                                   lda #$08
09C60 8D 95 07                                sta ScrollIntervalTimer    ;set scroll timer (residual, not used elsewhere)
09C63 4C 6B 9C                                jmp ChkPOffscr             ;skip this part
09C66 A9 00                     InitScrlAmt:  lda #$00
09C68 8D 75 07                                sta ScrollAmount           ;initialize value here
09C6B A2 00                     ChkPOffscr:   ldx #$00                   ;set X for player offset
09C6D 20 03 E1                                jsr GetXOffscreenBits      ;get horizontal offscreen bits for player
09C70 85 00                                   sta $00                    ;save them here
09C72 A0 00                                   ldy #$00                   ;load default offset (left side)
09C74 0A                                      asl                        ;if d7 of offscreen bits are set,
09C75 B0 07                                   bcs KeepOnscr              ;branch with default offset
09C77 C8                                      iny                        ;otherwise use different offset (right side)
09C78 A5 00                                   lda $00
09C7A 29 20                                   and #%00100000             ;check offscreen bits for d5 set
09C7C F0 1B                                   beq InitPlatScrl           ;if not set, branch ahead of this part
09C7E B9 1C 07                  KeepOnscr:    lda ScreenEdge_X_Pos,y     ;get left or right side coordinate based on offset
09C81 38                                      sec
09C82 F9 9F 9C                                sbc X_SubtracterData,y     ;subtract amount based on offset
09C85 85 86                                   sta Player_X_Position      ;store as player position to prevent movement further
09C87 B9 1A 07                                lda ScreenEdge_PageLoc,y   ;get left or right page location based on offset
09C8A E9 00                                   sbc #$00                   ;subtract borrow
09C8C 85 6D                                   sta Player_PageLoc         ;save as player's page location
09C8E A5 0C                                   lda Left_Right_Buttons     ;check saved controller bits
09C90 D9 A1 9C                                cmp OffscrJoypadBitsData,y ;against bits based on offset
09C93 F0 04                                   beq InitPlatScrl           ;if not equal, branch
09C95 A9 00                                   lda #$00
09C97 85 57                                   sta Player_X_Speed         ;otherwise nullify horizontal speed of player
09C99 A9 00                     InitPlatScrl: lda #$00                   ;nullify platform force imposed on scroll
09C9B 8D A1 03                                sta Platform_X_Scroll
09C9E 60                                      rts
09C9F                           
09C9F                           X_SubtracterData:
09C9F 00 10                           .db $00, $10
09CA1                           
09CA1                           OffscrJoypadBitsData:
09CA1 01 02                           .db $01, $02
09CA3                           
09CA3                           ;-------------------------------------------------------------------------------------
09CA3                           
09CA3                           GetScreenPosition:
09CA3 AD 1C 07                        lda ScreenLeft_X_Pos    ;get coordinate of screen's left boundary
09CA6 18                              clc
09CA7 69 FF                           adc #$ff                ;add 255 pixels
09CA9 8D 1D 07                        sta ScreenRight_X_Pos   ;store as coordinate of screen's right boundary
09CAC AD 1A 07                        lda ScreenLeft_PageLoc  ;get page number where left boundary is
09CAF 69 00                           adc #$00                ;add carry from before
09CB1 8D 1B 07                        sta ScreenRight_PageLoc ;store as page number where right boundary is
09CB4 60                              rts
09CB5                           
09CB5                           ;-------------------------------------------------------------------------------------
09CB5                           
09CB5                           GameRoutines:
09CB5 A5 0E                           lda GameEngineSubroutine  ;run routine based on number (a few of these routines are   
09CB7 20 F8 8C                        jsr JumpEngine            ;merely placeholders as conditions for other routines)
09CBA                           
09CBA FB 8F                           .dw Entrance_GameTimerSetup
09CBC 32 9E                           .dw Vine_AutoClimb
09CBE 71 9E                           .dw SideExitPipeEntry
09CC0 50 9E                           .dw VerticalPipeEntry
09CC2 0E 9F                           .dw FlagpoleSlide
09CC4 35 9F                           .dw PlayerEndLevel
09CC6 B3 90                           .dw PlayerLoseLife
09CC8 D4 9C                           .dw PlayerEntrance
09CCA 54 9D                           .dw PlayerCtrlRoutine
09CCC 9E 9E                           .dw PlayerChangeSize
09CCE B0 9E                           .dw PlayerInjuryBlink
09CD0 D4 9E                           .dw PlayerDeath
09CD2 E8 9E                           .dw PlayerFireFlower
09CD4                           
09CD4                           PlayerEntrance:
09CD4 AD 52 07                              lda AltEntranceControl    ;check for mode of alternate entry
09CD7 C9 02                                 cmp #$02
09CD9 F0 2B                                 beq EntrMode2             ;if found, branch to enter from pipe or with vine
09CDB A9 00                                 lda #$00       
09CDD A4 CE                                 ldy Player_Y_Position     ;if vertical position above a certain
09CDF C0 30                                 cpy #$30                  ;point, nullify controller bits and continue
09CE1 90 6E                                 bcc AutoControlPlayer     ;with player movement code, do not return
09CE3 AD 10 07                              lda PlayerEntranceCtrl    ;check player entry bits from header
09CE6 C9 06                                 cmp #$06
09CE8 F0 04                                 beq ChkBehPipe            ;if set to 6 or 7, execute pipe intro code
09CEA C9 07                                 cmp #$07                  ;otherwise branch to normal entry
09CEC D0 50                                 bne PlayerRdy
09CEE AD C4 03                  ChkBehPipe: lda Player_SprAttrib      ;check for sprite attributes
09CF1 D0 05                                 bne IntroEntr             ;branch if found
09CF3 A9 01                                 lda #$01
09CF5 4C 51 9D                              jmp AutoControlPlayer     ;force player to walk to the right
09CF8 20 8A 9E                  IntroEntr:  jsr EnterSidePipe         ;execute sub to move player to the right
09CFB CE DE 06                              dec ChangeAreaTimer       ;decrement timer for change of area
09CFE D0 50                                 bne ExitEntr              ;branch to exit if not yet expired
09D00 EE 69 07                              inc DisableIntermediate   ;set flag to skip world and lives display
09D03 4C 94 9F                              jmp NextArea              ;jump to increment to next area and set modes
09D06 AD 58 07                  EntrMode2:  lda JoypadOverride        ;if controller override bits set here,
09D09 D0 0C                                 bne VineEntr              ;branch to enter with vine
09D0B A9 FF                                 lda #$ff                  ;otherwise, set value here then execute sub
09D0D 20 6B 9E                              jsr MovePlayerYAxis       ;to move player upwards
09D10 A5 CE                                 lda Player_Y_Position     ;check to see if player is at a specific coordinate
09D12 C9 91                                 cmp #$91                  ;if player risen to a certain point (this requires pipes
09D14 90 28                                 bcc PlayerRdy             ;to be at specific height to look/function right) branch
09D16 60                                    rts                       ;to the last part, otherwise leave
09D17 AD 99 03                  VineEntr:   lda VineHeight
09D1A C9 60                                 cmp #$60                  ;check vine height
09D1C D0 32                                 bne ExitEntr              ;if vine not yet reached maximum height, branch to leave
09D1E A5 CE                                 lda Player_Y_Position     ;get player's vertical coordinate
09D20 C9 99                                 cmp #$99                  ;check player's vertical coordinate against preset value
09D22 A0 00                                 ldy #$00                  ;load default values to be written to 
09D24 A9 01                                 lda #$01                  ;this value moves player to the right off the vine
09D26 90 0A                                 bcc OffVine               ;if vertical coordinate < preset value, use defaults
09D28 A9 03                                 lda #$03
09D2A 85 1D                                 sta Player_State          ;otherwise set player state to climbing
09D2C C8                                    iny                       ;increment value in Y
09D2D A9 08                                 lda #$08                  ;set block in block buffer to cover hole, then 
09D2F 8D B4 05                              sta Block_Buffer_1+$b4    ;use same value to force player to climb
09D32 8C 16 07                  OffVine:    sty DisableCollisionDet   ;set collision detection disable flag
09D35 20 51 9D                              jsr AutoControlPlayer     ;use contents of A to move player up or right, execute sub
09D38 A5 86                                 lda Player_X_Position
09D3A C9 48                                 cmp #$48                  ;check player's horizontal position
09D3C 90 12                                 bcc ExitEntr              ;if not far enough to the right, branch to leave
09D3E A9 08                     PlayerRdy:  lda #$08                  ;set routine to be executed by game engine next frame
09D40 85 0E                                 sta GameEngineSubroutine
09D42 A9 01                                 lda #$01                  ;set to face player to the right
09D44 85 33                                 sta PlayerFacingDir
09D46 4A                                    lsr                       ;init A
09D47 8D 52 07                              sta AltEntranceControl    ;init mode of entry
09D4A 8D 16 07                              sta DisableCollisionDet   ;init collision detection disable flag
09D4D 8D 58 07                              sta JoypadOverride        ;nullify controller override bits
09D50 60                        ExitEntr:   rts                       ;leave!
09D51                           
09D51                           ;-------------------------------------------------------------------------------------
09D51                           ;$07 - used to hold upper limit of high byte when player falls down hole
09D51                           
09D51                           AutoControlPlayer:
09D51 8D FC 06                        sta SavedJoypadBits         ;override controller bits with contents of A if executing here
09D54                           
09D54                           PlayerCtrlRoutine:
09D54 A5 0E                                 lda GameEngineSubroutine    ;check task here
09D56 C9 0B                                 cmp #$0b                    ;if certain value is set, branch to skip controller bit loading
09D58 F0 3C                                 beq SizeChk
09D5A AD 4E 07                              lda AreaType                ;are we in a water type area?
09D5D D0 10                                 bne SaveJoyp                ;if not, branch
09D5F A4 B5                                 ldy Player_Y_HighPos
09D61 88                                    dey                         ;if not in vertical area between
09D62 D0 06                                 bne DisJoyp                 ;status bar and bottom, branch
09D64 A5 CE                                 lda Player_Y_Position
09D66 C9 D0                                 cmp #$d0                    ;if nearing the bottom of the screen or
09D68 90 05                                 bcc SaveJoyp                ;not in the vertical area between status bar or bottom,
09D6A A9 00                     DisJoyp:    lda #$00                    ;disable controller bits
09D6C 8D FC 06                              sta SavedJoypadBits
09D6F AD FC 06                  SaveJoyp:   lda SavedJoypadBits         ;otherwise store A and B buttons in $0a
09D72 29 C0                                 and #%11000000
09D74 85 0A                                 sta A_B_Buttons
09D76 AD FC 06                              lda SavedJoypadBits         ;store left and right buttons in $0c
09D79 29 03                                 and #%00000011
09D7B 85 0C                                 sta Left_Right_Buttons
09D7D AD FC 06                              lda SavedJoypadBits         ;store up and down buttons in $0b
09D80 29 0C                                 and #%00001100
09D82 85 0B                                 sta Up_Down_Buttons
09D84 29 04                                 and #%00000100              ;check for pressing down
09D86 F0 0E                                 beq SizeChk                 ;if not, branch
09D88 A5 1D                                 lda Player_State            ;check player's state
09D8A D0 0A                                 bne SizeChk                 ;if not on the ground, branch
09D8C A4 0C                                 ldy Left_Right_Buttons      ;check left and right
09D8E F0 06                                 beq SizeChk                 ;if neither pressed, branch
09D90 A9 00                                 lda #$00
09D92 85 0C                                 sta Left_Right_Buttons      ;if pressing down while on the ground,
09D94 85 0B                                 sta Up_Down_Buttons         ;nullify directional bits
09D96 20 B2 9F                  SizeChk:    jsr PlayerMovementSubs      ;run movement subroutines
09D99 A0 01                                 ldy #$01                    ;is player small?
09D9B AD 54 07                              lda PlayerSize
09D9E D0 09                                 bne ChkMoveDir
09DA0 A0 00                                 ldy #$00                    ;check for if crouching
09DA2 AD 14 07                              lda CrouchingFlag
09DA5 F0 02                                 beq ChkMoveDir              ;if not, branch ahead
09DA7 A0 02                                 ldy #$02                    ;if big and crouching, load y with 2
09DA9 8C 99 04                  ChkMoveDir: sty Player_BoundBoxCtrl     ;set contents of Y as player's bounding box size control
09DAC A9 01                                 lda #$01                    ;set moving direction to right by default
09DAE A4 57                                 ldy Player_X_Speed          ;check player's horizontal speed
09DB0 F0 05                                 beq PlayerSubs              ;if not moving at all horizontally, skip this part
09DB2 10 01                                 bpl SetMoveDir              ;if moving to the right, use default moving direction
09DB4 0A                                    asl                         ;otherwise change to move to the left
09DB5 85 45                     SetMoveDir: sta Player_MovingDir        ;set moving direction
09DB7 20 02 9C                  PlayerSubs: jsr ScrollHandler           ;move the screen if necessary
09DBA 20 8D E0                              jsr GetPlayerOffscreenBits  ;get player's offscreen bits
09DBD 20 37 E0                              jsr RelativePlayerPosition  ;get coordinates relative to the screen
09DC0 A2 00                                 ldx #$00                    ;set offset for player object
09DC2 20 53 D1                              jsr BoundingBoxCore         ;get player's bounding box coordinates
09DC5 20 E6 CA                              jsr PlayerBGCollision       ;do collision detection and process
09DC8 A5 CE                                 lda Player_Y_Position
09DCA C9 40                                 cmp #$40                    ;check to see if player is higher than 64th pixel
09DCC 90 16                                 bcc PlayerHole              ;if so, branch ahead
09DCE A5 0E                                 lda GameEngineSubroutine
09DD0 C9 05                                 cmp #$05                    ;if running end-of-level routine, branch ahead
09DD2 F0 10                                 beq PlayerHole
09DD4 C9 07                                 cmp #$07                    ;if running player entrance routine, branch ahead
09DD6 F0 0C                                 beq PlayerHole
09DD8 C9 04                                 cmp #$04                    ;if running routines $00-$03, branch ahead
09DDA 90 08                                 bcc PlayerHole
09DDC AD C4 03                              lda Player_SprAttrib
09DDF 29 DF                                 and #%11011111              ;otherwise nullify player's
09DE1 8D C4 03                              sta Player_SprAttrib        ;background priority flag
09DE4 A5 B5                     PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
09DE6 C9 02                                 cmp #$02                    ;for below the screen
09DE8 30 3B                                 bmi ExitCtrl                ;branch to leave if not that far down
09DEA A2 01                                 ldx #$01
09DEC 8E 23 07                              stx ScrollLock              ;set scroll lock
09DEF A0 04                                 ldy #$04
09DF1 84 07                                 sty $07                     ;set value here
09DF3 A2 00                                 ldx #$00                    ;use X as flag, and clear for cloud level
09DF5 AC 59 07                              ldy GameTimerExpiredFlag    ;check game timer expiration flag
09DF8 D0 05                                 bne HoleDie                 ;if set, branch
09DFA AC 43 07                              ldy CloudTypeOverride       ;check for cloud type override
09DFD D0 16                                 bne ChkHoleX                ;skip to last part if found
09DFF E8                        HoleDie:    inx                         ;set flag in X for player death
09E00 A4 0E                                 ldy GameEngineSubroutine
09E02 C0 0B                                 cpy #$0b                    ;check for some other routine running
09E04 F0 0F                                 beq ChkHoleX                ;if so, branch ahead
09E06 AC 12 07                              ldy DeathMusicLoaded        ;check value here
09E09 D0 06                                 bne HoleBottom              ;if already set, branch to next part
09E0B C8                                    iny
09E0C 84 FC                                 sty EventMusicQueue         ;otherwise play death music
09E0E 8C 12 07                              sty DeathMusicLoaded        ;and set value here
09E11 A0 06                     HoleBottom: ldy #$06
09E13 84 07                                 sty $07                     ;change value here
09E15 C5 07                     ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
09E17 30 0C                                 bmi ExitCtrl                ;if less, branch to leave
09E19 CA                                    dex                         ;otherwise decrement flag in X
09E1A 30 0A                                 bmi CloudExit               ;if flag was clear, branch to set modes and other values
09E1C AC B1 07                              ldy EventMusicBuffer        ;check to see if music is still playing
09E1F D0 04                                 bne ExitCtrl                ;branch to leave if so
09E21 A9 06                                 lda #$06                    ;otherwise set to run lose life routine
09E23 85 0E                                 sta GameEngineSubroutine    ;on next frame
09E25 60                        ExitCtrl:   rts                         ;leave
09E26                           
09E26                           CloudExit:
09E26 A9 00                           lda #$00
09E28 8D 58 07                        sta JoypadOverride      ;clear controller override bits if any are set
09E2B 20 48 9E                        jsr SetEntr             ;do sub to set secondary mode
09E2E EE 52 07                        inc AltEntranceControl  ;set mode of entry to 3
09E31 60                              rts
09E32                           
09E32                           ;-------------------------------------------------------------------------------------
09E32                           
09E32                           Vine_AutoClimb:
09E32 A5 B5                                lda Player_Y_HighPos   ;check to see whether player reached position
09E34 D0 06                                bne AutoClimb          ;above the status bar yet and if so, set modes
09E36 A5 CE                                lda Player_Y_Position
09E38 C9 E4                                cmp #$e4
09E3A 90 0C                                bcc SetEntr
09E3C A9 08                     AutoClimb: lda #%00001000         ;set controller bits override to up
09E3E 8D 58 07                             sta JoypadOverride
09E41 A0 03                                ldy #$03               ;set player state to climbing
09E43 84 1D                                sty Player_State
09E45 4C 51 9D                             jmp AutoControlPlayer
09E48 A9 02                     SetEntr:   lda #$02               ;set starting position to override
09E4A 8D 52 07                             sta AltEntranceControl
09E4D 4C 7E 9E                             jmp ChgAreaMode        ;set modes
09E50                           
09E50                           ;-------------------------------------------------------------------------------------
09E50                           
09E50                           VerticalPipeEntry:
09E50 A9 01                           lda #$01             ;set 1 as movement amount
09E52 20 6B 9E                        jsr MovePlayerYAxis  ;do sub to move player downwards
09E55 20 02 9C                        jsr ScrollHandler    ;do sub to scroll screen with saved force if necessary
09E58 A0 00                           ldy #$00             ;load default mode of entry
09E5A AD D6 06                        lda WarpZoneControl  ;check warp zone control variable/flag
09E5D D0 17                           bne ChgAreaPipe      ;if set, branch to use mode 0
09E5F C8                              iny
09E60 AD 4E 07                        lda AreaType         ;check for castle level type
09E63 C9 03                           cmp #$03
09E65 D0 0F                           bne ChgAreaPipe      ;if not castle type level, use mode 1
09E67 C8                              iny
09E68 4C 76 9E                        jmp ChgAreaPipe      ;otherwise use mode 2
09E6B                           
09E6B                           MovePlayerYAxis:
09E6B 18                              clc
09E6C 65 CE                           adc Player_Y_Position ;add contents of A to player position
09E6E 85 CE                           sta Player_Y_Position
09E70 60                              rts
09E71                           
09E71                           ;-------------------------------------------------------------------------------------
09E71                           
09E71                           SideExitPipeEntry:
09E71 20 8A 9E                               jsr EnterSidePipe         ;execute sub to move player to the right
09E74 A0 02                                  ldy #$02
09E76 CE DE 06                  ChgAreaPipe: dec ChangeAreaTimer       ;decrement timer for change of area
09E79 D0 0E                                  bne ExitCAPipe
09E7B 8C 52 07                               sty AltEntranceControl    ;when timer expires set mode of alternate entry
09E7E EE 74 07                  ChgAreaMode: inc DisableScreenFlag     ;set flag to disable screen output
09E81 A9 00                                  lda #$00
09E83 8D 72 07                               sta OperMode_Task         ;set secondary mode of operation
09E86 8D 22 07                               sta IRQUpdateFlag         ;disable IRQ check
09E89 60                        ExitCAPipe:  rts                       ;leave
09E8A                           
09E8A                           EnterSidePipe:
09E8A A9 08                                lda #$08               ;set player's horizontal speed
09E8C 85 57                                sta Player_X_Speed
09E8E A0 01                                ldy #$01               ;set controller right button by default
09E90 A5 86                                lda Player_X_Position  ;mask out higher nybble of player's
09E92 29 0F                                and #%00001111         ;horizontal position
09E94 D0 03                                bne RightPipe
09E96 85 57                                sta Player_X_Speed     ;if lower nybble = 0, set as horizontal speed
09E98 A8                                   tay                    ;and nullify controller bit override here
09E99 98                        RightPipe: tya                    ;use contents of Y to
09E9A 20 51 9D                             jsr AutoControlPlayer  ;execute player control routine with ctrl bits nulled
09E9D 60                                   rts
09E9E                           
09E9E                           ;-------------------------------------------------------------------------------------
09E9E                           
09E9E                           PlayerChangeSize:
09E9E AD 47 07                               lda TimerControl    ;check master timer control
09EA1 C9 F8                                  cmp #$f8            ;for specific moment in time
09EA3 D0 03                                  bne EndChgSize      ;branch if before or after that point
09EA5 4C C0 9E                               jmp InitChangeSize  ;otherwise run code to get growing/shrinking going
09EA8 C9 C4                     EndChgSize:  cmp #$c4            ;check again for another specific moment
09EAA D0 03                                  bne ExitChgSize     ;and branch to leave if before or after that point
09EAC 20 DE 9E                               jsr DonePlayerTask  ;otherwise do sub to init timer control and set routine
09EAF 60                        ExitChgSize: rts                 ;and then leave
09EB0                           
09EB0                           ;-------------------------------------------------------------------------------------
09EB0                           
09EB0                           PlayerInjuryBlink:
09EB0 AD 47 07                             lda TimerControl       ;check master timer control
09EB3 C9 F0                                cmp #$f0               ;for specific moment in time
09EB5 B0 07                                bcs ExitBlink          ;branch if before that point
09EB7 C9 C8                                cmp #$c8               ;check again for another specific point
09EB9 F0 23                                beq DonePlayerTask     ;branch if at that point, and not before or after
09EBB 4C 54 9D                             jmp PlayerCtrlRoutine  ;otherwise run player control routine
09EBE D0 13                     ExitBlink: bne ExitBoth           ;do unconditional branch to leave
09EC0                           
09EC0                           InitChangeSize:
09EC0 AC 0B 07                            ldy PlayerChangeSizeFlag  ;if growing/shrinking flag already set
09EC3 D0 0E                               bne ExitBoth              ;then branch to leave
09EC5 8C 0D 07                            sty PlayerAnimCtrl        ;otherwise initialize player's animation frame control
09EC8 EE 0B 07                            inc PlayerChangeSizeFlag  ;set growing/shrinking flag
09ECB AD 54 07                            lda PlayerSize
09ECE 49 01                               eor #$01                  ;invert player's size
09ED0 8D 54 07                            sta PlayerSize
09ED3 60                        ExitBoth: rts                       ;leave
09ED4                           
09ED4                           ;-------------------------------------------------------------------------------------
09ED4                           ;$00 - used in CyclePlayerPalette to store current palette to cycle
09ED4                           
09ED4                           PlayerDeath:
09ED4 AD 47 07                        lda TimerControl       ;check master timer control
09ED7 C9 F0                           cmp #$f0               ;for specific moment in time
09ED9 B0 32                           bcs ExitDeath          ;branch to leave if before that point
09EDB 4C 54 9D                        jmp PlayerCtrlRoutine  ;otherwise run player control routine
09EDE                           
09EDE                           DonePlayerTask:
09EDE A9 00                           lda #$00
09EE0 8D 47 07                        sta TimerControl          ;initialize master timer control to continue timers
09EE3 A9 08                           lda #$08
09EE5 85 0E                           sta GameEngineSubroutine  ;set player control routine to run next frame
09EE7 60                              rts                       ;leave
09EE8                           
09EE8                           PlayerFireFlower: 
09EE8 AD 47 07                        lda TimerControl       ;check master timer control
09EEB C9 C0                           cmp #$c0               ;for specific moment in time
09EED F0 13                           beq ResetPalFireFlower ;branch if at moment, not before or after
09EEF A5 09                           lda FrameCounter       ;get frame counter
09EF1 4A                              lsr
09EF2 4A                              lsr                    ;divide by four to change every four frames
09EF3                           
09EF3                           CyclePlayerPalette:
09EF3 29 03                           and #$03              ;mask out all but d1-d0 (previously d3-d2)
09EF5 85 00                           sta $00               ;store result here to use as palette bits
09EF7 AD C4 03                        lda Player_SprAttrib  ;get player attributes
09EFA 29 FC                           and #%11111100        ;save any other bits but palette bits
09EFC 05 00                           ora $00               ;add palette bits
09EFE 8D C4 03                        sta Player_SprAttrib  ;store as new player attributes
09F01 60                              rts                   ;and leave
09F02                           
09F02                           ResetPalFireFlower:
09F02 20 DE 9E                        jsr DonePlayerTask    ;do sub to init timer control and run player control routine
09F05                           
09F05                           ResetPalStar:
09F05 AD C4 03                        lda Player_SprAttrib  ;get player attributes
09F08 29 FC                           and #%11111100        ;mask out palette bits to force palette 0
09F0A 8D C4 03                        sta Player_SprAttrib  ;store as new player attributes
09F0D                           ExitDeath:
09F0D 60                              rts                   ;and leave
09F0E                           
09F0E                           ;-------------------------------------------------------------------------------------
09F0E                           
09F0E                           FlagpoleSlide:
09F0E A5 1B                                  lda Enemy_ID+5           ;check special use enemy slot
09F10 C9 30                                  cmp #FlagpoleFlagObject  ;for flagpole flag object
09F12 D0 15                                  bne NoFPObj              ;if not found, branch to something residual
09F14 AD 13 07                               lda FlagpoleSoundQueue   ;load flagpole sound
09F17 85 FF                                  sta Square1SoundQueue    ;into square 1's sfx queue
09F19 A9 00                                  lda #$00
09F1B 8D 13 07                               sta FlagpoleSoundQueue   ;init flagpole sound queue
09F1E A4 CE                                  ldy Player_Y_Position
09F20 C0 9E                                  cpy #$9e                 ;check to see if player has slid down
09F22 B0 02                                  bcs SlidePlayer          ;far enough, and if so, branch with no controller bits set
09F24 A9 04                                  lda #$04                 ;otherwise force player to climb down (to slide)
09F26 4C 51 9D                  SlidePlayer: jmp AutoControlPlayer    ;jump to player control routine
09F29 E6 0E                     NoFPObj:     inc GameEngineSubroutine ;increment to next routine (this may
09F2B 60                                     rts                      ;be residual code)
09F2C                           
09F2C                           ;-------------------------------------------------------------------------------------
09F2C                           
09F2C                           Hidden1UpCoinAmts:
09F2C 15 23 16 1B 17 18 23 00..       .db $15, $23, $16, $1b, $17, $18, $23, $00, $00
09F35                           
09F35                           PlayerEndLevel:
09F35 A9 01                               lda #$01                  ;force player to walk to the right
09F37 20 51 9D                            jsr AutoControlPlayer
09F3A A5 CE                               lda Player_Y_Position     ;check player's vertical position
09F3C C9 AE                               cmp #$ae
09F3E 90 11                               bcc ChkStop               ;if player is not yet off the flagpole, skip this part
09F40 A9 00                               lda #$00
09F42 8D 23 07                            sta ScrollLock            ;reactivate scroll
09F45 AD F6 07                            lda FlagpoleMusicFlag     ;check flag to see if music was already queued
09F48 D0 07                               bne ChkStop               ;if so, skip this
09F4A A9 20                               lda #EndOfLevelMusic
09F4C 85 FC                               sta EventMusicQueue       ;load win level music in event music queue
09F4E EE F6 07                            inc FlagpoleMusicFlag     ;set flag to keep music from getting queued more than once
09F51 AD 90 04                  ChkStop:  lda Player_CollisionBits  ;get player collision bits
09F54 4A                                  lsr                       ;check for d0 set
09F55 B0 0D                               bcs RdyNextA              ;if d0 set, skip to next part
09F57 AD 46 07                            lda StarFlagTaskControl   ;if star flag task control already set,
09F5A D0 03                               bne InCastle              ;go ahead with the rest of the code
09F5C EE 46 07                            inc StarFlagTaskControl   ;otherwise set task control now (this gets ball rolling!)
09F5F A9 20                     InCastle: lda #%00100000            ;set player's background priority bit to
09F61 8D C4 03                            sta Player_SprAttrib      ;give illusion of being inside the castle
09F64 AD 46 07                  RdyNextA: lda StarFlagTaskControl
09F67 C9 05                               cmp #$05                  ;if star flag task control not yet set
09F69 D0 46                               bne ExitNA                ;beyond last valid task number, branch to leave
09F6B EE 5C 07                            inc LevelNumber           ;increment level number used for game logic
09F6E AD 5C 07                            lda LevelNumber
09F71 C9 03                               cmp #$03                  ;check to see if we have yet reached level -4
09F73 D0 1F                               bne NextArea              ;and skip this last part here if not
09F75 AD FB 07                            lda HardWorldFlag         ;playing SMB2J levels?
09F78 D0 10                               bne ChkF10C               ;yes, only need to check if player got 10 coins in third area
09F7A AC 5F 07                            ldy WorldNumber           ;get world number as offset
09F7D AD 48 07                            lda CoinTallyFor1Ups      ;check third area coin tally for bonus 1-ups
09F80 D9 2C 9F                            cmp Hidden1UpCoinAmts,y   ;against minimum value, if player has not collected
09F83 90 0F                               bcc NextArea              ;at least this number of coins, leave flag clear
09F85 EE 5D 07                            inc Hidden1UpFlag         ;otherwise set hidden 1-up box control flag
09F88 D0 0A                               bne NextArea              ;branch to move on to next area
09F8A AD 48 07                  ChkF10C:  lda CoinTallyFor1Ups      ;check third area coin tally for bonus 1-ups
09F8D C9 0A                               cmp #$0a                  ;against minimum value, if player has not collected
09F8F 90 03                               bcc NextArea              ;at least this number of coins, leave flag clear
09F91 EE 5D 07                            inc Hidden1UpFlag         ;otherwise set hidden 1-up box control flag
09F94 EE 60 07                  NextArea: inc AreaNumber            ;increment area number used for address loader
09F97 AD 5C 07                            lda LevelNumber           ;go to next world if past level 4 of current world
09F9A C9 04                               cmp #$04
09F9C 90 03                               bcc NotEndW
09F9E 4C 84 83                            jmp NextWorld
09FA1 20 AF FE                  NotEndW:  jsr RunLoadAreaPointer    ;get new level pointer
09FA4 EE 57 07                            inc FetchNewGameTimerFlag ;set flag to load new game timer
09FA7 20 7E 9E                            jsr ChgAreaMode           ;do sub to set secondary mode, disable screen and IRQ
09FAA 8D 5B 07                            sta HalfwayPage           ;reset halfway page to 0 (beginning)
09FAD A9 80                               lda #Silence
09FAF 85 FC                               sta EventMusicQueue       ;silence music and leave
09FB1 60                        ExitNA:   rts
09FB2                           
09FB2                           ;-------------------------------------------------------------------------------------
09FB2                           
09FB2                           PlayerMovementSubs:
09FB2 A9 00                                lda #$00                  ;set A to init crouch flag by default
09FB4 AC 54 07                             ldy PlayerSize            ;is player small?
09FB7 D0 08                                bne SetCrouch             ;if so, branch
09FB9 A5 1D                                lda Player_State          ;check state of player
09FBB D0 07                                bne ProcMove              ;if not on the ground, branch
09FBD A5 0B                                lda Up_Down_Buttons       ;load controller bits for up and down
09FBF 29 04                                and #%00000100            ;single out bit for down button
09FC1 8D 14 07                  SetCrouch: sta CrouchingFlag         ;store value in crouch flag
09FC4 20 EC A0                  ProcMove:  jsr PlayerPhysicsSub      ;run sub related to jumping and swimming
09FC7 AD 0B 07                             lda PlayerChangeSizeFlag  ;if growing/shrinking flag set,
09FCA D0 16                                bne NoMoveSub             ;branch to leave
09FCC A5 1D                                lda Player_State
09FCE C9 03                                cmp #$03                  ;get player state
09FD0 F0 05                                beq MoveSubs              ;if climbing, branch ahead, leave timer unset
09FD2 A0 18                                ldy #$18
09FD4 8C 89 07                             sty ClimbSideTimer        ;otherwise reset timer now
09FD7 20 F8 8C                  MoveSubs:  jsr JumpEngine
09FDA                           
09FDA E3 9F                           .dw OnGroundStateSub
09FDC 07 A0                           .dw JumpSwimSub
09FDE FE 9F                           .dw FallingSub
09FE0 5D A0                           .dw ClimbingSub
09FE2                           
09FE2 60                        NoMoveSub: rts
09FE3                           
09FE3                           ;-------------------------------------------------------------------------------------
09FE3                           ;$00 - used by ClimbingSub to store high vertical adder
09FE3                           
09FE3                           OnGroundStateSub:
09FE3 20 4A A2                           jsr GetPlayerAnimSpeed     ;do a sub to set animation frame timing
09FE6 A5 0C                              lda Left_Right_Buttons
09FE8 F0 02                              beq GndMove                ;if left/right controller bits not set, skip instruction
09FEA 85 33                              sta PlayerFacingDir        ;otherwise set new facing direction
09FEC 20 87 A2                  GndMove: jsr ImposeFriction         ;do a sub to impose friction on player's walk/run
09FEF 20 2A AC                  JmpMove: jsr MovePlayerHorizontally ;do another sub to move player horizontally
09FF2 8D FF 06                           sta Player_X_Scroll        ;set returned value as player's movement speed for scroll
09FF5 AD F7 07                           lda FileListNumber         ;if in SMB1 levels or 2J worlds 1-4, don't bother checking for wind
09FF8 F0 03                              beq ExOGSS
09FFA 20 95 E6                           jsr BlowPlayerAround
09FFD 60                        ExOGSS:  rts
09FFE                           
09FFE                           ;--------------------------------
09FFE                           
09FFE                           FallingSub:
09FFE AD 0A 07                        lda VerticalForceDown
0A001 8D 09 07                        sta VerticalForce      ;dump vertical movement force for falling into main one
0A004 4C 3D A0                        jmp LRAir              ;movement force, then skip ahead to process left/right movement
0A007                           
0A007                           ;--------------------------------
0A007                           
0A007                           JumpSwimSub:
0A007 A4 9F                               ldy Player_Y_Speed         ;if player's vertical speed zero
0A009 10 13                               bpl DumpFall               ;or moving downwards, branch to falling
0A00B A5 0A                               lda A_B_Buttons
0A00D 29 80                               and #A_Button              ;check to see if A button is being pressed
0A00F 25 0D                               and PreviousA_B_Buttons    ;and was pressed in previous frame
0A011 D0 11                               bne ProcSwim               ;if so, branch elsewhere
0A013 AD 08 07                            lda JumpOrigin_Y_Position  ;get vertical position player jumped from
0A016 38                                  sec
0A017 E5 CE                               sbc Player_Y_Position      ;subtract current from original vertical coordinate
0A019 CD 06 07                            cmp DiffToHaltJump         ;compare to value set here to see if player is in mid-jump
0A01C 90 06                               bcc ProcSwim               ;or just starting to jump, if just starting, skip ahead
0A01E AD 0A 07                  DumpFall: lda VerticalForceDown      ;otherwise dump falling into main fractional
0A021 8D 09 07                            sta VerticalForce
0A024 AD 04 07                  ProcSwim: lda SwimmingFlag           ;if swimming flag not set,
0A027 F0 14                               beq LRAir                  ;branch ahead to last part
0A029 20 4A A2                            jsr GetPlayerAnimSpeed     ;do a sub to get animation frame timing
0A02C A5 CE                               lda Player_Y_Position
0A02E C9 14                               cmp #$14                   ;check vertical position against preset value
0A030 B0 05                               bcs LRWater                ;if not yet reached a certain position, branch ahead
0A032 A9 18                               lda #$18
0A034 8D 09 07                            sta VerticalForce          ;otherwise set fractional
0A037 A5 0C                     LRWater:  lda Left_Right_Buttons     ;check left/right controller bits (check for swimming)
0A039 F0 02                               beq LRAir                  ;if not pressing any, skip
0A03B 85 33                               sta PlayerFacingDir        ;otherwise set facing direction accordingly
0A03D A5 0C                     LRAir:    lda Left_Right_Buttons     ;check left/right controller bits (check for jumping/falling)
0A03F F0 03                               beq JSMove                 ;if not pressing any, skip
0A041 20 87 A2                            jsr ImposeFriction         ;otherwise process horizontal movement
0A044 20 EF 9F                  JSMove:   jsr JmpMove
0A047 A5 0E                               lda GameEngineSubroutine
0A049 C9 0B                               cmp #$0b                   ;check for specific routine selected
0A04B D0 05                               bne ExitMov1               ;branch if not set to run
0A04D A9 28                               lda #$28
0A04F 8D 09 07                            sta VerticalForce          ;otherwise set fractional
0A052 4C 6E AC                  ExitMov1: jmp MovePlayerVertically   ;jump to move player vertically, then leave
0A055                           
0A055                           ;--------------------------------
0A055                           
0A055                           ClimbAdderLow:
0A055 0E 04 FC F2                     .db $0e, $04, $fc, $f2
0A059                           ClimbAdderHigh:
0A059 00 00 FF FF                     .db $00, $00, $ff, $ff
0A05D                           
0A05D                           ClimbingSub:
0A05D AD 16 04                               lda Player_YMF_Dummy
0A060 18                                     clc                      ;add movement force to dummy variable
0A061 6D 33 04                               adc Player_Y_MoveForce   ;save with carry
0A064 8D 16 04                               sta Player_YMF_Dummy
0A067 A0 00                                  ldy #$00                 ;set default adder here
0A069 A5 9F                                  lda Player_Y_Speed       ;get player's vertical speed
0A06B 10 01                                  bpl MoveOnVine           ;if not moving upwards, branch
0A06D 88                                     dey                      ;otherwise set adder to $ff
0A06E 84 00                     MoveOnVine:  sty $00                  ;store adder here
0A070 65 CE                                  adc Player_Y_Position    ;add carry to player's vertical position
0A072 85 CE                                  sta Player_Y_Position    ;and store to move player up or down
0A074 A5 B5                                  lda Player_Y_HighPos
0A076 65 00                                  adc $00                  ;add carry to player's page location
0A078 85 B5                                  sta Player_Y_HighPos     ;and store
0A07A A5 0C                                  lda Left_Right_Buttons   ;compare left/right controller bits
0A07C 2D 90 04                               and Player_CollisionBits ;to collision flag
0A07F F0 2D                                  beq InitCSTimer          ;if not set, skip to end
0A081 AC 89 07                               ldy ClimbSideTimer       ;otherwise check timer 
0A084 D0 27                                  bne ExitCSub             ;if timer not expired, branch to leave
0A086 A0 18                                  ldy #$18
0A088 8C 89 07                               sty ClimbSideTimer       ;otherwise set timer now
0A08B A2 00                                  ldx #$00                 ;set default offset here
0A08D A4 33                                  ldy PlayerFacingDir      ;get facing direction
0A08F 4A                                     lsr                      ;move right button controller bit to carry
0A090 B0 02                                  bcs ClimbFD              ;if controller right pressed, branch ahead
0A092 E8                                     inx
0A093 E8                                     inx                      ;otherwise increment offset by 2 bytes
0A094 88                        ClimbFD:     dey                      ;check to see if facing right
0A095 F0 01                                  beq CSetFDir             ;if so, branch, do not increment
0A097 E8                                     inx                      ;otherwise increment by 1 byte
0A098 A5 86                     CSetFDir:    lda Player_X_Position
0A09A 18                                     clc                      ;add or subtract from player's horizontal position
0A09B 7D 55 A0                               adc ClimbAdderLow,x      ;using value here as adder and X as offset
0A09E 85 86                                  sta Player_X_Position
0A0A0 A5 6D                                  lda Player_PageLoc       ;add or subtract carry or borrow using value here
0A0A2 7D 59 A0                               adc ClimbAdderHigh,x     ;from the player's page location
0A0A5 85 6D                                  sta Player_PageLoc
0A0A7 A5 0C                                  lda Left_Right_Buttons   ;get left/right controller bits again
0A0A9 49 03                                  eor #%00000011           ;invert them and store them while player
0A0AB 85 33                                  sta PlayerFacingDir      ;is on vine to face player in opposite direction
0A0AD 60                        ExitCSub:    rts                      ;then leave
0A0AE 8D 89 07                  InitCSTimer: sta ClimbSideTimer       ;initialize timer here
0A0B1 60                                     rts
0A0B2                           
0A0B2                           ;-------------------------------------------------------------------------------------
0A0B2                           ;$00 - used to store offset to friction data
0A0B2                           
0A0B2                           MarioJumpMForceData:
0A0B2 20 20 1E 28 28 0D 04            .db $20, $20, $1e, $28, $28, $0d, $04
0A0B9                           
0A0B9                           MarioFallMForceData:
0A0B9 70 70 60 90 90 0A 09            .db $70, $70, $60, $90, $90, $0a, $09
0A0C0                           
0A0C0                           LuigiJumpMForceData:
0A0C0 18 18 18 22 22 0D 04            .db $18, $18, $18, $22, $22, $0d, $04
0A0C7                           
0A0C7                           LuigiFallMForceData:
0A0C7 42 42 3E 5D 5D 0A 09            .db $42, $42, $3e, $5d, $5d, $0a, $09
0A0CE                           
0A0CE                           FrictionData:
0A0CE E4 98 D0                        .db $e4, $98, $d0
0A0D1                           
0A0D1                           PlayerYSpdData:
0A0D1 FC FC FC FB FB FE FF            .db $fc, $fc, $fc, $fb, $fb, $fe, $ff
0A0D8                           
0A0D8                           InitMForceData:
0A0D8 00 00 00 00 00 80 00            .db $00, $00, $00, $00, $00, $80, $00
0A0DF                           
0A0DF                           MaxLeftXSpdData:
0A0DF D8 E8 F0                        .db $d8, $e8, $f0
0A0E2                           
0A0E2                           MaxRightXSpdData:
0A0E2 28 18 10                        .db $28, $18, $10
0A0E5 0C                              .db $0c ;used for pipe intros
0A0E6                           
0A0E6                           Climb_Y_SpeedData:
0A0E6 00 FF 01                        .db $00, $ff, $01
0A0E9                           
0A0E9                           Climb_Y_MForceData:
0A0E9 00 20 FF                        .db $00, $20, $ff
0A0EC                           
0A0EC                           PlayerPhysicsSub:
0A0EC A5 1D                                lda Player_State          ;check player state
0A0EE C9 03                                cmp #$03
0A0F0 D0 23                                bne CheckForJumping       ;if not climbing, branch
0A0F2 A0 00                                ldy #$00
0A0F4 A5 0B                                lda Up_Down_Buttons       ;get controller bits for up/down
0A0F6 2D 90 04                             and Player_CollisionBits  ;check against player's collision detection bits
0A0F9 F0 06                                beq ProcClimb             ;if not pressing up or down, branch
0A0FB C8                                   iny
0A0FC 29 08                                and #%00001000            ;check for pressing up
0A0FE D0 01                                bne ProcClimb
0A100 C8                                   iny
0A101 BE E9 A0                  ProcClimb: ldx Climb_Y_MForceData,y  ;load value here
0A104 8E 33 04                             stx Player_Y_MoveForce    ;store as vertical movement force
0A107 A9 08                                lda #$08                  ;load default animation timing
0A109 BE E6 A0                             ldx Climb_Y_SpeedData,y   ;load some other value here
0A10C 86 9F                                stx Player_Y_Speed        ;store as vertical speed
0A10E 30 01                                bmi SetCAnim              ;if climbing down, use default animation timing value
0A110 4A                                   lsr                       ;otherwise divide timer setting by 2
0A111 8D 0C 07                  SetCAnim:  sta PlayerAnimTimerSet    ;store animation timer setting and leave
0A114 60                                   rts
0A115                           
0A115                           CheckForJumping:
0A115 AD 0E 07                          lda JumpspringAnimCtrl    ;if jumpspring animating, 
0A118 D0 0A                             bne NoJump                ;skip ahead to something else
0A11A A5 0A                             lda A_B_Buttons           ;check for A button press
0A11C 29 80                             and #A_Button
0A11E F0 04                             beq NoJump                ;if not, branch to something else
0A120 25 0D                             and PreviousA_B_Buttons   ;if button not pressed in previous frame, branch
0A122 F0 03                             beq ProcJumping
0A124 4C D2 A1                  NoJump: jmp X_Physics             ;otherwise, jump to something else
0A127                           
0A127                           ProcJumping:
0A127 A5 1D                                lda Player_State           ;check player state
0A129 F0 11                                beq InitJS                 ;if on the ground, branch
0A12B AD 04 07                             lda SwimmingFlag           ;if swimming flag not set, jump to do something else
0A12E F0 F4                                beq NoJump                 ;to prevent midair jumping, otherwise continue
0A130 AD 82 07                             lda JumpSwimTimer          ;if jump/swim timer nonzero, branch
0A133 D0 07                                bne InitJS
0A135 A5 9F                                lda Player_Y_Speed         ;check player's vertical speed
0A137 10 03                                bpl InitJS                 ;if player's vertical speed motionless or down, branch
0A139 4C D2 A1                             jmp X_Physics              ;if timer at zero and player still rising, do not swim
0A13C A9 20                     InitJS:    lda #$20                   ;set jump/swim timer
0A13E 8D 82 07                             sta JumpSwimTimer
0A141 A0 00                                ldy #$00                   ;initialize vertical force and dummy variable
0A143 8C 16 04                             sty Player_YMF_Dummy
0A146 8C 33 04                             sty Player_Y_MoveForce
0A149 A5 B5                                lda Player_Y_HighPos       ;get vertical high and low bytes of jump origin
0A14B 8D 07 07                             sta JumpOrigin_Y_HighPos   ;and store them next to each other here
0A14E A5 CE                                lda Player_Y_Position
0A150 8D 08 07                             sta JumpOrigin_Y_Position
0A153 A9 01                                lda #$01                   ;set player state to jumping/swimming
0A155 85 1D                                sta Player_State
0A157 AD 00 07                             lda Player_XSpeedAbsolute  ;check value related to walking/running speed
0A15A C9 09                                cmp #$09
0A15C 90 10                                bcc ChkWtr                 ;branch if below certain values, increment Y
0A15E C8                                   iny                        ;for each amount equal or exceeded
0A15F C9 10                                cmp #$10
0A161 90 0B                                bcc ChkWtr
0A163 C8                                   iny
0A164 C9 19                                cmp #$19
0A166 90 06                                bcc ChkWtr
0A168 C8                                   iny
0A169 C9 1C                                cmp #$1c
0A16B 90 01                                bcc ChkWtr                 ;note that for jumping, range is 0-4 for Y
0A16D C8                                   iny
0A16E A9 01                     ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
0A170 8D 06 07                             sta DiffToHaltJump
0A173 AD 04 07                             lda SwimmingFlag           ;if swimming flag disabled, branch
0A176 F0 08                                beq GetYPhy
0A178 A0 05                                ldy #$05                   ;otherwise set Y to 5, range is 5-6
0A17A AD 7D 04                             lda Whirlpool_Flag         ;if whirlpool flag not set, branch
0A17D F0 01                                beq GetYPhy
0A17F C8                                   iny                        ;otherwise increment to 6
0A180 AD 53 07                  GetYPhy:   lda SelectedPlayer         ;check selected player
0A183 F0 15                                beq MarioYPhy              ;if mario, branch
0A185 AD 70 07                             lda OperMode               ;get primary mode of operation
0A188 C9 02                                cmp #VictoryMode
0A18A F0 0E                                beq MarioYPhy              ;if victory mode, branch
0A18C B9 C0 A0                             lda LuigiJumpMForceData,y  ;store appropriate jump/swim
0A18F 8D 09 07                             sta VerticalForce          ;data here
0A192 B9 C7 A0                             lda LuigiFallMForceData,y
0A195 8D 0A 07                             sta VerticalForceDown
0A198 D0 0C                                bne ContYPhy               ;unconditional branch
0A19A B9 B2 A0                  MarioYPhy: lda MarioJumpMForceData,y  ;store appropriate jump/swim
0A19D 8D 09 07                             sta VerticalForce          ;data here
0A1A0 B9 B9 A0                             lda MarioFallMForceData,y
0A1A3 8D 0A 07                             sta VerticalForceDown
0A1A6 B9 D8 A0                  ContYPhy:  lda InitMForceData,y
0A1A9 8D 33 04                             sta Player_Y_MoveForce
0A1AC B9 D1 A0                             lda PlayerYSpdData,y
0A1AF 85 9F                                sta Player_Y_Speed
0A1B1 AD 04 07                             lda SwimmingFlag           ;if swimming flag disabled, branch
0A1B4 F0 11                                beq PJumpSnd
0A1B6 A9 04                                lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
0A1B8 85 FF                                sta Square1SoundQueue      ;square 1's sfx queue
0A1BA A5 CE                                lda Player_Y_Position
0A1BC C9 14                                cmp #$14                   ;check vertical low byte of player position
0A1BE B0 12                                bcs X_Physics              ;if below a certain point, branch
0A1C0 A9 00                                lda #$00                   ;otherwise reset player's vertical speed
0A1C2 85 9F                                sta Player_Y_Speed         ;and jump to something else to keep player
0A1C4 4C D2 A1                             jmp X_Physics              ;from swimming above water level
0A1C7 A9 01                     PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
0A1C9 AC 54 07                             ldy PlayerSize             ;is mario big?
0A1CC F0 02                                beq SJumpSnd
0A1CE A9 80                                lda #Sfx_SmallJump         ;if not, load small mario's jump sound
0A1D0 85 FF                     SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
0A1D2 A0 00                     X_Physics: ldy #$00
0A1D4 84 00                                sty $00                    ;init value here
0A1D6 A5 1D                                lda Player_State           ;if mario is on the ground, branch
0A1D8 F0 09                                beq ProcPRun
0A1DA AD 00 07                             lda Player_XSpeedAbsolute  ;check something that seems to be related
0A1DD C9 19                                cmp #$19                   ;to mario's speed
0A1DF B0 33                                bcs GetXPhy                ;if =>$19 branch here
0A1E1 90 18                                bcc ChkRFast               ;if not branch elsewhere
0A1E3 C8                        ProcPRun:  iny                        ;if mario on the ground, increment Y
0A1E4 AD 4E 07                             lda AreaType               ;check area type
0A1E7 F0 12                                beq ChkRFast               ;if water type, branch
0A1E9 88                                   dey                        ;decrement Y by default for non-water type area
0A1EA A5 0C                                lda Left_Right_Buttons     ;get left/right controller bits
0A1EC C5 45                                cmp Player_MovingDir       ;check against moving direction
0A1EE D0 0B                                bne ChkRFast               ;if controller bits <> moving direction, skip this part
0A1F0 A5 0A                                lda A_B_Buttons            ;check for b button pressed
0A1F2 29 40                                and #B_Button
0A1F4 D0 19                                bne SetRTmr                ;if pressed, skip ahead to set timer
0A1F6 AD 83 07                             lda RunningTimer           ;check for running timer set
0A1F9 D0 19                                bne GetXPhy                ;if set, branch
0A1FB C8                        ChkRFast:  iny                        ;if running timer not set or level type is water, 
0A1FC E6 00                                inc $00                    ;increment Y again and temp variable in memory
0A1FE AD 03 07                             lda RunningSpeed
0A201 D0 07                                bne FastXSp                ;if running speed set here, branch
0A203 AD 00 07                             lda Player_XSpeedAbsolute
0A206 C9 21                                cmp #$21                   ;otherwise check player's walking/running speed
0A208 90 0A                                bcc GetXPhy                ;if less than a certain amount, branch ahead
0A20A E6 00                     FastXSp:   inc $00                    ;if running speed set or speed => $21 increment $00
0A20C 4C 14 A2                             jmp GetXPhy                ;and jump ahead
0A20F A9 0A                     SetRTmr:   lda #$0a                   ;if b button pressed, set running timer
0A211 8D 83 07                             sta RunningTimer
0A214 B9 DF A0                  GetXPhy:   lda MaxLeftXSpdData,y      ;get maximum speed to the left
0A217 8D 50 04                             sta MaximumLeftSpeed
0A21A A5 0E                                lda GameEngineSubroutine   ;check for specific routine running
0A21C C9 07                                cmp #$07                   ;(player entrance)
0A21E D0 02                                bne GetXPhy2               ;if not running, skip and use old value of Y
0A220 A0 03                                ldy #$03                   ;otherwise set Y to 3
0A222 B9 E2 A0                  GetXPhy2:  lda MaxRightXSpdData,y     ;get maximum speed to the right
0A225 8D 56 04                             sta MaximumRightSpeed
0A228 A4 00                                ldy $00                    ;get other value in memory
0A22A B9 CE A0                             lda FrictionData,y         ;get value using value in memory as offset
0A22D 8D 02 07                             sta FrictionAdderLow
0A230 A9 00                                lda #$00
0A232 8D 01 07                             sta FrictionAdderHigh      ;init something here
0A235 AD 53 07                             lda SelectedPlayer         ;if we're playing as luigi, don't bother with this bit
0A238 D0 0C                                bne ExitPhy
0A23A A5 33                                lda PlayerFacingDir
0A23C C5 45                                cmp Player_MovingDir       ;check facing direction against moving direction
0A23E F0 06                                beq ExitPhy                ;if the same, branch to leave
0A240 0E 02 07                             asl FrictionAdderLow       ;otherwise multiply friction by 2
0A243 2E 01 07                             rol FrictionAdderHigh      ;then leave (or just leave, if code was modified earlier)
0A246 60                        ExitPhy:   rts
0A247                           
0A247                           ;-------------------------------------------------------------------------------------
0A247                           
0A247                           PlayerAnimTmrData:
0A247 02 04 07                        .db $02, $04, $07
0A24A                           
0A24A                           GetPlayerAnimSpeed:
0A24A A0 00                                 ldy #$00                   ;initialize offset in Y
0A24C AD 00 07                              lda Player_XSpeedAbsolute  ;check player's walking/running speed
0A24F C9 1C                                 cmp #$1c                   ;against preset amount
0A251 B0 15                                 bcs SetRunSpd              ;if greater than a certain amount, branch ahead
0A253 C8                                    iny                        ;otherwise increment Y
0A254 C9 0E                                 cmp #$0e                   ;compare against lower amount
0A256 B0 01                                 bcs ChkSkid                ;if greater than this but not greater than first, skip increment
0A258 C8                                    iny                        ;otherwise increment Y again
0A259 AD FC 06                  ChkSkid:    lda SavedJoypadBits        ;get controller bits
0A25C 29 7F                                 and #%01111111             ;mask out A button
0A25E F0 20                                 beq SetAnimSpd             ;if no other buttons pressed, branch ahead of all this
0A260 29 03                                 and #$03                   ;mask out all others except left and right
0A262 C5 45                                 cmp Player_MovingDir       ;check against moving direction
0A264 D0 08                                 bne ProcSkid               ;if left/right controller bits <> moving direction, branch
0A266 A9 00                                 lda #$00                   ;otherwise set zero value here
0A268 8D 03 07                  SetRunSpd:  sta RunningSpeed           ;store zero or running speed here
0A26B 4C 80 A2                              jmp SetAnimSpd
0A26E AD 00 07                  ProcSkid:   lda Player_XSpeedAbsolute  ;check player's walking/running speed
0A271 C9 0B                                 cmp #$0b                   ;against one last amount
0A273 B0 0B                                 bcs SetAnimSpd             ;if greater than this amount, branch
0A275 A5 33                                 lda PlayerFacingDir
0A277 85 45                                 sta Player_MovingDir       ;otherwise use facing direction to set moving direction
0A279 A9 00                                 lda #$00
0A27B 85 57                                 sta Player_X_Speed         ;nullify player's horizontal speed
0A27D 8D 05 07                              sta Player_X_MoveForce     ;and dummy variable for player
0A280 B9 47 A2                  SetAnimSpd: lda PlayerAnimTmrData,y    ;get animation timer setting using Y as offset
0A283 8D 0C 07                              sta PlayerAnimTimerSet
0A286 60                                    rts
0A287                           
0A287                           ;-------------------------------------------------------------------------------------
0A287                           
0A287                           ImposeFriction:
0A287 2D 90 04                             and Player_CollisionBits  ;perform AND between left/right controller bits and collision flag
0A28A C9 00                                cmp #$00                  ;then compare to zero (this instruction is redundant)
0A28C D0 08                                bne JoypFrict             ;if any bits set, branch to next part
0A28E A5 57                                lda Player_X_Speed
0A290 F0 49                                beq SetAbsSpd             ;if player has no horizontal speed, branch ahead to last part
0A292 10 23                                bpl RghtFrict             ;if player moving to the right, branch to slow
0A294 30 03                                bmi LeftFrict             ;otherwise logic dictates player moving left, branch to slow
0A296 4A                        JoypFrict: lsr                       ;put right controller bit into carry
0A297 90 1E                                bcc RghtFrict             ;if left button pressed, carry = 0, thus branch
0A299 AD 05 07                  LeftFrict: lda Player_X_MoveForce    ;load value set here
0A29C 18                                   clc
0A29D 6D 02 07                             adc FrictionAdderLow      ;add to it another value set here
0A2A0 8D 05 07                             sta Player_X_MoveForce    ;store here
0A2A3 A5 57                                lda Player_X_Speed
0A2A5 6D 01 07                             adc FrictionAdderHigh     ;add value plus carry to horizontal speed
0A2A8 85 57                                sta Player_X_Speed        ;set as new horizontal speed
0A2AA CD 56 04                             cmp MaximumRightSpeed     ;compare against maximum value for right movement
0A2AD 30 23                                bmi XSpdSign              ;if horizontal speed greater negatively, branch
0A2AF AD 56 04                             lda MaximumRightSpeed     ;otherwise set preset value as horizontal speed
0A2B2 85 57                                sta Player_X_Speed        ;thus slowing the player's left movement down
0A2B4 4C DB A2                             jmp SetAbsSpd             ;skip to the end
0A2B7 AD 05 07                  RghtFrict: lda Player_X_MoveForce    ;load value set here
0A2BA 38                                   sec
0A2BB ED 02 07                             sbc FrictionAdderLow      ;subtract from it another value set here
0A2BE 8D 05 07                             sta Player_X_MoveForce    ;store here
0A2C1 A5 57                                lda Player_X_Speed
0A2C3 ED 01 07                             sbc FrictionAdderHigh     ;subtract value plus borrow from horizontal speed
0A2C6 85 57                                sta Player_X_Speed        ;set as new horizontal speed
0A2C8 CD 50 04                             cmp MaximumLeftSpeed      ;compare against maximum value for left movement
0A2CB 10 05                                bpl XSpdSign              ;if horizontal speed greater positively, branch
0A2CD AD 50 04                             lda MaximumLeftSpeed      ;otherwise set preset value as horizontal speed
0A2D0 85 57                                sta Player_X_Speed        ;thus slowing the player's right movement down
0A2D2 C9 00                     XSpdSign:  cmp #$00                  ;if player not moving or moving to the right,
0A2D4 10 05                                bpl SetAbsSpd             ;branch and leave horizontal speed value unmodified
0A2D6 49 FF                                eor #$ff
0A2D8 18                                   clc                       ;otherwise get two's compliment to get absolute
0A2D9 69 01                                adc #$01                  ;unsigned walking/running speed
0A2DB 8D 00 07                  SetAbsSpd: sta Player_XSpeedAbsolute ;store walking/running speed here and leave
0A2DE 60                                   rts
0A2DF                           
0A2DF                           ;-------------------------------------------------------------------------------------
0A2DF                           ;$00 - used to store downward movement force in FireballObjCore
0A2DF                           ;$02 - used to store maximum vertical speed in FireballObjCore
0A2DF                           ;$07 - used to store pseudorandom bit in BubbleCheck
0A2DF                           
0A2DF                           ProcFireball_Bubble:
0A2DF AD 56 07                        lda PlayerStatus           ;check player's status
0A2E2 C9 02                           cmp #$02
0A2E4 90 43                           bcc ProcAirBubbles         ;if not fiery, branch
0A2E6 A5 0A                           lda A_B_Buttons
0A2E8 29 40                           and #B_Button              ;check for b button pressed
0A2EA F0 33                           beq ProcFireballs          ;branch if not pressed
0A2EC 25 0D                           and PreviousA_B_Buttons
0A2EE D0 2F                           bne ProcFireballs          ;if button pressed in previous frame, branch
0A2F0 AD CE 06                        lda FireballCounter        ;load fireball counter
0A2F3 29 01                           and #%00000001             ;get LSB and use as offset for buffer
0A2F5 AA                              tax
0A2F6 B5 24                           lda Fireball_State,x       ;load fireball state
0A2F8 D0 25                           bne ProcFireballs          ;if not inactive, branch
0A2FA A4 B5                           ldy Player_Y_HighPos       ;if player too high or too low, branch
0A2FC 88                              dey
0A2FD D0 20                           bne ProcFireballs
0A2FF AD 14 07                        lda CrouchingFlag          ;if player crouching, branch
0A302 D0 1B                           bne ProcFireballs
0A304 A5 1D                           lda Player_State           ;if player's state = climbing, branch
0A306 C9 03                           cmp #$03
0A308 F0 15                           beq ProcFireballs
0A30A A9 20                           lda #Sfx_Fireball          ;play fireball sound effect
0A30C 85 FF                           sta Square1SoundQueue
0A30E A9 02                           lda #$02                   ;load state
0A310 95 24                           sta Fireball_State,x
0A312 AC 0C 07                        ldy PlayerAnimTimerSet     ;copy animation frame timer setting
0A315 8C 11 07                        sty FireballThrowingTimer  ;into fireball throwing timer
0A318 88                              dey
0A319 8C 81 07                        sty PlayerAnimTimer        ;decrement and store in player's animation timer
0A31C EE CE 06                        inc FireballCounter        ;increment fireball counter
0A31F                           
0A31F                           ProcFireballs:
0A31F A2 00                           ldx #$00
0A321 20 44 A3                        jsr FireballObjCore  ;process first fireball object
0A324 A2 01                           ldx #$01
0A326 20 44 A3                        jsr FireballObjCore  ;process second fireball object, then do air bubbles
0A329                           
0A329                           ProcAirBubbles:
0A329 AD 4E 07                            lda AreaType                ;if not water type level, skip the rest of this
0A32C D0 13                               bne BublExit
0A32E A2 02                               ldx #$02                    ;otherwise load counter and use as offset
0A330 86 08                     BublLoop: stx ObjectOffset            ;store offset
0A332 20 B4 A3                            jsr BubbleCheck             ;check timers and coordinates, create air bubble
0A335 20 3E E0                            jsr RelativeBubblePosition  ;get relative coordinates
0A338 20 9E E0                            jsr GetBubbleOffscreenBits  ;get offscreen information
0A33B 20 E4 DC                            jsr DrawBubble              ;draw the air bubble
0A33E CA                                  dex
0A33F 10 EF                               bpl BublLoop                ;do this until all three are handled
0A341 60                        BublExit: rts                         ;then leave
0A342                           
0A342                           FireballXSpdData:
0A342 40 C0                           .db $40, $c0
0A344                           
0A344                           FireballObjCore:
0A344 86 08                              stx ObjectOffset             ;store offset as current object
0A346 B5 24                              lda Fireball_State,x         ;check for d7 = 1
0A348 0A                                 asl
0A349 B0 63                              bcs FireballExplosion        ;if so, branch to get relative coordinates and draw explosion
0A34B B4 24                              ldy Fireball_State,x         ;if fireball inactive, branch to leave
0A34D F0 5E                              beq NoFBall
0A34F 88                                 dey                          ;if fireball state set to 1, skip this part and just run it
0A350 F0 27                              beq RunFB
0A352 A5 86                              lda Player_X_Position        ;get player's horizontal position
0A354 69 04                              adc #$04                     ;add four pixels and store as fireball's horizontal position
0A356 95 8D                              sta Fireball_X_Position,x
0A358 A5 6D                              lda Player_PageLoc           ;get player's page location
0A35A 69 00                              adc #$00                     ;add carry and store as fireball's page location
0A35C 95 74                              sta Fireball_PageLoc,x
0A35E A5 CE                              lda Player_Y_Position        ;get player's vertical position and store
0A360 95 D5                              sta Fireball_Y_Position,x
0A362 A9 01                              lda #$01                     ;set high byte of vertical position
0A364 95 BC                              sta Fireball_Y_HighPos,x
0A366 A4 33                              ldy PlayerFacingDir          ;get player's facing direction
0A368 88                                 dey                          ;decrement to use as offset here
0A369 B9 42 A3                           lda FireballXSpdData,y       ;set horizontal speed of fireball accordingly
0A36C 95 5E                              sta Fireball_X_Speed,x
0A36E A9 04                              lda #$04                     ;set vertical speed of fireball
0A370 95 A6                              sta Fireball_Y_Speed,x
0A372 A9 07                              lda #$07
0A374 9D A0 04                           sta Fireball_BoundBoxCtrl,x  ;set bounding box size control for fireball
0A377 D6 24                              dec Fireball_State,x         ;decrement state to 1 to skip this part from now on
0A379 8A                        RunFB:   txa                          ;add 7 to offset to use
0A37A 18                                 clc                          ;as fireball offset for next routines
0A37B 69 07                              adc #$07
0A37D AA                                 tax
0A37E A9 50                              lda #$50                     ;set downward movement force here
0A380 85 00                              sta $00
0A382 A9 03                              lda #$03                     ;set maximum speed here
0A384 85 02                              sta $02
0A386 A9 00                              lda #$00
0A388 20 F8 AC                           jsr ImposeGravity            ;do sub here to impose gravity on fireball and move vertically
0A38B 20 30 AC                           jsr MoveObjectHorizontally   ;do another sub to move it horizontally
0A38E A6 08                              ldx ObjectOffset             ;return fireball offset to X
0A390 20 48 E0                           jsr RelativeFireballPosition ;get relative coordinates
0A393 20 94 E0                           jsr GetFireballOffscreenBits ;get offscreen information
0A396 20 E4 D0                           jsr GetFireballBoundBox      ;get bounding box coordinates
0A399 20 7F D0                           jsr FireballBGCollision      ;do fireball to background collision detection
0A39C AD D2 03                           lda FBall_OffscreenBits      ;get fireball offscreen bits
0A39F 29 CC                              and #%11001100               ;mask out certain bits
0A3A1 D0 06                              bne EraseFB                  ;if any bits still set, branch to kill fireball
0A3A3 20 19 C5                           jsr FireballEnemyCollision   ;do fireball to enemy collision detection and deal with collisions
0A3A6 4C E1 DB                           jmp DrawFireball             ;draw fireball appropriately and leave
0A3A9 A9 00                     EraseFB: lda #$00                     ;erase fireball state
0A3AB 95 24                              sta Fireball_State,x
0A3AD 60                        NoFBall: rts                          ;leave
0A3AE                           
0A3AE                           FireballExplosion:
0A3AE 20 48 E0                        jsr RelativeFireballPosition
0A3B1 4C 0C DC                        jmp DrawExplosion_Fireball
0A3B4                           
0A3B4                           BubbleCheck:
0A3B4 BD A8 07                        lda PseudoRandomBitReg+1,x  ;get part of LSFR
0A3B7 29 01                           and #$01
0A3B9 85 07                           sta $07                     ;store pseudorandom bit here
0A3BB B5 E4                           lda Bubble_Y_Position,x     ;get vertical coordinate for air bubble
0A3BD C9 F8                           cmp #$f8                    ;if offscreen coordinate not set,
0A3BF D0 2C                           bne MoveBubl                ;branch to move air bubble
0A3C1 AD 92 07                        lda AirBubbleTimer          ;if air bubble timer not expired,
0A3C4 D0 3F                           bne ExitBubl                ;branch to leave, otherwise create new air bubble
0A3C6                           
0A3C6                           SetupBubble:
0A3C6 A0 00                               ldy #$00                 ;load default value here
0A3C8 A5 33                               lda PlayerFacingDir      ;get player's facing direction
0A3CA 4A                                  lsr                      ;move d0 to carry
0A3CB 90 02                               bcc PosBubl              ;branch to use default value if facing left
0A3CD A0 08                               ldy #$08                 ;otherwise load alternate value here
0A3CF 98                        PosBubl:  tya                      ;use value loaded as adder
0A3D0 65 86                               adc Player_X_Position    ;add to player's horizontal position
0A3D2 95 9C                               sta Bubble_X_Position,x  ;save as horizontal position for airbubble
0A3D4 A5 6D                               lda Player_PageLoc
0A3D6 69 00                               adc #$00                 ;add carry to player's page location
0A3D8 95 83                               sta Bubble_PageLoc,x     ;save as page location for airbubble
0A3DA A5 CE                               lda Player_Y_Position
0A3DC 18                                  clc                      ;add eight pixels to player's vertical position
0A3DD 69 08                               adc #$08
0A3DF 95 E4                               sta Bubble_Y_Position,x  ;save as vertical position for air bubble
0A3E1 A9 01                               lda #$01
0A3E3 95 CB                               sta Bubble_Y_HighPos,x   ;set vertical high byte for air bubble
0A3E5 A4 07                               ldy $07                  ;get pseudorandom bit, use as offset
0A3E7 B9 08 A4                            lda BubbleTimerData,y    ;get data for air bubble timer
0A3EA 8D 92 07                            sta AirBubbleTimer       ;set air bubble timer
0A3ED A4 07                     MoveBubl: ldy $07                  ;get pseudorandom bit again, use as offset
0A3EF BD 2C 04                            lda Bubble_YMF_Dummy,x
0A3F2 38                                  sec                      ;subtract pseudorandom amount from dummy variable
0A3F3 F9 06 A4                            sbc Bubble_MForceData,y
0A3F6 9D 2C 04                            sta Bubble_YMF_Dummy,x   ;save dummy variable
0A3F9 B5 E4                               lda Bubble_Y_Position,x
0A3FB E9 00                               sbc #$00                 ;subtract borrow from airbubble's vertical coordinate
0A3FD C9 20                               cmp #$20                 ;if below the status bar,
0A3FF B0 02                               bcs Y_Bubl               ;branch to go ahead and use to move air bubble upwards
0A401 A9 F8                               lda #$f8                 ;otherwise set offscreen coordinate
0A403 95 E4                     Y_Bubl:   sta Bubble_Y_Position,x  ;store as new vertical coordinate for air bubble
0A405 60                        ExitBubl: rts                      ;leave
0A406                           
0A406                           Bubble_MForceData:
0A406 FF 50                           .db $ff, $50
0A408                           
0A408                           BubbleTimerData:
0A408 40 20                           .db $40, $20
0A40A                           
0A40A                           ;-------------------------------------------------------------------------------------
0A40A                           
0A40A                           RunGameTimer:
0A40A AD 70 07                             lda OperMode               ;get primary mode of operation
0A40D F0 4F                                beq ExGTimer               ;branch to leave if in attract mode
0A40F A5 0E                                lda GameEngineSubroutine
0A411 C9 08                                cmp #$08                   ;if routine number less than eight running,
0A413 90 49                                bcc ExGTimer               ;branch to leave
0A415 C9 0B                                cmp #$0b                   ;if running death routine,
0A417 F0 45                                beq ExGTimer               ;branch to leave
0A419 A5 B5                                lda Player_Y_HighPos
0A41B C9 02                                cmp #$02                   ;if player below the screen,
0A41D 10 3F                                bpl ExGTimer               ;branch to leave regardless of level type
0A41F AD 87 07                             lda GameTimerCtrlTimer     ;if game timer control not yet expired,
0A422 D0 3A                                bne ExGTimer               ;branch to leave
0A424 AD EC 07                             lda GameTimerDisplay
0A427 0D ED 07                             ora GameTimerDisplay+1     ;otherwise check game timer digits
0A42A 0D EE 07                             ora GameTimerDisplay+2
0A42D F0 26                                beq TimeUpOn               ;if game timer digits at 000, branch to time-up code
0A42F AC EC 07                             ldy GameTimerDisplay       ;otherwise check first digit
0A432 88                                   dey                        ;if first digit not on 1,
0A433 D0 0C                                bne ResGTCtrl              ;branch to reset game timer control
0A435 AD ED 07                             lda GameTimerDisplay+1     ;otherwise check second and third digits
0A438 0D EE 07                             ora GameTimerDisplay+2
0A43B D0 04                                bne ResGTCtrl              ;if timer not at 100, branch to reset game timer control
0A43D A9 40                                lda #TimeRunningOutMusic
0A43F 85 FC                                sta EventMusicQueue        ;otherwise load time running out music
0A441 A9 18                     ResGTCtrl: lda #$18                   ;reset game timer control
0A443 8D 87 07                             sta GameTimerCtrlTimer
0A446 A0 17                                ldy #$17                   ;set offset for last digit
0A448 A9 FF                                lda #$ff                   ;set value to decrement game timer digit
0A44A 8D 39 01                             sta DigitModifier+5
0A44D 20 4D 8E                             jsr DigitsMathRoutine      ;do sub to decrement game timer slowly
0A450 A9 A2                                lda #$a2                   ;set status nybbles to update game timer display
0A452 4C F4 8D                             jmp PrintStatusBarNumbers  ;do sub to update the display
0A455 8D 56 07                  TimeUpOn:  sta PlayerStatus           ;init player status (note A will always be zero here)
0A458 20 93 C7                             jsr ForceInjury            ;do sub to kill the player (note player is small here)
0A45B EE 59 07                             inc GameTimerExpiredFlag   ;set game timer expiration flag
0A45E 60                        ExGTimer:  rts                        ;leave
0A45F                           
0A45F                           ;-------------------------------------------------------------------------------------
0A45F                           
0A45F                           WarpZoneObject:
0A45F AD 23 07                        lda ScrollLock         ;check for scroll lock flag
0A462 F0 FA                           beq ExGTimer           ;branch if not set to leave
0A464 A5 CE                           lda Player_Y_Position  ;check to see if player's vertical coordinate has
0A466 25 B5                           and Player_Y_HighPos   ;same bits set as in vertical high byte (why?)
0A468 D0 F4                           bne ExGTimer           ;if so, branch to leave
0A46A 8D 23 07                        sta ScrollLock         ;otherwise nullify scroll lock flag
0A46D 4C B1 B7                        jmp EraseEnemyObject   ;kill this object
0A470                           
0A470                           ;-------------------------------------------------------------------------------------
0A470                           ;$00 - used in WhirlpoolActivate to store whirlpool length / 2, page location of center of whirlpool
0A470                           ;and also to store movement force exerted on player
0A470                           ;$01 - used in ProcessWhirlpools to store page location of right extent of whirlpool
0A470                           ;and in WhirlpoolActivate to store center of whirlpool
0A470                           ;$02 - used in ProcessWhirlpools to store right extent of whirlpool and in
0A470                           ;WhirlpoolActivate to store maximum vertical speed
0A470                           
0A470                           ProcessWhirlpools:
0A470 AD 4E 07                          lda AreaType                ;check for water type level
0A473 D0 37                             bne ExitWh                  ;branch to leave if not found
0A475 8D 7D 04                          sta Whirlpool_Flag          ;otherwise initialize whirlpool flag
0A478 AD 47 07                          lda TimerControl            ;if master timer control set,
0A47B D0 2F                             bne ExitWh                  ;branch to leave
0A47D A0 04                             ldy #$04                    ;otherwise start with last whirlpool data
0A47F B9 71 04                  WhLoop: lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
0A482 18                                clc
0A483 79 77 04                          adc Whirlpool_Length,y      ;add length of whirlpool
0A486 85 02                             sta $02                     ;store result as right extent here
0A488 B9 6B 04                          lda Whirlpool_PageLoc,y     ;get page location
0A48B F0 1C                             beq NextWh                  ;if none or page 0, branch to get next data
0A48D 69 00                             adc #$00                    ;add carry
0A48F 85 01                             sta $01                     ;store result as page location of right extent here
0A491 A5 86                             lda Player_X_Position       ;get player's horizontal position
0A493 38                                sec
0A494 F9 71 04                          sbc Whirlpool_LeftExtent,y  ;subtract left extent
0A497 A5 6D                             lda Player_PageLoc          ;get player's page location
0A499 F9 6B 04                          sbc Whirlpool_PageLoc,y     ;subtract borrow
0A49C 30 0B                             bmi NextWh                  ;if player too far left, branch to get next data
0A49E A5 02                             lda $02                     ;otherwise get right extent
0A4A0 38                                sec
0A4A1 E5 86                             sbc Player_X_Position       ;subtract player's horizontal coordinate
0A4A3 A5 01                             lda $01                     ;get right extent's page location
0A4A5 E5 6D                             sbc Player_PageLoc          ;subtract borrow
0A4A7 10 04                             bpl WhirlpoolActivate       ;if player within right extent, branch to whirlpool code
0A4A9 88                        NextWh: dey                         ;move onto next whirlpool data
0A4AA 10 D3                             bpl WhLoop                  ;do this until all whirlpools are checked
0A4AC 60                        ExitWh: rts                         ;leave
0A4AD                           
0A4AD                           WhirlpoolActivate:
0A4AD B9 77 04                          lda Whirlpool_Length,y      ;get length of whirlpool
0A4B0 4A                                lsr                         ;divide by 2
0A4B1 85 00                             sta $00                     ;save here
0A4B3 B9 71 04                          lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
0A4B6 18                                clc
0A4B7 65 00                             adc $00                     ;add length divided by 2
0A4B9 85 01                             sta $01                     ;save as center of whirlpool
0A4BB B9 6B 04                          lda Whirlpool_PageLoc,y     ;get page location
0A4BE 69 00                             adc #$00                    ;add carry
0A4C0 85 00                             sta $00                     ;save as page location of whirlpool center
0A4C2 A5 09                             lda FrameCounter            ;get frame counter
0A4C4 4A                                lsr                         ;shift d0 into carry (to run on every other frame)
0A4C5 90 2C                             bcc WhPull                  ;if d0 not set, branch to last part of code
0A4C7 A5 01                             lda $01                     ;get center
0A4C9 38                                sec
0A4CA E5 86                             sbc Player_X_Position       ;subtract player's horizontal coordinate
0A4CC A5 00                             lda $00                     ;get page location of center
0A4CE E5 6D                             sbc Player_PageLoc          ;subtract borrow
0A4D0 10 0E                             bpl LeftWh                  ;if player to the left of center, branch
0A4D2 A5 86                             lda Player_X_Position       ;otherwise slowly pull player left, towards the center
0A4D4 38                                sec
0A4D5 E9 01                             sbc #$01                    ;subtract one pixel
0A4D7 85 86                             sta Player_X_Position       ;set player's new horizontal coordinate
0A4D9 A5 6D                             lda Player_PageLoc
0A4DB E9 00                             sbc #$00                    ;subtract borrow
0A4DD 4C F1 A4                          jmp SetPWh                  ;jump to set player's new page location
0A4E0 AD 90 04                  LeftWh: lda Player_CollisionBits    ;get player's collision bits
0A4E3 4A                                lsr                         ;shift d0 into carry
0A4E4 90 0D                             bcc WhPull                  ;if d0 not set, branch
0A4E6 A5 86                             lda Player_X_Position       ;otherwise slowly pull player right, towards the center
0A4E8 18                                clc
0A4E9 69 01                             adc #$01                    ;add one pixel
0A4EB 85 86                             sta Player_X_Position       ;set player's new horizontal coordinate
0A4ED A5 6D                             lda Player_PageLoc
0A4EF 69 00                             adc #$00                    ;add carry
0A4F1 85 6D                     SetPWh: sta Player_PageLoc          ;set player's new page location
0A4F3 A9 10                     WhPull: lda #$10
0A4F5 85 00                             sta $00                     ;set vertical movement force
0A4F7 A9 01                             lda #$01
0A4F9 8D 7D 04                          sta Whirlpool_Flag          ;set whirlpool flag to be used later
0A4FC 85 02                             sta $02                     ;also set maximum vertical speed
0A4FE 4A                                lsr
0A4FF AA                                tax                         ;set X for player offset
0A500 4C F8 AC                          jmp ImposeGravity           ;jump to put whirlpool effect on player vertically, do not return
0A503                           
0A503                           ;-------------------------------------------------------------------------------------
0A503                           
0A503                           FlagpoleScoreMods:
0A503 05 02 08 04 01                  .db $05, $02, $08, $04, $01
0A508                           
0A508                           FlagpoleScoreDigits:
0A508 03 03 04 04 04                  .db $03, $03, $04, $04, $04
0A50D                           
0A50D                           FlagpoleRoutine:
0A50D A2 05                                ldx #$05                  ;set enemy object offset
0A50F 86 08                                stx ObjectOffset          ;to special use slot
0A511 B5 16                                lda Enemy_ID,x
0A513 C9 30                                cmp #FlagpoleFlagObject   ;if flagpole flag not found,
0A515 D0 60                                bne ExitFlagP             ;branch to leave
0A517 A5 0E                                lda GameEngineSubroutine
0A519 C9 04                                cmp #$04                  ;if flagpole slide routine not running,
0A51B D0 31                                bne SkipScore             ;branch to near the end of code
0A51D A5 1D                                lda Player_State
0A51F C9 03                                cmp #$03                  ;if player state not climbing,
0A521 D0 2B                                bne SkipScore             ;branch to near the end of code
0A523 B5 CF                                lda Enemy_Y_Position,x    ;check flagpole flag's vertical coordinate
0A525 C9 AA                                cmp #$aa                  ;if flagpole flag down to a certain point,
0A527 B0 28                                bcs GiveFPScr             ;branch to end the level
0A529 A5 CE                                lda Player_Y_Position     ;check player's vertical coordinate
0A52B C9 A2                                cmp #$a2                  ;if player down to a certain point,
0A52D B0 22                                bcs GiveFPScr             ;branch to end the level
0A52F BD 17 04                             lda Enemy_YMF_Dummy,x
0A532 69 FF                                adc #$ff                  ;add movement amount to dummy variable
0A534 9D 17 04                             sta Enemy_YMF_Dummy,x     ;save dummy variable
0A537 B5 CF                                lda Enemy_Y_Position,x    ;get flag's vertical coordinate
0A539 69 01                                adc #$01                  ;add 1 plus carry to move flag, and
0A53B 95 CF                                sta Enemy_Y_Position,x    ;store vertical coordinate
0A53D AD 0E 01                             lda FlagpoleFNum_YMFDummy
0A540 38                                   sec                       ;subtract movement amount from dummy variable
0A541 E9 FF                                sbc #$ff
0A543 8D 0E 01                             sta FlagpoleFNum_YMFDummy ;save dummy variable
0A546 AD 0D 01                             lda FlagpoleFNum_Y_Pos
0A549 E9 01                                sbc #$01                  ;subtract one plus borrow to move floatey number,
0A54B 8D 0D 01                             sta FlagpoleFNum_Y_Pos    ;and store vertical coordinate here
0A54E 4C 6E A5                  SkipScore: jmp FPGfx                 ;jump to skip ahead and draw flag and floatey number
0A551 AC 0F 01                  GiveFPScr: ldy FlagpoleScore         ;get score offset from earlier (when player touched flagpole)
0A554 C0 05                                cpy #$05
0A556 D0 06                                bne NoEL4F                ;if set to give player an extra life, do so now
0A558 20 80 84                             jsr GiveExtraLife
0A55B 4C 6A A5                             jmp NoSc4F
0A55E B9 03 A5                  NoEL4F:    lda FlagpoleScoreMods,y   ;get amount to award player points
0A561 BE 08 A5                             ldx FlagpoleScoreDigits,y ;get digit with which to award points
0A564 9D 34 01                             sta DigitModifier,x       ;store in digit modifier
0A567 20 38 A9                             jsr AddToScore            ;do sub to award player points depending on height of collision
0A56A A9 05                     NoSc4F:    lda #$05
0A56C 85 0E                                sta GameEngineSubroutine  ;set to run end-of-level subroutine on next frame
0A56E 20 BC E0                  FPGfx:     jsr GetEnemyOffscreenBits ;get offscreen information
0A571 20 5F E0                             jsr RelativeEnemyPosition ;get relative coordinates
0A574 20 03 D4                             jsr FlagpoleGfxHandler    ;draw flagpole flag and floatey number
0A577 60                        ExitFlagP: rts
0A578                           
0A578                           ;-------------------------------------------------------------------------------------
0A578                           
0A578                           Jumpspring_Y_PosData:
0A578 08 10 08 00                     .db $08, $10, $08, $00
0A57C                           
0A57C                           JumpspringHandler:
0A57C 20 BC E0                             jsr GetEnemyOffscreenBits   ;get offscreen information
0A57F AD 47 07                             lda TimerControl            ;check master timer control
0A582 D0 5E                                bne DrawJSpr                ;branch to last section if set
0A584 AD 0E 07                             lda JumpspringAnimCtrl      ;check jumpspring frame control
0A587 F0 59                                beq DrawJSpr                ;branch to last section if not set
0A589 A8                                   tay
0A58A 88                                   dey                         ;subtract one from frame control in A,
0A58B 98                                   tya                         ;the only way a poor NMOS 6502 can
0A58C 29 02                                and #%00000010              ;mask out all but d1, original value still in Y
0A58E D0 07                                bne DownJSpr                ;if set, branch to move player up
0A590 E6 CE                                inc Player_Y_Position
0A592 E6 CE                                inc Player_Y_Position       ;move player's vertical position down two pixels
0A594 4C 9B A5                             jmp PosJSpr                 ;skip to next part
0A597 C6 CE                     DownJSpr:  dec Player_Y_Position       ;move player's vertical position up two pixels
0A599 C6 CE                                dec Player_Y_Position
0A59B B5 58                     PosJSpr:   lda Jumpspring_FixedYPos,x  ;get permanent vertical position
0A59D 18                                   clc
0A59E 79 78 A5                             adc Jumpspring_Y_PosData,y  ;add value using frame control as offset
0A5A1 95 CF                                sta Enemy_Y_Position,x      ;store as new vertical position
0A5A3 C0 01                                cpy #$01                    ;check frame control offset (second frame is $00)
0A5A5 90 2D                                bcc BounceJS                ;if offset not yet at third frame ($01), skip to next part
0A5A7 A5 0A                                lda A_B_Buttons
0A5A9 29 80                                and #A_Button               ;check saved controller bits for A button press
0A5AB F0 27                                beq BounceJS                ;skip to next part if A not pressed
0A5AD 25 0D                                and PreviousA_B_Buttons     ;check for A button pressed in previous frame
0A5AF D0 23                                bne BounceJS                ;skip to next part if so
0A5B1 98                                   tya
0A5B2 48                                   pha
0A5B3 A9 F4                                lda #$f4                    ;set jumpspring force for red jumpsprings
0A5B5 AC FB 07                             ldy HardWorldFlag           ;if playing SMB1 levels, use red jumpspring force
0A5B8 F0 15                                beq SetJSF
0A5BA AC 5F 07                             ldy WorldNumber             ;otherwise check world number
0A5BD C0 01                                cpy #World2
0A5BF F0 0C                                beq GreenJS                 ;if world number is 2, 3, 7, or C
0A5C1 C0 02                                cpy #World3                 ;set jumpspring force for green jumpsprings
0A5C3 F0 08                                beq GreenJS
0A5C5 C0 06                                cpy #World7
0A5C7 F0 04                                beq GreenJS
0A5C9 C0 0B                                cpy #WorldC                 ;otherwise use red jumpspring force
0A5CB D0 02                                bne SetJSF
0A5CD A9 E0                     GreenJS:   lda #$e0
0A5CF 8D DB 06                  SetJSF:    sta JumpspringForce         ;otherwise write new jumpspring force here
0A5D2 68                                   pla
0A5D3 A8                                   tay
0A5D4 C0 03                     BounceJS:  cpy #$03                    ;check frame control offset again
0A5D6 D0 0A                                bne DrawJSpr                ;skip to last part if not yet at fifth frame ($03)
0A5D8 AD DB 06                             lda JumpspringForce
0A5DB 85 9F                                sta Player_Y_Speed          ;store jumpspring force as player's new vertical speed
0A5DD A9 00                                lda #$00
0A5DF 8D 0E 07                             sta JumpspringAnimCtrl      ;initialize jumpspring frame control
0A5E2 20 5F E0                  DrawJSpr:  jsr RelativeEnemyPosition   ;get jumpspring's relative coordinates
0A5E5 20 3E D7                             jsr EnemyGfxHandler         ;draw jumpspring
0A5E8 20 B5 C4                             jsr OffscreenBoundsCheck    ;check to see if we need to kill it
0A5EB AD 0E 07                             lda JumpspringAnimCtrl      ;if frame control at zero, don't bother
0A5EE F0 0D                                beq ExJSpring               ;trying to animate it, just leave
0A5F0 AD 86 07                             lda JumpspringTimer
0A5F3 D0 08                                bne ExJSpring               ;if jumpspring timer not expired yet, leave
0A5F5 A9 04                                lda #$04
0A5F7 8D 86 07                             sta JumpspringTimer         ;otherwise initialize jumpspring timer
0A5FA EE 0E 07                             inc JumpspringAnimCtrl      ;increment frame control to animate jumpspring
0A5FD 60                        ExJSpring: rts                         ;leave
0A5FE                           
0A5FE                           ;-------------------------------------------------------------------------------------
0A5FE                           
0A5FE                           Setup_Vine:
0A5FE A9 2F                             lda #VineObject          ;load identifier for vine object
0A600 95 16                             sta Enemy_ID,x           ;store in buffer
0A602 A9 01                             lda #$01
0A604 95 0F                             sta Enemy_Flag,x         ;set flag for enemy object buffer
0A606 B9 76 00                          lda Block_PageLoc,y
0A609 95 6E                             sta Enemy_PageLoc,x      ;copy page location from previous object
0A60B B9 8F 00                          lda Block_X_Position,y
0A60E 95 87                             sta Enemy_X_Position,x   ;copy horizontal coordinate from previous object
0A610 B9 D7 00                          lda Block_Y_Position,y
0A613 95 CF                             sta Enemy_Y_Position,x   ;copy vertical coordinate from previous object
0A615 AC 98 03                          ldy VineFlagOffset       ;load vine flag/offset to next available vine slot
0A618 D0 03                             bne NextVO               ;if set at all, don't bother to store vertical
0A61A 8D 9D 03                          sta VineStart_Y_Position ;otherwise store vertical coordinate here
0A61D 8A                        NextVO: txa                      ;store object offset to next available vine slot
0A61E 99 9A 03                          sta VineObjOffset,y      ;using vine flag as offset
0A621 EE 98 03                          inc VineFlagOffset       ;increment vine flag offset
0A624 A9 04                             lda #Sfx_GrowVine
0A626 85 FE                             sta Square2SoundQueue    ;load vine grow sound
0A628 60                                rts
0A629                           
0A629                           ;-------------------------------------------------------------------------------------
0A629                           ;$06-$07 - used as address to block buffer data
0A629                           ;$02 - used as vertical high nybble of block buffer offset
0A629                           
0A629                           VineHeightData:
0A629 30 60                           .db $30, $60
0A62B                           
0A62B                           VineObjectHandler:
0A62B E0 05                                 cpx #$05                  ;check enemy offset for special use slot
0A62D F0 01                                 beq ProcVO                ;if in special use slot, continue
0A62F 60                                    rts
0A630 AC 98 03                  ProcVO:     ldy VineFlagOffset
0A633 88                                    dey                       ;decrement vine flag in Y, use as offset
0A634 AD 99 03                              lda VineHeight
0A637 D9 29 A6                              cmp VineHeightData,y      ;if vine has reached certain height,
0A63A F0 0F                                 beq RunVSubs              ;branch ahead to skip this part
0A63C A5 09                                 lda FrameCounter          ;get frame counter
0A63E 4A                                    lsr                       ;shift d1 into carry
0A63F 4A                                    lsr
0A640 90 09                                 bcc RunVSubs              ;if d1 not set (2 frames every 4) skip this part
0A642 A5 D4                                 lda Enemy_Y_Position+5
0A644 E9 01                                 sbc #$01                  ;subtract vertical position of vine
0A646 85 D4                                 sta Enemy_Y_Position+5    ;one pixel every frame it's time
0A648 EE 99 03                              inc VineHeight            ;increment vine height
0A64B AD 99 03                  RunVSubs:   lda VineHeight            ;if vine still very small,
0A64E C9 08                                 cmp #$08                  ;branch to last part
0A650 90 46                                 bcc ChkVOffscr
0A652 20 5F E0                              jsr RelativeEnemyPosition ;get relative coordinates of vine,
0A655 20 BC E0                              jsr GetEnemyOffscreenBits ;and any offscreen bits
0A658 A0 00                                 ldy #$00                  ;initialize offset used in draw vine sub
0A65A 20 EB D2                  VDrawLoop:  jsr DrawVine              ;draw vine
0A65D C8                                    iny                       ;increment offset
0A65E CC 98 03                              cpy VineFlagOffset        ;if offset in Y and offset here
0A661 D0 F7                                 bne VDrawLoop             ;do not yet match, loop back to draw more vine
0A663 AD D1 03                              lda Enemy_OffscreenBits
0A666 29 0C                                 and #%00001100            ;mask offscreen bits
0A668 F0 10                                 beq WrCMTile              ;if none of the saved offscreen bits set, skip ahead
0A66A 88                                    dey                       ;otherwise decrement Y to get proper offset again
0A66B BE 9A 03                  KillVine:   ldx VineObjOffset,y       ;get enemy object offset for this vine object
0A66E 20 B1 B7                              jsr EraseEnemyObject      ;kill this vine object
0A671 88                                    dey                       ;decrement Y
0A672 10 F7                                 bpl KillVine              ;if any vine objects left, loop back to kill it
0A674 8D 98 03                              sta VineFlagOffset        ;initialize vine flag/offset
0A677 8D 99 03                              sta VineHeight            ;initialize vine height
0A67A AD 99 03                  WrCMTile:   lda VineHeight            ;check vine height
0A67D C9 20                                 cmp #$20                  ;if vine small (less than 32 pixels tall)
0A67F 90 17                                 bcc ChkVOffscr            ;then branch ahead to last part to skip this
0A681 A2 06                                 ldx #$06                  ;set offset in X to last enemy slot
0A683 A9 01                                 lda #$01                  ;set A to obtain horizontal in $04, but we don't care
0A685 A0 1B                                 ldy #$1b                  ;set Y to offset to get block at ($04, $10) of coordinates
0A687 20 A7 D2                              jsr BlockBufferCollision  ;do a sub to get block buffer address set, return contents
0A68A A4 02                                 ldy $02
0A68C C0 D0                                 cpy #$d0                  ;if vertical high nybble offset beyond extent of
0A68E B0 08                                 bcs ChkVOffscr            ;current block buffer, branch to leave, do not write
0A690 B1 06                                 lda ($06),y               ;otherwise check contents of block buffer at 
0A692 D0 04                                 bne ChkVOffscr            ;current offset, if not empty, branch to leave
0A694 A9 26                                 lda #$26
0A696 91 06                                 sta ($06),y               ;otherwise, write climbing metatile to block buffer
0A698 A5 8C                     ChkVOffscr: lda Enemy_X_Position+5
0A69A 38                                    sec
0A69B ED 1C 07                              sbc ScreenLeft_X_Pos
0A69E A8                                    tay
0A69F A5 73                                 lda Enemy_PageLoc+5       ;compare horizontal position of vine
0A6A1 ED 1A 07                              sbc ScreenLeft_PageLoc    ;to that of the left side of the screen
0A6A4 30 04                                 bmi VineOffscr            ;if vine isn't within 8 pixels of the edge
0A6A6 C0 09                                 cpy #$09                  ;or past the left edge, branch to leave
0A6A8 B0 2C                                 bcs ExitVH
0A6AA A9 00                     VineOffscr: lda #$00                  ;erase vine's flag to kill it
0A6AC 85 14                                 sta Enemy_Flag+5
0A6AE A5 73                                 lda Enemy_PageLoc+5
0A6B0 29 01                                 and #$01                  ;fetch the right block buffer address
0A6B2 A8                                    tay
0A6B3 B9 31 9B                              lda BlockBufferAddr,y
0A6B6 85 06                                 sta $06
0A6B8 B9 33 9B                              lda BlockBufferAddr+2,y
0A6BB 85 07                                 sta $07
0A6BD A5 8C                                 lda Enemy_X_Position+5    ;divide upper nybble of X position by 16
0A6BF 4A                                    lsr                       ;to get appropriate offset
0A6C0 4A                                    lsr
0A6C1 4A                                    lsr
0A6C2 4A                                    lsr
0A6C3 A8                        EraseClM:   tay
0A6C4 B1 06                                 lda ($06),y               ;check for climbing metatile
0A6C6 C9 26                                 cmp #$26                  ;if not found, move down a row
0A6C8 D0 04                                 bne NoClimbM
0A6CA A9 00                                 lda #$00                  ;otherwise erase climbing metatile
0A6CC 91 06                                 sta ($06),y
0A6CE 98                        NoClimbM:   tya
0A6CF 18                                    clc
0A6D0 69 10                                 adc #$10                  ;move 16 bytes (one row) ahead in block buffer
0A6D2 C9 D0                                 cmp #$d0                  ;if not at bottom row, loop
0A6D4 90 ED                                 bcc EraseClM
0A6D6 A6 08                     ExitVH:     ldx ObjectOffset          ;get enemy object offset and leave
0A6D8 60                                    rts
0A6D9                           
0A6D9                           ;-------------------------------------------------------------------------------------
0A6D9                           
0A6D9                           CannonBitmasks:
0A6D9 0F 07                           .db %00001111, %00000111
0A6DB                           
0A6DB                           ProcessCannons:
0A6DB AD 4E 07                             lda AreaType                ;get area type
0A6DE F0 6F                                beq ExCannon                ;if water type area, branch to leave
0A6E0 A2 02                                ldx #$02
0A6E2 86 08                     ThreeSChk: stx ObjectOffset            ;start at third enemy slot
0A6E4 B5 0F                                lda Enemy_Flag,x            ;check enemy buffer flag
0A6E6 D0 51                                bne Chk_BB                  ;if set, branch to check enemy
0A6E8 BD A8 07                             lda PseudoRandomBitReg+1,x  ;otherwise get part of LSFR
0A6EB AC CC 06                             ldy SecondaryHardMode       ;get secondary hard mode flag, use as offset
0A6EE 39 D9 A6                             and CannonBitmasks,y        ;mask out bits of LSFR as decided by flag
0A6F1 C9 06                                cmp #$06                    ;check to see if lower nybble is above certain value
0A6F3 B0 44                                bcs Chk_BB                  ;if so, branch to check enemy
0A6F5 A8                                   tay                         ;transfer masked contents of LSFR to Y as pseudorandom offset
0A6F6 B9 6B 04                             lda Cannon_PageLoc,y        ;get page location
0A6F9 F0 3E                                beq Chk_BB                  ;if not set or on page 0, branch to check enemy
0A6FB B9 7D 04                             lda Cannon_Timer,y          ;get cannon timer
0A6FE F0 08                                beq FireCannon              ;if expired, branch to fire cannon
0A700 E9 00                                sbc #$00                    ;otherwise subtract borrow (note carry will always be clear here)
0A702 99 7D 04                             sta Cannon_Timer,y          ;to count timer down
0A705 4C 39 A7                             jmp Chk_BB                  ;then jump ahead to check enemy
0A708                           
0A708                           FireCannon:
0A708 AD 47 07                            lda TimerControl           ;if master timer control set,
0A70B D0 2C                               bne Chk_BB                 ;branch to check enemy
0A70D A9 0E                               lda #$0e                   ;otherwise we start creating one
0A70F 99 7D 04                            sta Cannon_Timer,y         ;first, reset cannon timer
0A712 B9 6B 04                            lda Cannon_PageLoc,y       ;get page location of cannon
0A715 95 6E                               sta Enemy_PageLoc,x        ;save as page location of bullet bill
0A717 B9 71 04                            lda Cannon_X_Position,y    ;get horizontal coordinate of cannon
0A71A 95 87                               sta Enemy_X_Position,x     ;save as horizontal coordinate of bullet bill
0A71C B9 77 04                            lda Cannon_Y_Position,y    ;get vertical coordinate of cannon
0A71F 38                                  sec
0A720 E9 08                               sbc #$08                   ;subtract eight pixels (because enemies are 24 pixels tall)
0A722 95 CF                               sta Enemy_Y_Position,x     ;save as vertical coordinate of bullet bill
0A724 A9 01                               lda #$01
0A726 95 B6                               sta Enemy_Y_HighPos,x      ;set vertical high byte of bullet bill
0A728 95 0F                               sta Enemy_Flag,x           ;set buffer flag
0A72A 4A                                  lsr                        ;shift right once to init A
0A72B 95 1E                               sta Enemy_State,x          ;then initialize enemy's state
0A72D A9 09                               lda #$09
0A72F 9D 9A 04                            sta Enemy_BoundBoxCtrl,x   ;set bounding box size control for bullet bill
0A732 A9 33                               lda #BulletBill_CannonVar
0A734 95 16                               sta Enemy_ID,x             ;load identifier for bullet bill (cannon variant)
0A736 4C 4C A7                            jmp Next3Slt               ;move onto next slot
0A739 B5 16                     Chk_BB:   lda Enemy_ID,x             ;check enemy identifier for bullet bill (cannon variant)
0A73B C9 33                               cmp #BulletBill_CannonVar
0A73D D0 0D                               bne Next3Slt               ;if not found, branch to get next slot
0A73F 20 B5 C4                            jsr OffscreenBoundsCheck   ;otherwise, check to see if it went offscreen
0A742 B5 0F                               lda Enemy_Flag,x           ;check enemy buffer flag
0A744 F0 06                               beq Next3Slt               ;if not set, branch to get next slot
0A746 20 BC E0                            jsr GetEnemyOffscreenBits  ;otherwise, get offscreen information
0A749 20 52 A7                            jsr BulletBillHandler      ;then do sub to handle bullet bill
0A74C CA                        Next3Slt: dex                        ;move onto next slot
0A74D 10 93                               bpl ThreeSChk              ;do this until first three slots are checked
0A74F 60                        ExCannon: rts                        ;then leave
0A750                           
0A750                           ;--------------------------------
0A750                           
0A750                           BulletBillXSpdData:
0A750 18 E8                           .db $18, $e8
0A752                           
0A752                           BulletBillHandler:
0A752 AD 47 07                             lda TimerControl          ;if master timer control set,
0A755 D0 3E                                bne RunBBSubs             ;branch to run subroutines except movement sub
0A757 B5 1E                                lda Enemy_State,x
0A759 D0 2E                                bne ChkDSte               ;if bullet bill's state set, branch to check defeated state
0A75B AD D1 03                             lda Enemy_OffscreenBits   ;otherwise load offscreen bits
0A75E 29 0C                                and #%00001100            ;mask out bits
0A760 C9 0C                                cmp #%00001100            ;check to see if all bits are set
0A762 F0 40                                beq KillBB                ;if so, branch to kill this object
0A764 A0 01                                ldy #$01                  ;set to move right by default
0A766 20 F2 CF                             jsr PlayerEnemyDiff       ;get horizontal difference between player and bullet bill
0A769 30 01                                bmi SetupBB               ;if enemy to the left of player, branch
0A76B C8                                   iny                       ;otherwise increment to move left
0A76C 94 46                     SetupBB:   sty Enemy_MovingDir,x     ;set bullet bill's moving direction
0A76E 88                                   dey                       ;decrement to use as offset
0A76F B9 50 A7                             lda BulletBillXSpdData,y  ;get horizontal speed based on moving direction
0A772 95 58                                sta Enemy_X_Speed,x       ;and store it
0A774 A5 00                                lda $00                   ;get horizontal difference
0A776 69 28                                adc #$28                  ;add 40 pixels
0A778 C9 50                                cmp #$50                  ;if less than a certain amount, player is too close
0A77A 90 28                                bcc KillBB                ;to cannon either on left or right side, thus branch
0A77C A9 01                                lda #$01
0A77E 95 1E                                sta Enemy_State,x         ;otherwise set bullet bill's state
0A780 A9 0A                                lda #$0a
0A782 9D 8A 07                             sta EnemyFrameTimer,x     ;set enemy frame timer
0A785 A9 08                                lda #Sfx_Blast
0A787 85 FE                                sta Square2SoundQueue     ;play fireworks/gunfire sound
0A789 B5 1E                     ChkDSte:   lda Enemy_State,x         ;check enemy state for d5 set
0A78B 29 20                                and #%00100000
0A78D F0 03                                beq BBFly                 ;if not set, skip to move horizontally
0A78F 20 84 AC                             jsr MoveD_EnemyVertically ;otherwise do sub to move bullet bill vertically
0A792 20 23 AC                  BBFly:     jsr MoveEnemyHorizontally ;do sub to move bullet bill horizontally
0A795 20 BC E0                  RunBBSubs: jsr GetEnemyOffscreenBits ;get offscreen information
0A798 20 5F E0                             jsr RelativeEnemyPosition ;get relative coordinates
0A79B 20 FA D0                             jsr GetEnemyBoundBox      ;get bounding box coordinates
0A79E 20 AF C6                             jsr PlayerEnemyCollision  ;handle player to enemy collisions
0A7A1 4C 3E D7                             jmp EnemyGfxHandler       ;draw the bullet bill and leave
0A7A4 20 B1 B7                  KillBB:    jsr EraseEnemyObject      ;kill bullet bill and leave
0A7A7 60                                   rts
0A7A8                           
0A7A8                           ;-------------------------------------------------------------------------------------
0A7A8                           
0A7A8                           HammerEnemyOfsData:
0A7A8 04 04 04 05 05 05               .db $04, $04, $04, $05, $05, $05
0A7AE 06 06 06                        .db $06, $06, $06
0A7B1                           
0A7B1                           HammerXSpdData:
0A7B1 10 F0                           .db $10, $f0
0A7B3                           
0A7B3                           SpawnHammerObj:
0A7B3 AD A8 07                            lda PseudoRandomBitReg+1 ;get a pseudorandom number from 0 to 8
0A7B6 29 07                               and #%00000111           ;from the second part of LSFR
0A7B8 D0 05                               bne SetMOfs
0A7BA AD A8 07                            lda PseudoRandomBitReg+1
0A7BD 29 08                               and #%00001000
0A7BF A8                        SetMOfs:  tay                      ;use as misc object offset
0A7C0 B9 2A 00                            lda Misc_State,y         ;check for enemy state, if found, branch to leave
0A7C3 D0 19                               bne NoHammer
0A7C5 BE A8 A7                            ldx HammerEnemyOfsData,y ;get enemy slot offset number using misc obj offset
0A7C8 B5 0F                               lda Enemy_Flag,x         ;then check enemy buffer flag at that offset
0A7CA D0 12                               bne NoHammer             ;if buffer flag set, branch to leave with carry clear
0A7CC A6 08                               ldx ObjectOffset         ;get original enemy object offset
0A7CE 8A                                  txa
0A7CF 99 AE 06                            sta HammerEnemyOffset,y  ;save here
0A7D2 A9 90                               lda #$90
0A7D4 99 2A 00                            sta Misc_State,y         ;save hammer's state here
0A7D7 A9 07                               lda #$07
0A7D9 99 A2 04                            sta Misc_BoundBoxCtrl,y  ;set something else entirely, here
0A7DC 38                                  sec                      ;return with carry set
0A7DD 60                                  rts
0A7DE A6 08                     NoHammer: ldx ObjectOffset         ;get original enemy object offset
0A7E0 18                                  clc                      ;return with carry clear
0A7E1 60                                  rts
0A7E2                           
0A7E2                           ;--------------------------------
0A7E2                           ;$00 - used to set downward force
0A7E2                           ;$01 - used to set upward force (residual)
0A7E2                           ;$02 - used to set maximum speed
0A7E2                           
0A7E2                           ProcHammerObj:
0A7E2 AD 47 07                            lda TimerControl           ;if master timer control set
0A7E5 D0 63                               bne RunHSubs               ;skip all of this code and go to last subs at the end
0A7E7 B5 2A                               lda Misc_State,x           ;otherwise get hammer's state
0A7E9 29 7F                               and #%01111111             ;mask out d7
0A7EB BC AE 06                            ldy HammerEnemyOffset,x    ;get enemy object offset that spawned this hammer
0A7EE C9 02                               cmp #$02                   ;check hammer's state
0A7F0 F0 20                               beq SetHSpd                ;if currently at 2, branch
0A7F2 B0 34                               bcs SetHPos                ;if greater than 2, branch elsewhere
0A7F4 8A                                  txa
0A7F5 18                                  clc                        ;add 13 bytes to use
0A7F6 69 0D                               adc #$0d                   ;proper misc object
0A7F8 AA                                  tax                        ;return offset to X
0A7F9 A9 10                               lda #$10
0A7FB 85 00                               sta $00                    ;set downward movement force
0A7FD A9 0F                               lda #$0f
0A7FF 85 01                               sta $01                    ;set upward movement force (not used)
0A801 A9 04                               lda #$04
0A803 85 02                               sta $02                    ;set maximum vertical speed
0A805 A9 00                               lda #$00                   ;set A to impose gravity on hammer
0A807 20 F8 AC                            jsr ImposeGravity          ;do sub to impose gravity on hammer and move vertically
0A80A 20 30 AC                            jsr MoveObjectHorizontally ;do sub to move it horizontally
0A80D A6 08                               ldx ObjectOffset           ;get original misc object offset
0A80F 4C 47 A8                            jmp RunAllH                ;branch to essential subroutines
0A812 A9 FE                     SetHSpd:  lda #$fe
0A814 95 AC                               sta Misc_Y_Speed,x         ;set hammer's vertical speed
0A816 B9 1E 00                            lda Enemy_State,y          ;get enemy object state
0A819 29 F7                               and #%11110111             ;mask out d3
0A81B 99 1E 00                            sta Enemy_State,y          ;store new state
0A81E B6 46                               ldx Enemy_MovingDir,y      ;get enemy's moving direction
0A820 CA                                  dex                        ;decrement to use as offset
0A821 BD B1 A7                            lda HammerXSpdData,x       ;get proper speed to use based on moving direction
0A824 A6 08                               ldx ObjectOffset           ;reobtain hammer's buffer offset
0A826 95 64                               sta Misc_X_Speed,x         ;set hammer's horizontal speed
0A828 D6 2A                     SetHPos:  dec Misc_State,x           ;decrement hammer's state
0A82A B9 87 00                            lda Enemy_X_Position,y     ;get enemy's horizontal position
0A82D 18                                  clc
0A82E 69 02                               adc #$02                   ;set position 2 pixels to the right
0A830 95 93                               sta Misc_X_Position,x      ;store as hammer's horizontal position
0A832 B9 6E 00                            lda Enemy_PageLoc,y        ;get enemy's page location
0A835 69 00                               adc #$00                   ;add carry
0A837 95 7A                               sta Misc_PageLoc,x         ;store as hammer's page location
0A839 B9 CF 00                            lda Enemy_Y_Position,y     ;get enemy's vertical position
0A83C 38                                  sec
0A83D E9 0A                               sbc #$0a                   ;move position 10 pixels upward
0A83F 95 DB                               sta Misc_Y_Position,x      ;store as hammer's vertical position
0A841 A9 01                               lda #$01
0A843 95 C2                               sta Misc_Y_HighPos,x       ;set hammer's vertical high byte
0A845 D0 03                               bne RunHSubs               ;unconditional branch to skip first routine
0A847 20 14 C6                  RunAllH:  jsr PlayerHammerCollision  ;handle collisions
0A84A 20 A8 E0                  RunHSubs: jsr GetMiscOffscreenBits   ;get offscreen information
0A84D 20 55 E0                            jsr RelativeMiscPosition   ;get relative coordinates
0A850 20 ED D0                            jsr GetMiscBoundBox        ;get bounding box coordinates
0A853 20 92 D3                            jsr DrawHammer             ;draw the hammer
0A856 60                                  rts                        ;and we are done here
0A857                           
0A857                           ;-------------------------------------------------------------------------------------
0A857                           ;$02 - used to store vertical high nybble offset from block buffer routine
0A857                           ;$06 - used to store low byte of block buffer address
0A857                           
0A857                           CoinBlock:
0A857 20 A3 A8                        jsr FindEmptyMiscSlot   ;set offset for empty or last misc object buffer slot
0A85A B5 76                           lda Block_PageLoc,x     ;get page location of block object
0A85C 99 7A 00                        sta Misc_PageLoc,y      ;store as page location of misc object
0A85F B5 8F                           lda Block_X_Position,x  ;get horizontal coordinate of block object
0A861 09 05                           ora #$05                ;add 5 pixels
0A863 99 93 00                        sta Misc_X_Position,y   ;store as horizontal coordinate of misc object
0A866 B5 D7                           lda Block_Y_Position,x  ;get vertical coordinate of block object
0A868 E9 10                           sbc #$10                ;subtract 16 pixels
0A86A 99 DB 00                        sta Misc_Y_Position,y   ;store as vertical coordinate of misc object
0A86D 4C 8B A8                        jmp JCoinC              ;jump to rest of code as applies to this misc object
0A870                           
0A870                           SetupJumpCoin:
0A870 20 A3 A8                          jsr FindEmptyMiscSlot  ;set offset for empty or last misc object buffer slot
0A873 BD EA 03                          lda Block_PageLoc2,x   ;get page location saved earlier
0A876 99 7A 00                          sta Misc_PageLoc,y     ;and save as page location for misc object
0A879 A5 06                             lda $06                ;get low byte of block buffer offset
0A87B 0A                                asl
0A87C 0A                                asl                    ;multiply by 16 to use lower nybble
0A87D 0A                                asl
0A87E 0A                                asl
0A87F 09 05                             ora #$05               ;add five pixels
0A881 99 93 00                          sta Misc_X_Position,y  ;save as horizontal coordinate for misc object
0A884 A5 02                             lda $02                ;get vertical high nybble offset from earlier
0A886 69 20                             adc #$20               ;add 32 pixels for the status bar
0A888 99 DB 00                          sta Misc_Y_Position,y  ;store as vertical coordinate
0A88B A9 FB                     JCoinC: lda #$fb
0A88D 99 AC 00                          sta Misc_Y_Speed,y     ;set vertical speed
0A890 A9 01                             lda #$01
0A892 99 C2 00                          sta Misc_Y_HighPos,y   ;set vertical high byte
0A895 99 2A 00                          sta Misc_State,y       ;set state for misc object
0A898 85 FE                             sta Square2SoundQueue  ;load coin grab sound
0A89A 86 08                             stx ObjectOffset       ;store current control bit as misc object offset 
0A89C 20 17 A9                          jsr GiveOneCoin        ;update coin tally on the screen and coin amount variable
0A89F EE 48 07                          inc CoinTallyFor1Ups   ;increment coin tally used to activate 1-up block flag
0A8A2 60                                rts
0A8A3                           
0A8A3                           FindEmptyMiscSlot:
0A8A3 A0 08                                ldy #$08                ;start at end of misc objects buffer
0A8A5 B9 2A 00                  FMiscLoop: lda Misc_State,y        ;get misc object state
0A8A8 F0 07                                beq UseMiscS            ;branch if none found to use current offset
0A8AA 88                                   dey                     ;decrement offset
0A8AB C0 05                                cpy #$05                ;do this for three slots
0A8AD D0 F6                                bne FMiscLoop           ;do this until all slots are checked
0A8AF A0 08                                ldy #$08                ;if no empty slots found, use last slot
0A8B1 8C B7 06                  UseMiscS:  sty JumpCoinMiscOffset  ;store offset of misc object buffer here (residual)
0A8B4 60                                   rts
0A8B5                           
0A8B5                           ;-------------------------------------------------------------------------------------
0A8B5                           
0A8B5                           MiscObjectsCore:
0A8B5 A2 08                               ldx #$08          ;set at end of misc object buffer
0A8B7 86 08                     MiscLoop: stx ObjectOffset  ;store misc object offset here
0A8B9 B5 2A                               lda Misc_State,x  ;check misc object state
0A8BB F0 56                               beq MiscLoopBack  ;branch to check next slot
0A8BD 0A                                  asl               ;otherwise shift d7 into carry
0A8BE 90 06                               bcc ProcJumpCoin  ;if d7 not set, jumping coin, thus skip to rest of code here
0A8C0 20 E2 A7                            jsr ProcHammerObj ;otherwise go to process hammer,
0A8C3 4C 13 A9                            jmp MiscLoopBack  ;then check next slot
0A8C6                           
0A8C6                           ;--------------------------------
0A8C6                           ;$00 - used to set downward force
0A8C6                           ;$01 - used to set upward force (residual)
0A8C6                           ;$02 - used to set maximum speed
0A8C6                           
0A8C6                           ProcJumpCoin:
0A8C6 B4 2A                                ldy Misc_State,x          ;check misc object state
0A8C8 88                                   dey                       ;decrement to see if it's set to 1
0A8C9 F0 1D                                beq JCoinRun              ;if so, branch to handle jumping coin
0A8CB F6 2A                                inc Misc_State,x          ;otherwise increment state to either start off or as timer
0A8CD B5 93                                lda Misc_X_Position,x     ;get horizontal coordinate for misc object
0A8CF 18                                   clc                       ;whether its jumping coin (state 0 only) or floatey number
0A8D0 6D 75 07                             adc ScrollAmount          ;add current scroll speed
0A8D3 95 93                                sta Misc_X_Position,x     ;store as new horizontal coordinate
0A8D5 B5 7A                                lda Misc_PageLoc,x        ;get page location
0A8D7 69 00                                adc #$00                  ;add carry
0A8D9 95 7A                                sta Misc_PageLoc,x        ;store as new page location
0A8DB B5 2A                                lda Misc_State,x
0A8DD C9 30                                cmp #$30                  ;check state of object for preset value
0A8DF D0 26                                bne RunJCSubs             ;if not yet reached, branch to subroutines
0A8E1 A9 00                                lda #$00
0A8E3 95 2A                                sta Misc_State,x          ;otherwise nullify object state
0A8E5 4C 13 A9                             jmp MiscLoopBack          ;and move onto next slot
0A8E8 8A                        JCoinRun:  txa             
0A8E9 18                                   clc                       ;add 13 bytes to offset for next subroutine
0A8EA 69 0D                                adc #$0d
0A8EC AA                                   tax
0A8ED A9 50                                lda #$50                  ;set downward movement amount
0A8EF 85 00                                sta $00
0A8F1 A9 06                                lda #$06                  ;set maximum vertical speed
0A8F3 85 02                                sta $02
0A8F5 4A                                   lsr                       ;divide by 2 and set
0A8F6 85 01                                sta $01                   ;as upward movement amount (apparently residual)
0A8F8 A9 00                                lda #$00                  ;set A to impose gravity on jumping coin
0A8FA 20 F8 AC                             jsr ImposeGravity         ;do sub to move coin vertically and impose gravity on it
0A8FD A6 08                                ldx ObjectOffset          ;get original misc object offset
0A8FF B5 AC                                lda Misc_Y_Speed,x        ;check vertical speed
0A901 C9 05                                cmp #$05
0A903 D0 02                                bne RunJCSubs             ;if not moving downward fast enough, keep state as-is
0A905 F6 2A                                inc Misc_State,x          ;otherwise increment state to change to floatey number
0A907 20 55 E0                  RunJCSubs: jsr RelativeMiscPosition  ;get relative coordinates
0A90A 20 A8 E0                             jsr GetMiscOffscreenBits  ;get offscreen information
0A90D 20 ED D0                             jsr GetMiscBoundBox       ;get bounding box coordinates (why?)
0A910 20 3E D5                             jsr JCoinGfxHandler       ;draw the coin or floatey number
0A913                           
0A913                           MiscLoopBack: 
0A913 CA                                   dex                       ;decrement misc object offset
0A914 10 A1                                bpl MiscLoop              ;loop back until all misc objects handled
0A916 60                                   rts                       ;then leave
0A917                           
0A917                           ;-------------------------------------------------------------------------------------
0A917                           
0A917                           GiveOneCoin:
0A917 A9 01                           lda #$01               ;set digit modifier to add 1 coin
0A919 8D 39 01                        sta DigitModifier+5    ;to the current player's coin tally
0A91C A0 11                           ldy #$11               ;set offset for coin tally
0A91E 20 4D 8E                        jsr DigitsMathRoutine  ;update the coin tally
0A921 EE 5E 07                        inc CoinTally          ;increment onscreen player's coin amount
0A924 AD 5E 07                        lda CoinTally
0A927 C9 64                           cmp #100               ;does player have 100 coins yet?
0A929 D0 08                           bne CoinPoints         ;if not, skip all of this
0A92B A9 00                           lda #$00
0A92D 8D 5E 07                        sta CoinTally          ;otherwise, reinitialize coin amount
0A930 20 80 84                        jsr GiveExtraLife      ;award an extra life
0A933                           
0A933                           CoinPoints:
0A933 A9 02                           lda #$02               ;set digit modifier to award
0A935 8D 38 01                        sta DigitModifier+4    ;200 points to the player
0A938                           
0A938                           AddToScore:
0A938 A0 0B                           ldy #$0b               ;get offset for player's score
0A93A 20 4D 8E                        jsr DigitsMathRoutine  ;update the score internally with value in digit modifier
0A93D                           
0A93D                           WriteScoreAndCoinTally:
0A93D A9 01                             lda #$01
0A93F                           WriteDigits:
0A93F 20 F4 8D                          jsr PrintStatusBarNumbers ;print status bar numbers
0A942 AC 00 03                          ldy VRAM_Buffer1_Offset   
0A945 B9 FB 02                          lda VRAM_Buffer1-6,y      ;check highest digit of score
0A948 D0 05                             bne NoZSup                ;if zero, overwrite with space tile for zero suppression
0A94A A9 24                             lda #$24
0A94C 99 FB 02                          sta VRAM_Buffer1-6,y
0A94F A6 08                     NoZSup: ldx ObjectOffset          ;get enemy object buffer offset
0A951 60                                rts
0A952                           
0A952                           ;-------------------------------------------------------------------------------------
0A952                           
0A952                           SetupPowerUp:
0A952 A9 2E                                lda #PowerUpObject        ;load power-up identifier into
0A954 85 1B                                sta Enemy_ID+5            ;special use slot of enemy object buffer
0A956 B5 76                                lda Block_PageLoc,x       ;store page location of block object
0A958 85 73                                sta Enemy_PageLoc+5       ;as page location of power-up object
0A95A B5 8F                                lda Block_X_Position,x    ;store horizontal coordinate of block object
0A95C 85 8C                                sta Enemy_X_Position+5    ;as horizontal coordinate of power-up object
0A95E A9 01                                lda #$01
0A960 85 BB                                sta Enemy_Y_HighPos+5     ;set vertical high byte of power-up object
0A962 B5 D7                                lda Block_Y_Position,x    ;get vertical coordinate of block object
0A964 38                                   sec
0A965 E9 08                                sbc #$08                  ;subtract 8 pixels
0A967 85 D4                                sta Enemy_Y_Position+5    ;and use as vertical coordinate of power-up object
0A969 A9 01                     PwrUpJmp:  lda #$01                  ;this is a residual jump point in enemy object jump table
0A96B 85 23                                sta Enemy_State+5         ;set power-up object's state
0A96D 85 14                                sta Enemy_Flag+5          ;set buffer flag
0A96F A9 03                                lda #$03
0A971 8D 9F 04                             sta Enemy_BoundBoxCtrl+5  ;set bounding box size control for power-up object
0A974 A5 39                                lda PowerUpType
0A976 C9 02                                cmp #$02                  ;check currently loaded power-up type
0A978 B0 0A                                bcs PutBehind             ;if star or 1-up, branch ahead
0A97A AD 56 07                             lda PlayerStatus          ;otherwise check player's current status
0A97D C9 02                                cmp #$02
0A97F 90 01                                bcc StrType               ;if player not fiery, use status as power-up type
0A981 4A                                   lsr                       ;otherwise shift right to force fire flower type
0A982 85 39                     StrType:   sta PowerUpType           ;store type here
0A984 A9 20                     PutBehind: lda #%00100000
0A986 8D CA 03                             sta Enemy_SprAttrib+5     ;set background priority bit
0A989 A9 02                                lda #Sfx_GrowPowerUp
0A98B 85 FE                                sta Square2SoundQueue     ;load power-up reveal sound and leave
0A98D 60                                   rts
0A98E                           
0A98E                           ;-------------------------------------------------------------------------------------
0A98E                           
0A98E                           PowerUpObjHandler:
0A98E A2 05                              ldx #$05                   ;set object offset for last slot in enemy object buffer
0A990 86 08                              stx ObjectOffset
0A992 A5 23                              lda Enemy_State+5          ;check power-up object's state
0A994 F0 65                              beq ExitPUp                ;if not set, branch to leave
0A996 0A                                 asl                        ;shift to check if d7 was set in object state
0A997 90 2B                              bcc GrowThePowerUp         ;if not set, branch ahead to skip this part
0A999 AD 47 07                           lda TimerControl           ;if master timer control set,
0A99C D0 4B                              bne RunPUSubs              ;branch ahead to enemy object routines
0A99E A5 39                              lda PowerUpType            ;check power-up type
0A9A0 F0 19                              beq ShroomM                ;if normal mushroom, branch ahead to move it
0A9A2 C9 03                              cmp #$03
0A9A4 F0 15                              beq ShroomM                ;if 1-up mushroom, branch ahead to move it
0A9A6 C9 04                              cmp #$04
0A9A8 F0 11                              beq ShroomM
0A9AA C9 05                              cmp #$05
0A9AC F0 0D                              beq ShroomM
0A9AE C9 02                              cmp #$02
0A9B0 D0 37                              bne RunPUSubs              ;if not star, branch elsewhere to skip movement
0A9B2 20 12 B9                           jsr MoveJumpingEnemy       ;otherwise impose gravity on star power-up and make it jump
0A9B5 20 12 D0                           jsr EnemyJump              ;note that green paratroopa shares the same code here 
0A9B8 4C E9 A9                           jmp RunPUSubs              ;then jump to other power-up subroutines
0A9BB 20 90 B8                  ShroomM: jsr MoveNormalEnemy        ;do sub to make mushrooms move
0A9BE 20 63 CE                           jsr EnemyToBGCollisionDet  ;deal with collisions
0A9C1 4C E9 A9                           jmp RunPUSubs              ;run the other subroutines
0A9C4                           
0A9C4                           GrowThePowerUp:
0A9C4 A5 09                                lda FrameCounter           ;get frame counter
0A9C6 29 03                                and #$03                   ;mask out all but 2 LSB
0A9C8 D0 19                                bne ChkPUSte               ;if any bits set here, branch
0A9CA C6 D4                                dec Enemy_Y_Position+5     ;otherwise decrement vertical coordinate slowly
0A9CC A5 23                                lda Enemy_State+5          ;load power-up object state
0A9CE E6 23                                inc Enemy_State+5          ;increment state for next frame (to make power-up rise)
0A9D0 C9 11                                cmp #$11                   ;if power-up object state not yet past 16th pixel,
0A9D2 90 0F                                bcc ChkPUSte               ;branch ahead to last part here
0A9D4 A9 10                                lda #$10
0A9D6 95 58                                sta Enemy_X_Speed,x        ;otherwise set horizontal speed
0A9D8 A9 80                                lda #%10000000
0A9DA 85 23                                sta Enemy_State+5          ;and then set d7 in power-up object's state
0A9DC 0A                                   asl                        ;shift once to init A
0A9DD 8D CA 03                             sta Enemy_SprAttrib+5      ;initialize background priority bit set here
0A9E0 2A                                   rol                        ;rotate A to set right moving direction
0A9E1 95 46                                sta Enemy_MovingDir,x      ;set moving direction
0A9E3 A5 23                     ChkPUSte:  lda Enemy_State+5          ;check power-up object's state
0A9E5 C9 06                                cmp #$06                   ;for if power-up has risen enough
0A9E7 90 12                                bcc ExitPUp                ;if not, don't even bother running these routines
0A9E9 20 5F E0                  RunPUSubs: jsr RelativeEnemyPosition  ;get coordinates relative to screen
0A9EC 20 BC E0                             jsr GetEnemyOffscreenBits  ;get offscreen bits
0A9EF 20 FA D0                             jsr GetEnemyBoundBox       ;get bounding box coordinates
0A9F2 20 8F D5                             jsr DrawPowerUp            ;draw the power-up object
0A9F5 20 AF C6                             jsr PlayerEnemyCollision   ;check for collision with player
0A9F8 20 B5 C4                             jsr OffscreenBoundsCheck   ;check to see if it went offscreen
0A9FB 60                        ExitPUp:   rts                        ;and we're done
0A9FC                           
0A9FC                           ;-------------------------------------------------------------------------------------
0A9FC                           ;These apply to all routines in this section unless otherwise noted:
0A9FC                           ;$00 - used to store metatile from block buffer routine
0A9FC                           ;$02 - used to store vertical high nybble offset from block buffer routine
0A9FC                           ;$05 - used to store metatile stored in A at beginning of PlayerHeadCollision
0A9FC                           ;$06-$07 - used as block buffer address indirect
0A9FC                           
0A9FC                           BlockYPosAdderData:
0A9FC 04 12                           .db $04, $12
0A9FE                           
0A9FE                           PlayerHeadCollision:
0A9FE 48                                   pha                      ;store metatile number to stack
0A9FF A9 11                                lda #$11                 ;load unbreakable block object state by default
0AA01 AE EE 03                             ldx SprDataOffset_Ctrl   ;load offset control bit here
0AA04 AC 54 07                             ldy PlayerSize           ;check player's size
0AA07 D0 02                                bne DBlockSte            ;if small, branch
0AA09 A9 12                                lda #$12                 ;otherwise load breakable block object state
0AA0B 95 26                     DBlockSte: sta Block_State,x        ;store into block object buffer
0AA0D 20 9B 89                             jsr DestroyBlockMetatile ;store blank metatile in vram buffer to write to name table
0AA10 AE EE 03                             ldx SprDataOffset_Ctrl   ;load offset control bit
0AA13 A5 02                                lda $02                  ;get vertical high nybble offset used in block buffer routine
0AA15 9D E4 03                             sta Block_Orig_YPos,x    ;set as vertical coordinate for block object
0AA18 A8                                   tay
0AA19 A5 06                                lda $06                  ;get low byte of block buffer address used in same routine
0AA1B 9D E6 03                             sta Block_BBuf_Low,x     ;save as offset here to be used later
0AA1E B1 06                                lda ($06),y              ;get contents of block buffer at old address at $06, $07
0AA20 20 17 AB                             jsr BlockBumpedChk       ;do a sub to check which block player bumped head on
0AA23 85 00                                sta $00                  ;store metatile here
0AA25 AC 54 07                             ldy PlayerSize           ;check player's size
0AA28 D0 01                                bne ChkBrick             ;if small, use metatile itself as contents of A
0AA2A 98                                   tya                      ;otherwise init A (note: big = 0)
0AA2B 90 25                     ChkBrick:  bcc PutMTileB            ;if no match was found in previous sub, skip ahead
0AA2D A0 11                                ldy #$11                 ;otherwise load unbreakable state into block object buffer
0AA2F 94 26                                sty Block_State,x        ;note this applies to both player sizes
0AA31 A9 C5                                lda #$c5                 ;load empty block metatile into A for now
0AA33 A4 00                                ldy $00                  ;get metatile from before
0AA35 C0 58                                cpy #$58                 ;is it brick with coins (with line)?
0AA37 F0 04                                beq StartBTmr            ;if so, branch
0AA39 C0 5E                                cpy #$5e                 ;is it brick with coins (without line)?
0AA3B D0 15                                bne PutMTileB            ;if not, branch ahead to store empty block metatile
0AA3D AD BC 06                  StartBTmr: lda BrickCoinTimerFlag   ;check brick coin timer flag
0AA40 D0 08                                bne ContBTmr             ;if set, timer expired or counting down, thus branch
0AA42 A9 0B                                lda #$0b
0AA44 8D 9D 07                             sta BrickCoinTimer       ;if not set, set brick coin timer
0AA47 EE BC 06                             inc BrickCoinTimerFlag   ;and set flag linked to it
0AA4A AD 9D 07                  ContBTmr:  lda BrickCoinTimer       ;check brick coin timer
0AA4D D0 02                                bne PutOldMT             ;if not yet expired, branch to use current metatile
0AA4F A0 C5                                ldy #$c5                 ;otherwise use empty block metatile
0AA51 98                        PutOldMT:  tya                      ;put metatile into A
0AA52 9D E8 03                  PutMTileB: sta Block_Metatile,x     ;store whatever metatile be appropriate here
0AA55 20 95 AA                             jsr InitBlock_XY_Pos     ;get block object horizontal coordinates saved
0AA58 A4 02                                ldy $02                  ;get vertical high nybble offset
0AA5A A9 23                                lda #$23
0AA5C 91 06                                sta ($06),y              ;write blank metatile $23 to block buffer
0AA5E A9 10                                lda #$10
0AA60 8D 84 07                             sta BlockBounceTimer     ;set block bounce timer
0AA63 68                                   pla                      ;pull original metatile from stack
0AA64 85 05                                sta $05                  ;and save here
0AA66 A0 00                                ldy #$00                 ;set default offset
0AA68 AD 14 07                             lda CrouchingFlag        ;is player crouching?
0AA6B D0 05                                bne SmallBP              ;if so, branch to increment offset
0AA6D AD 54 07                             lda PlayerSize           ;is player big?
0AA70 F0 01                                beq BigBP                ;if so, branch to use default offset
0AA72 C8                        SmallBP:   iny                      ;increment for small or big and crouching
0AA73 A5 CE                     BigBP:     lda Player_Y_Position    ;get player's vertical coordinate
0AA75 18                                   clc
0AA76 79 FC A9                             adc BlockYPosAdderData,y ;add value determined by size
0AA79 29 F0                                and #$f0                 ;mask out low nybble to get 16-pixel correspondence
0AA7B 95 D7                                sta Block_Y_Position,x   ;save as vertical coordinate for block object
0AA7D B4 26                                ldy Block_State,x        ;get block object state
0AA7F C0 11                                cpy #$11
0AA81 F0 06                                beq Unbreak              ;if set to value loaded for unbreakable, branch
0AA83 20 23 AB                             jsr BrickShatter         ;execute code for breakable brick
0AA86 4C 8C AA                             jmp InvOBit              ;skip subroutine to do last part of code here
0AA89 20 AC AA                  Unbreak:   jsr BumpBlock            ;execute code for unbreakable brick or question block
0AA8C AD EE 03                  InvOBit:   lda SprDataOffset_Ctrl   ;invert control bit used by block objects
0AA8F 49 01                                eor #$01                 ;and floatey numbers
0AA91 8D EE 03                             sta SprDataOffset_Ctrl
0AA94 60                                   rts                      ;leave!
0AA95                           
0AA95                           ;--------------------------------
0AA95                           
0AA95                           InitBlock_XY_Pos:
0AA95 A5 86                           lda Player_X_Position   ;get player's horizontal coordinate
0AA97 18                              clc
0AA98 69 08                           adc #$08                ;add eight pixels
0AA9A 29 F0                           and #$f0                ;mask out low nybble to give 16-pixel correspondence
0AA9C 95 8F                           sta Block_X_Position,x  ;save as horizontal coordinate for block object
0AA9E A5 6D                           lda Player_PageLoc
0AAA0 69 00                           adc #$00                ;add carry to page location of player
0AAA2 95 76                           sta Block_PageLoc,x     ;save as page location of block object
0AAA4 9D EA 03                        sta Block_PageLoc2,x    ;save elsewhere to be used later
0AAA7 A5 B5                           lda Player_Y_HighPos
0AAA9 95 BE                           sta Block_Y_HighPos,x   ;save vertical high byte of player into
0AAAB 60                              rts                     ;vertical high byte of block object and leave
0AAAC                           
0AAAC                           ;--------------------------------
0AAAC                           
0AAAC                           BumpBlock:
0AAAC 20 40 AB                             jsr CheckTopOfBlock     ;check to see if there's a coin directly above this block
0AAAF A9 02                                lda #Sfx_Bump
0AAB1 85 FF                                sta Square1SoundQueue   ;play bump sound
0AAB3 A9 00                                lda #$00
0AAB5 95 60                                sta Block_X_Speed,x     ;initialize horizontal speed for block object
0AAB7 9D 3C 04                             sta Block_Y_MoveForce,x ;init fractional movement force
0AABA 85 9F                                sta Player_Y_Speed      ;init player's vertical speed
0AABC A9 FE                                lda #$fe
0AABE 95 A8                                sta Block_Y_Speed,x     ;set vertical speed for block object
0AAC0 A5 05                                lda $05                 ;get original metatile from stack
0AAC2 20 17 AB                             jsr BlockBumpedChk      ;do a sub to check which block player bumped head on
0AAC5 90 3C                                bcc ExitBlockChk        ;if no match was found, branch to leave
0AAC7 98                                   tya                     ;move block number to A
0AAC8 C9 0D                                cmp #$0d                ;if block number was within 0-$c range,
0AACA 90 02                                bcc BlockCode           ;branch to use current number
0AACC E9 06                                sbc #$06                ;otherwise subtract 6 for second set to get proper number
0AACE 20 F8 8C                  BlockCode: jsr JumpEngine          ;run appropriate subroutine depending on block number
0AAD1                           
0AAD1 EB AA                           .dw MushFlowerBlock
0AAD3 F1 AA                           .dw PoisonMushBlock
0AAD5 57 A8                           .dw CoinBlock
0AAD7 57 A8                           .dw CoinBlock
0AAD9 F4 AA                           .dw ExtraLifeMushBlock
0AADB F1 AA                           .dw PoisonMushBlock
0AADD EB AA                           .dw MushFlowerBlock
0AADF EB AA                           .dw MushFlowerBlock
0AAE1 F1 AA                           .dw PoisonMushBlock
0AAE3 FB AA                           .dw VineBlock
0AAE5 EE AA                           .dw StarBlock
0AAE7 57 A8                           .dw CoinBlock
0AAE9 F4 AA                           .dw ExtraLifeMushBlock
0AAEB                           
0AAEB                           MushFlowerBlock:
0AAEB A9 00                           lda #$00                ;load mushroom/flower type
0AAED 2C                              .db $2c
0AAEE                           
0AAEE                           StarBlock:
0AAEE A9 02                           lda #$02                ;load star type
0AAF0 2C                              .db $2c
0AAF1                           
0AAF1                           PoisonMushBlock:
0AAF1 A9 04                           lda #$04                ;load poison mushroom type
0AAF3 2C                              .db $2c
0AAF4                           
0AAF4                           ExtraLifeMushBlock:
0AAF4 A9 03                           lda #$03                ;load 1-up mushroom type
0AAF6 85 39                           sta $39                 ;store correct power-up type
0AAF8 4C 52 A9                        jmp SetupPowerUp
0AAFB                           
0AAFB                           VineBlock:
0AAFB A2 05                           ldx #$05                ;load last slot for enemy object buffer
0AAFD AC EE 03                        ldy SprDataOffset_Ctrl  ;get control bit
0AB00 20 FE A5                        jsr Setup_Vine          ;set up vine object
0AB03                           
0AB03                           ExitBlockChk:
0AB03 60                              rts                     ;leave
0AB04                           
0AB04                           ;--------------------------------
0AB04                           
0AB04                           BrickQBlockMetatiles:
0AB04 C1 C2 C0 60 61 62 63            .db $c1, $c2, $c0, $60, $61, $62, $63 ;used by question blocks
0AB0B                           
0AB0B 54 55 56 57 58 59               .db $54, $55, $56, $57, $58, $59 ;used by ground level bricks
0AB11 5A 5B 5C 5D 5E 5F               .db $5a, $5b, $5c, $5d, $5e, $5f ;used by other level bricks
0AB17                           
0AB17                           BlockBumpedChk:
0AB17 A0 12                                  ldy #$12                    ;start at end of metatile data
0AB19 D9 04 AB                  BumpChkLoop: cmp BrickQBlockMetatiles,y  ;check to see if current metatile matches
0AB1C F0 04                                  beq MatchBump               ;metatile found in block buffer, branch if so
0AB1E 88                                     dey                         ;otherwise move onto next metatile
0AB1F 10 F8                                  bpl BumpChkLoop             ;do this until all metatiles are checked
0AB21 18                                     clc                         ;if none match, return with carry clear
0AB22 60                        MatchBump:   rts                         ;note carry is set if found match
0AB23                           
0AB23                           ;--------------------------------
0AB23                           
0AB23                           BrickShatter:
0AB23 20 40 AB                        jsr CheckTopOfBlock    ;check to see if there's a coin directly above this block
0AB26 A9 01                           lda #Sfx_BrickShatter
0AB28 9D EC 03                        sta Block_RepFlag,x    ;set flag for block object to immediately replace metatile
0AB2B 85 FD                           sta NoiseSoundQueue    ;load brick shatter sound
0AB2D 20 62 AB                        jsr SpawnBrickChunks   ;create brick chunk objects
0AB30 A9 FE                           lda #$fe
0AB32 85 9F                           sta Player_Y_Speed     ;set vertical speed for player
0AB34 A9 05                           lda #$05
0AB36 8D 39 01                        sta DigitModifier+5    ;set digit modifier to give player 50 points
0AB39 20 38 A9                        jsr AddToScore         ;do sub to update the score
0AB3C AE EE 03                        ldx SprDataOffset_Ctrl ;load control bit and leave
0AB3F 60                              rts
0AB40                           
0AB40                           ;--------------------------------
0AB40                           
0AB40                           CheckTopOfBlock:
0AB40 AE EE 03                         ldx SprDataOffset_Ctrl  ;load control bit
0AB43 A4 02                            ldy $02                 ;get vertical high nybble offset used in block buffer
0AB45 F0 1A                            beq TopEx               ;branch to leave if set to zero, because we're at the top
0AB47 98                               tya                     ;otherwise set to A
0AB48 38                               sec
0AB49 E9 10                            sbc #$10                ;subtract $10 to move up one row in the block buffer
0AB4B 85 02                            sta $02                 ;store as new vertical high nybble offset
0AB4D A8                               tay 
0AB4E B1 06                            lda ($06),y             ;get contents of block buffer in same column, one row up
0AB50 C9 C3                            cmp #$c3                ;is it a coin? (not underwater)
0AB52 D0 0D                            bne TopEx               ;if not, branch to leave
0AB54 A9 00                            lda #$00
0AB56 91 06                            sta ($06),y             ;otherwise put blank metatile where coin was
0AB58 20 7D 89                         jsr RemoveCoin_Axe      ;write blank metatile to vram buffer
0AB5B AE EE 03                         ldx SprDataOffset_Ctrl  ;get control bit
0AB5E 20 70 A8                         jsr SetupJumpCoin       ;create jumping coin object and update coin variables
0AB61 60                        TopEx: rts                     ;leave!
0AB62                           
0AB62                           ;--------------------------------
0AB62                           
0AB62                           SpawnBrickChunks:
0AB62 B5 8F                           lda Block_X_Position,x     ;set horizontal coordinate of block object
0AB64 9D F1 03                        sta Block_Orig_XPos,x      ;as original horizontal coordinate here
0AB67 A9 F0                           lda #$f0
0AB69 95 60                           sta Block_X_Speed,x        ;set horizontal speed for brick chunk objects
0AB6B 95 62                           sta Block_X_Speed+2,x
0AB6D A9 FA                           lda #$fa
0AB6F 95 A8                           sta Block_Y_Speed,x        ;set vertical speed for one
0AB71 A9 FC                           lda #$fc
0AB73 95 AA                           sta Block_Y_Speed+2,x      ;set lower vertical speed for the other
0AB75 A9 00                           lda #$00
0AB77 9D 3C 04                        sta Block_Y_MoveForce,x    ;init fractional movement force for both
0AB7A 9D 3E 04                        sta Block_Y_MoveForce+2,x
0AB7D B5 76                           lda Block_PageLoc,x
0AB7F 95 78                           sta Block_PageLoc+2,x      ;copy page location
0AB81 B5 8F                           lda Block_X_Position,x
0AB83 95 91                           sta Block_X_Position+2,x   ;copy horizontal coordinate
0AB85 B5 D7                           lda Block_Y_Position,x
0AB87 18                              clc                        ;add 8 pixels to vertical coordinate
0AB88 69 08                           adc #$08                   ;and save as vertical coordinate for one of them
0AB8A 95 D9                           sta Block_Y_Position+2,x
0AB8C A9 FA                           lda #$fa
0AB8E 95 A8                           sta Block_Y_Speed,x        ;set vertical speed...again??? (redundant)
0AB90 60                              rts
0AB91                           
0AB91                           ;-------------------------------------------------------------------------------------
0AB91                           
0AB91                           BlockObjectsCore:
0AB91 B5 26                             lda Block_State,x           ;get state of block object
0AB93 F0 5D                             beq UpdSte                  ;if not set, branch to leave
0AB95 29 0F                             and #$0f                    ;mask out high nybble
0AB97 48                                pha                         ;push to stack
0AB98 A8                                tay                         ;put in Y for now
0AB99 8A                                txa
0AB9A 18                                clc
0AB9B 69 09                             adc #$09                    ;add 9 bytes to offset (note two block objects are created
0AB9D AA                                tax                         ;when using brick chunks, but only one offset for both)
0AB9E 88                                dey                         ;decrement Y to check for solid block state
0AB9F F0 33                             beq BouncingBlockHandler    ;branch if found, otherwise continue for brick chunks
0ABA1 20 C5 AC                          jsr ImposeGravityBlock      ;do sub to impose gravity on one block object object
0ABA4 20 30 AC                          jsr MoveObjectHorizontally  ;do another sub to move horizontally
0ABA7 8A                                txa
0ABA8 18                                clc                         ;move onto next block object
0ABA9 69 02                             adc #$02
0ABAB AA                                tax
0ABAC 20 C5 AC                          jsr ImposeGravityBlock      ;do sub to impose gravity on other block object
0ABAF 20 30 AC                          jsr MoveObjectHorizontally  ;do another sub to move horizontally
0ABB2 A6 08                             ldx ObjectOffset            ;get block object offset used for both
0ABB4 20 66 E0                          jsr RelativeBlockPosition   ;get relative coordinates
0ABB7 20 C3 E0                          jsr GetBlockOffscreenBits   ;get offscreen information
0ABBA 20 56 DB                          jsr DrawBrickChunks         ;draw the brick chunks
0ABBD 68                                pla                         ;get lower nybble of saved state
0ABBE B4 BE                             ldy Block_Y_HighPos,x       ;check vertical high byte of block object
0ABC0 F0 30                             beq UpdSte                  ;if above the screen, branch to kill it
0ABC2 48                                pha                         ;otherwise save state back into stack
0ABC3 A9 F0                             lda #$f0
0ABC5 D5 D9                             cmp Block_Y_Position+2,x    ;check to see if bottom block object went
0ABC7 B0 02                             bcs ChkTop                  ;to the bottom of the screen, and branch if not
0ABC9 95 D9                             sta Block_Y_Position+2,x    ;otherwise set offscreen coordinate
0ABCB B5 D7                     ChkTop: lda Block_Y_Position,x      ;get top block object's vertical coordinate
0ABCD C9 F0                             cmp #$f0                    ;see if it went to the bottom of the screen
0ABCF 68                                pla                         ;pull block object state from stack
0ABD0 90 20                             bcc UpdSte                  ;if not, branch to save state
0ABD2 B0 1C                             bcs KillBlock               ;otherwise do unconditional branch to kill it
0ABD4                           
0ABD4                           BouncingBlockHandler:
0ABD4 20 C5 AC                             jsr ImposeGravityBlock     ;do sub to impose gravity on block object
0ABD7 A6 08                                ldx ObjectOffset           ;get block object offset
0ABD9 20 66 E0                             jsr RelativeBlockPosition  ;get relative coordinates
0ABDC 20 C3 E0                             jsr GetBlockOffscreenBits  ;get offscreen information
0ABDF 20 D4 DA                             jsr DrawBlock              ;draw the block
0ABE2 B5 D7                                lda Block_Y_Position,x     ;get vertical coordinate
0ABE4 29 0F                                and #$0f                   ;mask out high nybble
0ABE6 C9 05                                cmp #$05                   ;check to see if low nybble wrapped around
0ABE8 68                                   pla                        ;pull state from stack
0ABE9 B0 07                                bcs UpdSte                 ;if still above amount, not time to kill block yet, thus branch
0ABEB A9 01                                lda #$01
0ABED 9D EC 03                             sta Block_RepFlag,x        ;otherwise set flag to replace metatile
0ABF0 A9 00                     KillBlock: lda #$00                   ;if branched here, nullify object state
0ABF2 95 26                     UpdSte:    sta Block_State,x          ;store contents of A in block object state
0ABF4 60                                   rts
0ABF5                           
0ABF5                           ;-------------------------------------------------------------------------------------
0ABF5                           ;$02 - used to store offset to block buffer
0ABF5                           ;$06-$07 - used to store block buffer address
0ABF5                           
0ABF5                           BlockObjMT_Updater:
0ABF5 A2 01                                 ldx #$01                  ;set offset to start with second block object
0ABF7 86 08                     UpdateLoop: stx ObjectOffset          ;set offset here
0ABF9 AD 01 03                              lda VRAM_Buffer1          ;if vram buffer already being used here,
0ABFC D0 21                                 bne NextBUpd              ;branch to move onto next block object
0ABFE BD EC 03                              lda Block_RepFlag,x       ;if flag for block object already clear,
0AC01 F0 1C                                 beq NextBUpd              ;branch to move onto next block object
0AC03 BD E6 03                              lda Block_BBuf_Low,x      ;get low byte of block buffer
0AC06 85 06                                 sta $06                   ;store into block buffer address
0AC08 A9 05                                 lda #$05
0AC0A 85 07                                 sta $07                   ;set high byte of block buffer address
0AC0C BD E4 03                              lda Block_Orig_YPos,x     ;get original vertical coordinate of block object
0AC0F 85 02                                 sta $02                   ;store here and use as offset to block buffer
0AC11 A8                                    tay
0AC12 BD E8 03                              lda Block_Metatile,x      ;get metatile to be written
0AC15 91 06                                 sta ($06),y               ;write it to the block buffer
0AC17 20 91 89                              jsr ReplaceBlockMetatile  ;do sub to replace metatile where block object is
0AC1A A9 00                                 lda #$00
0AC1C 9D EC 03                              sta Block_RepFlag,x       ;clear block object flag
0AC1F CA                        NextBUpd:   dex                       ;decrement block object offset
0AC20 10 D5                                 bpl UpdateLoop            ;do this until both block objects are dealt with
0AC22 60                                    rts                       ;then leave
0AC23                           
0AC23                           ;-------------------------------------------------------------------------------------
0AC23                           ;$00 - used to store high nybble of horizontal speed as adder
0AC23                           ;$01 - used to store low nybble of horizontal speed
0AC23                           ;$02 - used to store adder to page location
0AC23                           
0AC23                           MoveEnemyHorizontally:
0AC23 E8                              inx                         ;increment offset for enemy offset
0AC24 20 30 AC                        jsr MoveObjectHorizontally  ;position object horizontally according to
0AC27 A6 08                           ldx ObjectOffset            ;counters, return with saved value in A,
0AC29 60                              rts                         ;put enemy offset back in X and leave
0AC2A                           
0AC2A                           MovePlayerHorizontally:
0AC2A AD 0E 07                        lda JumpspringAnimCtrl  ;if jumpspring currently animating,
0AC2D D0 3E                           bne ExXMove             ;branch to leave
0AC2F AA                              tax                     ;otherwise set zero for offset to use player's stuff
0AC30                           
0AC30                           MoveObjectHorizontally:
0AC30 B5 57                               lda SprObject_X_Speed,x     ;get currently saved value (horizontal
0AC32 0A                                  asl                         ;speed, secondary counter, whatever)
0AC33 0A                                  asl                         ;and move low nybble to high
0AC34 0A                                  asl
0AC35 0A                                  asl
0AC36 85 01                               sta $01                     ;store result here
0AC38 B5 57                               lda SprObject_X_Speed,x     ;get saved value again
0AC3A 4A                                  lsr                         ;move high nybble to low
0AC3B 4A                                  lsr
0AC3C 4A                                  lsr
0AC3D 4A                                  lsr
0AC3E C9 08                               cmp #$08                    ;if < 8, branch, do not change
0AC40 90 02                               bcc SaveXSpd
0AC42 09 F0                               ora #%11110000              ;otherwise alter high nybble
0AC44 85 00                     SaveXSpd: sta $00                     ;save result here
0AC46 A0 00                               ldy #$00                    ;load default Y value here
0AC48 C9 00                               cmp #$00                    ;if result positive, leave Y alone
0AC4A 10 01                               bpl UseAdder
0AC4C 88                                  dey                         ;otherwise decrement Y
0AC4D 84 02                     UseAdder: sty $02                     ;save Y here
0AC4F BD 00 04                            lda SprObject_X_MoveForce,x ;get whatever number's here
0AC52 18                                  clc
0AC53 65 01                               adc $01                     ;add low nybble moved to high
0AC55 9D 00 04                            sta SprObject_X_MoveForce,x ;store result here
0AC58 A9 00                               lda #$00                    ;init A
0AC5A 2A                                  rol                         ;rotate carry into d0
0AC5B 48                                  pha                         ;push onto stack
0AC5C 6A                                  ror                         ;rotate d0 back onto carry
0AC5D B5 86                               lda SprObject_X_Position,x
0AC5F 65 00                               adc $00                     ;add carry plus saved value (high nybble moved to low
0AC61 95 86                               sta SprObject_X_Position,x  ;plus $f0 if necessary) to object's horizontal position
0AC63 B5 6D                               lda SprObject_PageLoc,x
0AC65 65 02                               adc $02                     ;add carry plus other saved value to the
0AC67 95 6D                               sta SprObject_PageLoc,x     ;object's page location and save
0AC69 68                                  pla
0AC6A 18                                  clc                         ;pull old carry from stack and add
0AC6B 65 00                               adc $00                     ;to high nybble moved to low
0AC6D 60                        ExXMove:  rts                         ;and leave
0AC6E                           
0AC6E                           ;-------------------------------------------------------------------------------------
0AC6E                           ;$00 - used for downward force
0AC6E                           ;$01 - used for upward force
0AC6E                           ;$02 - used for maximum vertical speed
0AC6E                           
0AC6E                           MovePlayerVertically:
0AC6E A2 00                              ldx #$00                ;set X for player offset
0AC70 AD 47 07                           lda TimerControl
0AC73 D0 05                              bne NoJSChk             ;if master timer control set, branch ahead
0AC75 AD 0E 07                           lda JumpspringAnimCtrl  ;otherwise check to see if jumpspring is animating
0AC78 D0 F3                              bne ExXMove             ;branch to leave if so
0AC7A AD 09 07                  NoJSChk: lda VerticalForce       ;dump vertical force 
0AC7D 85 00                              sta $00
0AC7F A9 04                              lda #$04                ;set maximum vertical speed here
0AC81 4C CE AC                           jmp ImposeGravitySprObj ;then jump to move player vertically
0AC84                           
0AC84                           ;--------------------------------
0AC84                           
0AC84                           MoveD_EnemyVertically:
0AC84 A0 3D                           ldy #$3d           ;set quick movement amount downwards
0AC86 B5 1E                           lda Enemy_State,x  ;then check enemy state
0AC88 C9 05                           cmp #$05           ;if not set to unique state for spiny's egg, go ahead
0AC8A D0 02                           bne ContVMove      ;and use, otherwise set different movement amount, continue on
0AC8C                           
0AC8C                           MoveFallingPlatform:
0AC8C A0 20                                ldy #$20       ;set movement amount
0AC8E 4C B5 AC                  ContVMove: jmp SetHiMax   ;jump to skip the rest of this
0AC91                           
0AC91                           ;--------------------------------
0AC91                           
0AC91                           MoveRedPTroopaDown:
0AC91 A0 00                           ldy #$00            ;set Y to move downwards
0AC93 4C 98 AC                        jmp MoveRedPTroopa  ;skip to movement routine
0AC96                           
0AC96                           MoveRedPTroopaUp:
0AC96 A0 01                           ldy #$01            ;set Y to move upwards
0AC98                           
0AC98                           MoveRedPTroopa:
0AC98 E8                              inx                 ;increment X for enemy offset
0AC99 A9 03                           lda #$03
0AC9B 85 00                           sta $00             ;set downward movement amount here
0AC9D A9 06                           lda #$06
0AC9F 85 01                           sta $01             ;set upward movement amount here
0ACA1 A9 02                           lda #$02
0ACA3 85 02                           sta $02             ;set maximum speed here
0ACA5 98                              tya                 ;set movement direction in A, and
0ACA6 4C F2 AC                        jmp RedPTroopaGrav  ;jump to move this thing
0ACA9                           
0ACA9                           ;--------------------------------
0ACA9                           
0ACA9                           MoveDropPlatform:
0ACA9 A0 7F                           ldy #$7f      ;set movement amount for drop platform
0ACAB D0 02                           bne SetMdMax  ;skip ahead of other value set here
0ACAD                           
0ACAD                           MoveEnemySlowVert:
0ACAD A0 0F                               ldy #$0f         ;set movement amount for bowser/other objects
0ACAF A9 02                     SetMdMax: lda #$02         ;set maximum speed in A
0ACB1 D0 04                               bne SetXMoveAmt  ;unconditional branch
0ACB3                           
0ACB3                           ;--------------------------------
0ACB3                           
0ACB3                           MoveJ_EnemyVertically:
0ACB3 A0 1C                                  ldy #$1c                ;set movement amount for podoboo/other objects
0ACB5 A9 03                     SetHiMax:    lda #$03                ;set maximum speed in A
0ACB7 84 00                     SetXMoveAmt: sty $00                 ;set movement amount here
0ACB9 E8                                     inx                     ;increment X for enemy offset
0ACBA 20 CE AC                               jsr ImposeGravitySprObj ;do a sub to move enemy object downwards
0ACBD A6 08                                  ldx ObjectOffset        ;get enemy object buffer offset and leave
0ACBF 60                                     rts
0ACC0                           
0ACC0                           ;--------------------------------
0ACC0                           
0ACC0                           MaxSpdBlockData:
0ACC0 06 08                           .db $06, $08
0ACC2                           
0ACC2                           ResidualGravityCode:
0ACC2 A0 00                           ldy #$00       ;this part appears to be residual,
0ACC4 2C                              .db $2c        ;no code branches or jumps to it...
0ACC5                           
0ACC5                           ImposeGravityBlock:
0ACC5 A0 01                           ldy #$01       ;set offset for maximum speed
0ACC7 A9 50                           lda #$50       ;set movement amount here
0ACC9 85 00                           sta $00
0ACCB B9 C0 AC                        lda MaxSpdBlockData,y    ;get maximum speed
0ACCE                           
0ACCE                           ImposeGravitySprObj:
0ACCE 85 02                           sta $02            ;set maximum speed here
0ACD0 A9 00                           lda #$00           ;set value to move downwards
0ACD2 4C F8 AC                        jmp ImposeGravity  ;jump to the code that actually moves it
0ACD5                           
0ACD5                           ;--------------------------------
0ACD5                           
0ACD5                           MovePlatformDown:
0ACD5 A9 00                           lda #$00    ;save value to stack (if branching here, execute next
0ACD7 2C                              .db $2c     ;part as BIT instruction)
0ACD8                           
0ACD8                           MovePlatformUp:
0ACD8 A9 01                                lda #$01        ;save value to stack
0ACDA 48                                   pha
0ACDB B4 16                                ldy Enemy_ID,x  ;get enemy object identifier
0ACDD E8                                   inx             ;increment offset for enemy object
0ACDE A9 05                                lda #$05        ;load default value here
0ACE0 C0 29                                cpy #$29        ;residual comparison, object #29 never executes
0ACE2 D0 02                                bne SetDplSpd   ;this code, thus unconditional branch here
0ACE4 A9 09                                lda #$09        ;residual code
0ACE6 85 00                     SetDplSpd: sta $00         ;save downward movement amount here
0ACE8 A9 0A                                lda #$0a        ;save upward movement amount here
0ACEA 85 01                                sta $01
0ACEC A9 03                                lda #$03        ;save maximum vertical speed here
0ACEE 85 02                                sta $02
0ACF0 68                                   pla             ;get value from stack
0ACF1 A8                                   tay             ;use as Y, then move onto code shared by red koopa
0ACF2                           
0ACF2                           RedPTroopaGrav:
0ACF2 20 F8 AC                        jsr ImposeGravity  ;do a sub to move object gradually
0ACF5 A6 08                           ldx ObjectOffset   ;get enemy object offset and leave
0ACF7 60                              rts
0ACF8                           
0ACF8                           ;-------------------------------------------------------------------------------------
0ACF8                           ;$00 - used for downward force
0ACF8                           ;$01 - used for upward force
0ACF8                           ;$07 - used as adder for vertical position
0ACF8                           
0ACF8                           ImposeGravity:
0ACF8 48                                 pha                          ;push value to stack
0ACF9 BD 16 04                           lda SprObject_YMF_Dummy,x
0ACFC 18                                 clc                          ;add value in movement force to contents of dummy variable
0ACFD 7D 33 04                           adc SprObject_Y_MoveForce,x
0AD00 9D 16 04                           sta SprObject_YMF_Dummy,x
0AD03 A0 00                              ldy #$00                     ;set Y to zero by default
0AD05 B5 9F                              lda SprObject_Y_Speed,x      ;get current vertical speed
0AD07 10 01                              bpl AlterYP                  ;if currently moving downwards, do not decrement Y
0AD09 88                                 dey                          ;otherwise decrement Y
0AD0A 84 07                     AlterYP: sty $07                      ;store Y here
0AD0C 75 CE                              adc SprObject_Y_Position,x   ;add vertical position to vertical speed plus carry
0AD0E 95 CE                              sta SprObject_Y_Position,x   ;store as new vertical position
0AD10 B5 B5                              lda SprObject_Y_HighPos,x
0AD12 65 07                              adc $07                      ;add carry plus contents of $07 to vertical high byte
0AD14 95 B5                              sta SprObject_Y_HighPos,x    ;store as new vertical high byte
0AD16 BD 33 04                           lda SprObject_Y_MoveForce,x
0AD19 18                                 clc
0AD1A 65 00                              adc $00                      ;add downward movement amount to contents of $0433
0AD1C 9D 33 04                           sta SprObject_Y_MoveForce,x
0AD1F B5 9F                              lda SprObject_Y_Speed,x      ;add carry to vertical speed and store
0AD21 69 00                              adc #$00
0AD23 95 9F                              sta SprObject_Y_Speed,x
0AD25 C5 02                              cmp $02                      ;compare to maximum speed
0AD27 30 10                              bmi ChkUpM                   ;if less than preset value, skip this part
0AD29 BD 33 04                           lda SprObject_Y_MoveForce,x
0AD2C C9 80                              cmp #$80                     ;if less positively than preset maximum, skip this part
0AD2E 90 09                              bcc ChkUpM
0AD30 A5 02                              lda $02
0AD32 95 9F                              sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
0AD34 A9 00                              lda #$00
0AD36 9D 33 04                           sta SprObject_Y_MoveForce,x  ;clear fractional
0AD39 68                        ChkUpM:  pla                          ;get value from stack
0AD3A F0 2B                              beq ExVMove                  ;if set to zero, branch to leave
0AD3C A5 02                              lda $02
0AD3E 49 FF                              eor #%11111111               ;otherwise get two's compliment of maximum speed
0AD40 A8                                 tay
0AD41 C8                                 iny
0AD42 84 07                              sty $07                      ;store two's compliment here
0AD44 BD 33 04                           lda SprObject_Y_MoveForce,x
0AD47 38                                 sec                          ;subtract upward movement amount from contents
0AD48 E5 01                              sbc $01                      ;of movement force, note that $01 is twice as large as $00,
0AD4A 9D 33 04                           sta SprObject_Y_MoveForce,x  ;thus it effectively undoes add we did earlier
0AD4D B5 9F                              lda SprObject_Y_Speed,x
0AD4F E9 00                              sbc #$00                     ;subtract borrow from vertical speed and store
0AD51 95 9F                              sta SprObject_Y_Speed,x
0AD53 C5 07                              cmp $07                      ;compare vertical speed to two's compliment
0AD55 10 10                              bpl ExVMove                  ;if less negatively than preset maximum, skip this part
0AD57 BD 33 04                           lda SprObject_Y_MoveForce,x
0AD5A C9 80                              cmp #$80                     ;check if fractional part is above certain amount,
0AD5C B0 09                              bcs ExVMove                  ;and if so, branch to leave
0AD5E A5 07                              lda $07
0AD60 95 9F                              sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
0AD62 A9 FF                              lda #$ff
0AD64 9D 33 04                           sta SprObject_Y_MoveForce,x  ;clear fractional
0AD67 60                        ExVMove: rts                          ;leave!
0AD68                           
0AD68                           ;-------------------------------------------------------------------------------------
0AD68                           
0AD68                           EnemiesAndLoopsCore:
0AD68 B5 0F                                 lda Enemy_Flag,x         ;check data here for MSB set
0AD6A 48                                    pha                      ;save in stack
0AD6B 0A                                    asl
0AD6C B0 12                                 bcs ChkBowserF           ;if MSB set in enemy flag, branch ahead of jumps
0AD6E 68                                    pla                      ;get from stack
0AD6F F0 03                                 beq ChkAreaTsk           ;if data zero, branch
0AD71 4C 9B B6                              jmp RunEnemyObjectsCore  ;otherwise, jump to run enemy subroutines
0AD74 AD 1F 07                  ChkAreaTsk: lda AreaParserTaskNum    ;check number of tasks to perform
0AD77 29 07                                 and #$07
0AD79 C9 07                                 cmp #$07                 ;if at a specific task, jump and leave
0AD7B F0 0E                                 beq ExitELCore
0AD7D 4C A6 AE                              jmp ProcLoopCommand      ;otherwise, jump to process loop command/load enemies
0AD80 68                        ChkBowserF: pla                      ;get data from stack
0AD81 29 0F                                 and #%00001111           ;mask out high nybble
0AD83 A8                                    tay
0AD84 B9 0F 00                              lda Enemy_Flag,y         ;use as pointer and load same place with different offset
0AD87 D0 02                                 bne ExitELCore
0AD89 95 0F                                 sta Enemy_Flag,x         ;if second enemy flag not set, also clear first one
0AD8B 60                        ExitELCore: rts
0AD8C                           
0AD8C                           ;-------------------------------------------------------------------------------------
0AD8C                           
0AD8C                           ExecGameLoopback:
0AD8C A5 6D                           lda Player_PageLoc        ;send player back four pages
0AD8E 38                              sec
0AD8F E9 04                           sbc #$04
0AD91 85 6D                           sta Player_PageLoc
0AD93 AD 25 07                        lda CurrentPageLoc        ;send current page back four pages
0AD96 38                              sec
0AD97 E9 04                           sbc #$04
0AD99 8D 25 07                        sta CurrentPageLoc
0AD9C AD 1A 07                        lda ScreenLeft_PageLoc    ;subtract four from page location
0AD9F 38                              sec                       ;of screen's left border
0ADA0 E9 04                           sbc #$04
0ADA2 8D 1A 07                        sta ScreenLeft_PageLoc
0ADA5 AD 1B 07                        lda ScreenRight_PageLoc   ;do the same for the page location
0ADA8 38                              sec                       ;of screen's right border
0ADA9 E9 04                           sbc #$04
0ADAB 8D 1B 07                        sta ScreenRight_PageLoc
0ADAE AD 2A 07                        lda AreaObjectPageLoc     ;subtract four from page control
0ADB1 38                              sec                       ;for area objects
0ADB2 E9 04                           sbc #$04
0ADB4 8D 2A 07                        sta AreaObjectPageLoc
0ADB7 A9 00                           lda #$00                  ;initialize page select for both
0ADB9 8D 3B 07                        sta EnemyObjectPageSel    ;area and enemy objects
0ADBC 8D 2B 07                        sta AreaObjectPageSel
0ADBF 8D 39 07                        sta EnemyDataOffset       ;initialize enemy object data offset
0ADC2 8D 3A 07                        sta EnemyObjectPageLoc    ;and enemy object page control
0ADC5 AD FB 07                        lda HardWorldFlag         ;use appropiate object offset
0ADC8 D0 07                           bne ExecGameLoopbackJ     ;depending on which game's levels we're playing
0ADCA B9 1C AE                        lda AreaDataOfsLoopback,y ;adjust area object offset based on
0ADCD 8D 2C 07                        sta AreaDataOffset        ;which loop command we encountered
0ADD0 60                              rts
0ADD1                           ExecGameLoopbackJ:
0ADD1 B9 5D AE                        lda AreaDataOfsLoopbackJ,y ;adjust area object offset based on
0ADD4 8D 2C 07                        sta AreaDataOffset        ;which loop command we encountered
0ADD7 60                              rts
0ADD8                           
0ADD8                           ;loop command data
0ADD8                           ;note that some data is never used (it may have been
0ADD8                           ;used at one point, but the area data that ref'd it
0ADD8                           ;is now missing the loop command object)
0ADD8                           
0ADD8                           ;SMB1 loops
0ADD8                           LoopCmdWorldNumber:
0ADD8 03 03 06 06 06 06 06 06..       .db $03, $03, $06, $06, $06, $06, $06, $06, $07, $07, $07
0ADE3 08 08 08 08 08 08               .db $08, $08, $08, $08, $08, $08
0ADE9                           
0ADE9                           LoopCmdPageNumber:
0ADE9 05 09 04 05 06 08 09 0A..       .db $05, $09, $04, $05, $06, $08, $09, $0a, $06, $0b, $10
0ADF4 04 05 06 08 09 0A               .db $04, $05, $06, $08, $09, $0a
0ADFA                           
0ADFA                           LoopCmdYPosition:
0ADFA 40 B0 B0 80 40 40 80 40..       .db $40, $b0, $b0, $80, $40, $40, $80, $40, $f0, $f0, $f0
0AE05 B0 40 40 B0 40 80               .db $b0, $40, $40, $b0, $40, $80
0AE0B                           
0AE0B                           MultiLoopCount:
0AE0B 01 01 03 03 03 03 03 03..       .db $01, $01, $03, $03, $03, $03, $03, $03, $01, $01, $01
0AE16 03 03 03 03 03 03               .db $03, $03, $03, $03, $03, $03
0AE1C                           
0AE1C                           AreaDataOfsLoopback:
0AE1C 12 36 0E 0E 0E 32 32 32..       .db $12, $36, $0e, $0e, $0e, $32, $32, $32, $0a, $26, $40
0AE27 0E 0E 0E 32 32 32               .db $0e, $0e, $0e, $32, $32, $32
0AE2D                           
0AE2D                           ;SMB2J loops
0AE2D                           LoopCmdWorldNumberJ:
0AE2D 02 02 02 02 05 05 05 05..   .db $02, $02, $02, $02, $05, $05, $05, $05, $06, $07, $07, $04
0AE39                           
0AE39                           LoopCmdPageNumberJ:
0AE39 03 05 08 09 03 06 07 0A..   .db $03, $05, $08, $09, $03, $06, $07, $0a, $05, $05, $0b, $05
0AE45                           
0AE45                           LoopCmdYPositionJ:
0AE45 B0 B0 40 30 B0 30 B0 B0..   .db $b0, $b0, $40, $30, $b0, $30, $b0, $b0, $f0, $f0, $b0, $f0
0AE51                           
0AE51                           MultiLoopCountJ:
0AE51 02 02 02 02 02 02 02 02..   .db $02, $02, $02, $02, $02, $02, $02, $02, $01, $01, $01, $01
0AE5D                           
0AE5D                           AreaDataOfsLoopbackJ:
0AE5D 0C 0C 42 42 10 10 30 30..   .db $0c, $0c, $42, $42, $10, $10, $30, $30, $06, $0c, $54, $06
0AE69                           
0AE69                           ChkEnemyFrenzyJ:
0AE69 4C 00 AF                        jmp ChkEnemyFrenzy ;lazy but it works?
0AE6C                           
0AE6C                           ProcLoopCommandJ:
0AE6C A0 0C                                ldy #$0c                  ;start at the end of each set of loop data
0AE6E 88                        FindLoopJ: dey
0AE6F 30 F8                                bmi ChkEnemyFrenzyJ        ;if all data is checked and not match, do not loop
0AE71 AD 5F 07                             lda WorldNumber           ;check to see if one of the world numbers
0AE74 D9 2D AE                             cmp LoopCmdWorldNumberJ,y  ;matches our current world number
0AE77 D0 F5                                bne FindLoopJ
0AE79 AD 25 07                             lda CurrentPageLoc        ;check to see if one of the page numbers
0AE7C D9 39 AE                             cmp LoopCmdPageNumberJ,y   ;matches the page we're currently on
0AE7F D0 ED                                bne FindLoopJ
0AE81 A5 CE                                lda Player_Y_Position     ;check to see if the player is at the correct position
0AE83 D9 45 AE                             cmp LoopCmdYPositionJ,y    ;if not, branch to check for world 7
0AE86 D0 09                                bne WrongChkJ
0AE88 A5 1D                                lda Player_State          ;check to see if the player is
0AE8A C9 00                                cmp #$00                  ;on solid ground (i.e. not jumping or falling)
0AE8C D0 03                                bne WrongChkJ              ;if not, player fails to pass loop, and loopback
0AE8E EE D9 06                             inc MultiLoopCorrectCntr  ;increment counter for correct progression
0AE91 EE DA 06                  WrongChkJ: inc MultiLoopPassCntr     ;increment master multi-part counter
0AE94 AD DA 06                             lda MultiLoopPassCntr     ;have we done all parts?
0AE97 D9 51 AE                             cmp MultiLoopCountJ,y
0AE9A D0 5F                                bne InitLCmd              ;if not, skip this part
0AE9C AD D9 06                             lda MultiLoopCorrectCntr  ;if so, have we done them all correctly?
0AE9F D9 51 AE                             cmp MultiLoopCountJ,y
0AEA2 F0 4F                                beq InitMLp               ;if so, branch past unnecessary check here
0AEA4 D0 47                                bne DoLpBack              ;if player is not in right place, loop back
0AEA6                           
0AEA6                           ProcLoopCommand:
0AEA6 AD 45 07                            lda LoopCommand           ;check if loop command was found
0AEA9 F0 55                               beq ChkEnemyFrenzy
0AEAB AD 26 07                            lda CurrentColumnPos      ;check to see if we're still on the first page
0AEAE D0 50                               bne ChkEnemyFrenzy        ;if not, do not loop yet
0AEB0 AD FB 07                            lda HardWorldFlag         ;use correct loop command routine
0AEB3 D0 B7                               bne ProcLoopCommandJ      ;depending on which game we're playing
0AEB5 A0 11                               ldy #$11                  ;start at the end of each set of loop data
0AEB7 88                        FindLoop: dey
0AEB8 30 46                               bmi ChkEnemyFrenzy        ;if all data is checked and not match, do not loop
0AEBA AD 5F 07                            lda WorldNumber           ;check to see if one of the world numbers
0AEBD D9 D8 AD                            cmp LoopCmdWorldNumber,y  ;matches our current world number
0AEC0 D0 F5                               bne FindLoop
0AEC2 AD 25 07                            lda CurrentPageLoc        ;check to see if one of the page numbers
0AEC5 D9 E9 AD                            cmp LoopCmdPageNumber,y   ;matches the page we're currently on
0AEC8 D0 ED                               bne FindLoop
0AECA A5 CE                               lda Player_Y_Position     ;check to see if the player is at the correct position
0AECC D9 FA AD                            cmp LoopCmdYPosition,y    ;if not, branch to check for world 7
0AECF D0 09                               bne WrongChk
0AED1 A5 1D                               lda Player_State          ;check to see if the player is
0AED3 C9 00                               cmp #$00                  ;on solid ground (i.e. not jumping or falling)
0AED5 D0 03                               bne WrongChk              ;if not, player fails to pass loop, and loopback
0AED7 EE D9 06                            inc MultiLoopCorrectCntr  ;increment counter for correct progression
0AEDA EE DA 06                  WrongChk: inc MultiLoopPassCntr     ;increment master multi-part counter
0AEDD AD DA 06                            lda MultiLoopPassCntr     ;have we done all parts?
0AEE0 D9 0B AE                            cmp MultiLoopCount,y
0AEE3 D0 16                               bne InitLCmd              ;if not, skip this part
0AEE5 AD D9 06                            lda MultiLoopCorrectCntr  ;if so, have we done them all correctly?
0AEE8 D9 0B AE                            cmp MultiLoopCount,y
0AEEB F0 06                               beq InitMLp               ;if so, branch past unnecessary check here
0AEED 20 8C AD                  DoLpBack: jsr ExecGameLoopback      ;if player is not in right place, loop back
0AEF0 20 8A BE                            jsr KillAllEnemies
0AEF3 A9 00                     InitMLp:  lda #$00                  ;initialize counters used for multi-part loop commands
0AEF5 8D DA 06                            sta MultiLoopPassCntr
0AEF8 8D D9 06                            sta MultiLoopCorrectCntr
0AEFB A9 00                     InitLCmd: lda #$00                  ;initialize loop command flag
0AEFD 8D 45 07                            sta LoopCommand
0AF00                           
0AF00                           ;--------------------------------
0AF00                           
0AF00                           ChkEnemyFrenzy:
0AF00 AD CD 06                        lda EnemyFrenzyQueue  ;check for enemy object in frenzy queue
0AF03 F0 10                           beq ProcessEnemyData  ;if not, skip this part
0AF05 95 16                           sta Enemy_ID,x        ;store as enemy object identifier here
0AF07 A9 01                           lda #$01
0AF09 95 0F                           sta Enemy_Flag,x      ;activate enemy object flag
0AF0B A9 00                           lda #$00
0AF0D 95 1E                           sta Enemy_State,x     ;initialize state and frenzy queue
0AF0F 8D CD 06                        sta EnemyFrenzyQueue
0AF12 4C F7 AF                        jmp InitEnemyObject   ;and then jump to deal with this enemy
0AF15                           
0AF15                           ;--------------------------------
0AF15                           ;$05 - used to hold world number for comparison
0AF15                           ;$06 - used to hold page location of extended right boundary
0AF15                           ;$07 - used to hold high nybble of position of extended right boundary
0AF15                           
0AF15                           ProcessEnemyData:
0AF15 AC 39 07                          ldy EnemyDataOffset      ;get offset of enemy object data
0AF18 B1 E9                             lda (EnemyData),y        ;load first byte
0AF1A C9 FF                             cmp #$ff                 ;check for EOD terminator
0AF1C D0 03                             bne CheckEndofBuffer
0AF1E 4C E7 AF                          jmp CheckFrenzyBuffer    ;if found, jump to check frenzy buffer, otherwise
0AF21                           
0AF21                           CheckEndofBuffer:
0AF21 29 0F                             and #%00001111           ;check for special row $0e
0AF23 C9 0E                             cmp #$0e
0AF25 F0 0E                             beq CheckRightBounds     ;if found, branch, otherwise
0AF27 E0 05                             cpx #$05                 ;check for end of buffer
0AF29 90 0A                             bcc CheckRightBounds     ;if not at end of buffer, branch
0AF2B C8                                iny
0AF2C B1 E9                             lda (EnemyData),y        ;check for specific value here
0AF2E 29 3F                             and #%00111111           ;not sure what this was intended for, exactly
0AF30 C9 2E                             cmp #$2e                 ;this part is quite possibly residual code
0AF32 F0 01                             beq CheckRightBounds     ;but it has the effect of keeping enemies out of
0AF34 60                                rts                      ;the sixth slot
0AF35                           
0AF35                           CheckRightBounds:
0AF35 AD 1D 07                          lda ScreenRight_X_Pos    ;add 48 to pixel coordinate of right boundary
0AF38 18                                clc
0AF39 69 30                             adc #$30
0AF3B 29 F0                             and #%11110000           ;store high nybble
0AF3D 85 07                             sta $07
0AF3F AD 1B 07                          lda ScreenRight_PageLoc  ;add carry to page location of right boundary
0AF42 69 00                             adc #$00
0AF44 85 06                             sta $06                  ;store page location + carry
0AF46 AC 39 07                          ldy EnemyDataOffset
0AF49 C8                                iny
0AF4A B1 E9                             lda (EnemyData),y        ;if MSB of enemy object is clear, branch to check for row $0f
0AF4C 0A                                asl
0AF4D 90 0B                             bcc CheckPageCtrlRow
0AF4F AD 3B 07                          lda EnemyObjectPageSel   ;if page select already set, do not set again
0AF52 D0 06                             bne CheckPageCtrlRow
0AF54 EE 3B 07                          inc EnemyObjectPageSel   ;otherwise, if MSB is set, set page select 
0AF57 EE 3A 07                          inc EnemyObjectPageLoc   ;and increment page control
0AF5A                           
0AF5A                           CheckPageCtrlRow:
0AF5A 88                                dey
0AF5B B1 E9                             lda (EnemyData),y        ;reread first byte
0AF5D 29 0F                             and #$0f
0AF5F C9 0F                             cmp #$0f                 ;check for special row $0f
0AF61 D0 19                             bne PositionEnemyObj     ;if not found, branch to position enemy object
0AF63 AD 3B 07                          lda EnemyObjectPageSel   ;if page select set,
0AF66 D0 14                             bne PositionEnemyObj     ;branch without reading second byte
0AF68 C8                                iny
0AF69 B1 E9                             lda (EnemyData),y        ;otherwise, get second byte, mask out 2 MSB
0AF6B 29 3F                             and #%00111111
0AF6D 8D 3A 07                          sta EnemyObjectPageLoc   ;store as page control for enemy object data
0AF70 EE 39 07                          inc EnemyDataOffset      ;increment enemy object data offset 2 bytes
0AF73 EE 39 07                          inc EnemyDataOffset
0AF76 EE 3B 07                          inc EnemyObjectPageSel   ;set page select for enemy object data and 
0AF79 4C A6 AE                          jmp ProcLoopCommand      ;jump back to process loop commands again
0AF7C                           
0AF7C                           PositionEnemyObj:
0AF7C AD 3A 07                          lda EnemyObjectPageLoc   ;store page control as page location
0AF7F 95 6E                             sta Enemy_PageLoc,x      ;for enemy object
0AF81 B1 E9                             lda (EnemyData),y        ;get first byte of enemy object
0AF83 29 F0                             and #%11110000
0AF85 95 87                             sta Enemy_X_Position,x   ;store column position
0AF87 CD 1D 07                          cmp ScreenRight_X_Pos    ;check column position against right boundary
0AF8A B5 6E                             lda Enemy_PageLoc,x      ;without subtracting, then subtract borrow
0AF8C ED 1B 07                          sbc ScreenRight_PageLoc  ;from page location
0AF8F B0 0B                             bcs CheckRightExtBounds  ;if enemy object beyond or at boundary, branch
0AF91 B1 E9                             lda (EnemyData),y
0AF93 29 0F                             and #%00001111           ;check for special row $0e
0AF95 C9 0E                             cmp #$0e                 ;if found, jump elsewhere
0AF97 F0 69                             beq ParseRow0e
0AF99 4C 30 B0                          jmp CheckThreeBytes      ;if not found, unconditional jump
0AF9C                           
0AF9C                           CheckRightExtBounds:
0AF9C A5 07                             lda $07                  ;check right boundary + 48 against
0AF9E D5 87                             cmp Enemy_X_Position,x   ;column position without subtracting,
0AFA0 A5 06                             lda $06                  ;then subtract borrow from page control temp
0AFA2 F5 6E                             sbc Enemy_PageLoc,x      ;plus carry
0AFA4 90 41                             bcc CheckFrenzyBuffer    ;if enemy object beyond extended boundary, branch
0AFA6 A9 01                             lda #$01                 ;store value in vertical high byte
0AFA8 95 B6                             sta Enemy_Y_HighPos,x
0AFAA B1 E9                             lda (EnemyData),y        ;get first byte again
0AFAC 0A                                asl                      ;multiply by four to get the vertical
0AFAD 0A                                asl                      ;coordinate
0AFAE 0A                                asl
0AFAF 0A                                asl
0AFB0 95 CF                             sta Enemy_Y_Position,x
0AFB2 C9 E0                             cmp #$e0                 ;do one last check for special row $0e
0AFB4 F0 4C                             beq ParseRow0e           ;(necessary if branched to $c1cb)
0AFB6 C8                                iny
0AFB7 B1 E9                             lda (EnemyData),y        ;get second byte of object
0AFB9 29 40                             and #%01000000           ;check to see if hard mode bit is set
0AFBB F0 05                             beq CheckForEnemyGroup   ;if not, branch to check for group enemy objects
0AFBD AD CC 06                          lda SecondaryHardMode    ;if set, check to see if secondary hard mode flag
0AFC0 F0 7C                             beq Inc2B                ;is on, and if not, branch to skip this object completely
0AFC2                           
0AFC2                           CheckForEnemyGroup:
0AFC2 B1 E9                             lda (EnemyData),y      ;get second byte and mask out 2 MSB
0AFC4 29 3F                             and #%00111111
0AFC6 C9 37                             cmp #$37               ;check for value below $37
0AFC8 90 04                             bcc BuzzyBeetleMutate
0AFCA C9 3F                             cmp #$3f               ;if $37 or greater, check for value
0AFCC 90 31                             bcc DoGroup            ;below $3f, branch if below $3f
0AFCE                           
0AFCE                           BuzzyBeetleMutate:
0AFCE C9 06                             cmp #Goomba          ;if below $37, check for goomba
0AFD0 D0 07                             bne StrID            ;value ($3f or more always fails)
0AFD2 AC 6A 07                          ldy PrimaryHardMode  ;check if primary hard mode flag is set
0AFD5 F0 02                             beq StrID            ;and if so, change goomba to buzzy beetle
0AFD7 A9 02                             lda #BuzzyBeetle
0AFD9 95 16                     StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
0AFDB A9 01                             lda #$01
0AFDD 95 0F                             sta Enemy_Flag,x     ;set flag for enemy in buffer
0AFDF 20 F7 AF                          jsr InitEnemyObject
0AFE2 B5 0F                             lda Enemy_Flag,x     ;check to see if flag is set
0AFE4 D0 58                             bne Inc2B            ;if not, leave, otherwise branch
0AFE6 60                                rts
0AFE7                           
0AFE7                           CheckFrenzyBuffer:
0AFE7 AD CB 06                          lda EnemyFrenzyBuffer    ;if enemy object stored in frenzy buffer
0AFEA D0 09                             bne StrFre               ;then branch ahead to store in enemy object buffer
0AFEC AD 98 03                          lda VineFlagOffset       ;otherwise check vine flag offset
0AFEF C9 01                             cmp #$01
0AFF1 D0 0B                             bne ExEPar               ;if other value <> 1, leave
0AFF3 A9 2F                             lda #VineObject          ;otherwise put vine in enemy identifier
0AFF5 95 16                     StrFre: sta Enemy_ID,x           ;store contents of frenzy buffer into enemy identifier value
0AFF7                           
0AFF7                           InitEnemyObject:
0AFF7 A9 00                             lda #$00                 ;initialize enemy state
0AFF9 95 1E                             sta Enemy_State,x
0AFFB 20 4C B0                          jsr CheckpointEnemyID    ;jump ahead to run jump engine and subroutines
0AFFE 60                        ExEPar: rts                      ;then leave
0AFFF                           
0AFFF                           DoGroup:
0AFFF 4C 2D B5                          jmp HandleGroupEnemies   ;handle enemy group objects
0B002                           
0B002                           ParseRow0e:
0B002 C8                                iny                      ;increment Y to load third byte of object
0B003 C8                                iny
0B004 AD 5F 07                          lda WorldNumber
0B007 C9 08                             cmp #World9              ;skip world number check if on world 9
0B009 F0 14                             beq W9Skip
0B00B C9 09                             cmp #WorldA              ;2J letter worlds?
0B00D 90 03                             bcc Pars0e               ;if not, branch ahead to use world number as-is
0B00F 38                                sec
0B010 E9 09                             sbc #$09                 ;otherwise subtract 9 for correct world comparison
0B012 85 05                     Pars0e: sta $05
0B014 B1 E9                             lda (EnemyData),y
0B016 4A                                lsr                      ;move 3 MSB to the bottom, effectively
0B017 4A                                lsr                      ;making %xxx00000 into %00000xxx
0B018 4A                                lsr
0B019 4A                                lsr
0B01A 4A                                lsr
0B01B C5 05                             cmp $05                  ;is it the same world number as we're on?
0B01D D0 0E                             bne NotUse               ;if not, do not use (this allows multiple uses
0B01F 88                        W9Skip: dey                      ;of the same area, like the underground bonus areas)
0B020 B1 E9                             lda (EnemyData),y        ;otherwise, get second byte and use as offset
0B022 8D 50 07                          sta AreaPointer          ;to addresses for level and enemy object data
0B025 C8                                iny
0B026 B1 E9                             lda (EnemyData),y        ;get third byte again, and this time mask out
0B028 29 1F                             and #%00011111           ;the 3 MSB from before, save as page number to be
0B02A 8D 51 07                          sta EntrancePage         ;used upon entry to area, if area is entered
0B02D 4C 3B B0                  NotUse: jmp Inc3B
0B030                           
0B030                           CheckThreeBytes:
0B030 AC 39 07                          ldy EnemyDataOffset      ;load current offset for enemy object data
0B033 B1 E9                             lda (EnemyData),y        ;get first byte
0B035 29 0F                             and #%00001111           ;check for special row $0e
0B037 C9 0E                             cmp #$0e
0B039 D0 03                             bne Inc2B
0B03B EE 39 07                  Inc3B:  inc EnemyDataOffset      ;if row = $0e, increment three bytes
0B03E EE 39 07                  Inc2B:  inc EnemyDataOffset      ;otherwise increment two bytes
0B041 EE 39 07                          inc EnemyDataOffset
0B044 A9 00                             lda #$00                 ;init page select for enemy objects
0B046 8D 3B 07                          sta EnemyObjectPageSel
0B049 A6 08                             ldx ObjectOffset         ;reload current offset in enemy buffers
0B04B 60                                rts                      ;and leave
0B04C                           
0B04C                           CheckpointEnemyID:
0B04C B5 16                             lda Enemy_ID,x
0B04E C9 15                             cmp #$15                     ;check enemy object identifier for $15 or greater
0B050 B0 0D                             bcs InitEnemyRoutines        ;and branch straight to the jump engine if found
0B052 A8                                tay                          ;save identifier in Y register for now
0B053 B5 CF                             lda Enemy_Y_Position,x
0B055 69 08                             adc #$08                     ;add eight pixels to what will eventually be the
0B057 95 CF                             sta Enemy_Y_Position,x       ;enemy object's vertical coordinate ($00-$14 only)
0B059 A9 01                             lda #$01
0B05B 9D D8 03                          sta EnemyOffscrBitsMasked,x  ;set offscreen masked bit
0B05E 98                                tya                          ;get identifier back and use as offset for jump engine
0B05F                           
0B05F                           InitEnemyRoutines:
0B05F 20 F8 8C                          jsr JumpEngine
0B062                           
0B062 EE B0                             .dw InitNormalEnemy
0B064 EE B0                             .dw InitNormalEnemy
0B066 EE B0                             .dw InitNormalEnemy
0B068 FE B0                             .dw InitRedKoopa
0B06A 99 B5                             .dw InitPiranhaPlant
0B06C 08 B1                             .dw InitHammerBro
0B06E D1 B0                             .dw InitGoomba
0B070 2E B1                             .dw InitBloober
0B072 57 B1                             .dw InitBulletBill
0B074 D0 B0                             .dw NoInitCode
0B076 61 B1                             .dw InitCheepCheep
0B078 61 B1                             .dw InitCheepCheep
0B07A D7 B0                             .dw InitPodoboo
0B07C 99 B5                             .dw InitPiranhaPlant
0B07E E3 B5                             .dw InitJumpGPTroopa
0B080 36 B1                             .dw InitRedPTroopa
0B082                           
0B082 29 B1                             .dw InitHorizFlySwimEnemy
0B084 71 B1                             .dw InitLakitu
0B086 B2 B5                             .dw InitEnemyFrenzy
0B088 D0 B0                             .dw NoInitCode
0B08A B2 B5                             .dw InitEnemyFrenzy
0B08C B2 B5                             .dw InitEnemyFrenzy
0B08E B2 B5                             .dw InitEnemyFrenzy
0B090 B2 B5                             .dw InitEnemyFrenzy
0B092 CA B5                             .dw EndFrenzy
0B094 D0 B0                             .dw NoInitCode
0B096 D0 B0                             .dw NoInitCode
0B098 56 B2                             .dw InitShortFirebar
0B09A 56 B2                             .dw InitShortFirebar
0B09C 56 B2                             .dw InitShortFirebar
0B09E 56 B2                             .dw InitShortFirebar
0B0A0 53 B2                             .dw InitLongFirebar
0B0A2                           
0B0A2 D0 B0                             .dw NoInitCode
0B0A4 D0 B0                             .dw NoInitCode
0B0A6 D0 B0                             .dw NoInitCode
0B0A8 D0 B0                             .dw NoInitCode
0B0AA F8 B5                             .dw InitBalPlatform
0B0AC 2B B6                             .dw InitVertPlatform
0B0AE 58 B6                             .dw LargeLiftUp
0B0B0 5E B6                             .dw LargeLiftDown
0B0B2 24 B6                             .dw InitHoriPlatform
0B0B4 1C B6                             .dw InitDropPlatform
0B0B6 24 B6                             .dw InitHoriPlatform
0B0B8 64 B6                             .dw PlatLiftUp
0B0BA 70 B6                             .dw PlatLiftDown
0B0BC 43 B3                             .dw InitBowser
0B0BE 69 A9                             .dw PwrUpJmp
0B0C0 FE A5                             .dw Setup_Vine
0B0C2                           
0B0C2 D0 B0                             .dw NoInitCode
0B0C4 D0 B0                             .dw NoInitCode
0B0C6 D0 B0                             .dw NoInitCode
0B0C8 D0 B0                             .dw NoInitCode
0B0CA D0 B0                             .dw NoInitCode
0B0CC E7 B0                             .dw InitRetainerObj
0B0CE 9A B6                             .dw EndOfEnemyInitCode
0B0D0                           
0B0D0                           NoInitCode:
0B0D0 60                                rts
0B0D1                           
0B0D1                           InitGoomba:
0B0D1 20 EE B0                        jsr InitNormalEnemy  ;set appropriate horizontal speed
0B0D4 4C 32 B1                        jmp SmallBBox        ;set $09 as bounding box control, set other values
0B0D7                           
0B0D7                           InitPodoboo:
0B0D7 A9 02                           lda #$02                  ;set enemy position to below
0B0D9 95 B6                           sta Enemy_Y_HighPos,x     ;the bottom of the screen
0B0DB 95 CF                           sta Enemy_Y_Position,x
0B0DD 4A                              lsr
0B0DE 9D 96 07                        sta EnemyIntervalTimer,x  ;set timer for enemy
0B0E1 4A                              lsr
0B0E2 95 1E                           sta Enemy_State,x         ;initialize enemy state, then jump to use
0B0E4 4C 32 B1                        jmp SmallBBox             ;$09 as bounding box size and set other things
0B0E7                           
0B0E7                           InitRetainerObj:
0B0E7 A9 B8                           lda #$b8                ;set fixed vertical position for
0B0E9 95 CF                           sta Enemy_Y_Position,x  ;princess/mushroom retainer object
0B0EB 60                              rts
0B0EC                           
0B0EC                           NormalXSpdData:
0B0EC F8 F4                           .db $f8, $f4
0B0EE                           
0B0EE                           InitNormalEnemy:
0B0EE A0 01                              ldy #$01              ;load offset of 1 by default
0B0F0 AD 6A 07                           lda PrimaryHardMode   ;check for primary hard mode flag set
0B0F3 D0 01                              bne GetESpd
0B0F5 88                                 dey                   ;if not set, decrement offset
0B0F6 B9 EC B0                  GetESpd: lda NormalXSpdData,y  ;get appropriate horizontal speed
0B0F9 95 58                     SetESpd: sta Enemy_X_Speed,x   ;store as speed for enemy object
0B0FB 4C 46 B1                           jmp TallBBox          ;branch to set bounding box control and other data
0B0FE                           
0B0FE                           InitRedKoopa:
0B0FE 20 EE B0                        jsr InitNormalEnemy   ;load appropriate horizontal speed
0B101 A9 01                           lda #$01              ;set enemy state for red koopa troopa $03
0B103 95 1E                           sta Enemy_State,x
0B105 60                              rts
0B106                           
0B106                           HBroWalkingTimerData:
0B106 80 50                           .db $80, $50
0B108                           
0B108                           InitHammerBro:
0B108 A9 00                            lda #$00                    ;init horizontal speed and timer used by hammer bro
0B10A 9D A2 03                         sta HammerThrowingTimer,x   ;apparently to time hammer throwing
0B10D 95 58                            sta Enemy_X_Speed,x
0B10F AD FB 07                         lda HardWorldFlag           ;playing SMB1 levels?
0B112 F0 07                            beq HBI                     ;skip world check, always have walk delay
0B114 AD 5F 07                         lda WorldNumber             ;if on world 7+ of SMB2J, branch to skip the walk delay
0B117 C9 06                            cmp #World7
0B119 B0 09                            bcs NoHBI
0B11B AC CC 06                  HBI:   ldy SecondaryHardMode       ;get secondary hard mode flag
0B11E B9 06 B1                         lda HBroWalkingTimerData,y
0B121 9D 96 07                         sta EnemyIntervalTimer,x    ;set value as delay for hammer bro to walk left
0B124 A9 0B                     NoHBI: lda #$0b                    ;set specific value for bounding box size control
0B126 4C 48 B1                         jmp SetBBox
0B129                           
0B129                           ;--------------------------------
0B129                           
0B129                           InitHorizFlySwimEnemy:
0B129 A9 00                           lda #$00        ;initialize horizontal speed
0B12B 4C F9 B0                        jmp SetESpd
0B12E                           
0B12E                           ;--------------------------------
0B12E                           
0B12E                           InitBloober:
0B12E A9 00                                lda #$00               ;initialize horizontal speed
0B130 95 58                                sta BlooperMoveSpeed,x
0B132 A9 09                     SmallBBox: lda #$09               ;set specific bounding box size control
0B134 D0 12                                bne SetBBox            ;unconditional branch
0B136                           
0B136                           InitRedPTroopa:
0B136 A0 30                               ldy #$30                    ;load central position adder for 48 pixels down
0B138 B5 CF                               lda Enemy_Y_Position,x      ;set vertical coordinate into location to
0B13A 9D 01 04                            sta RedPTroopaOrigXPos,x    ;be used as original vertical coordinate
0B13D 10 02                               bpl GetCent                 ;if vertical coordinate < $80
0B13F A0 E0                               ldy #$e0                    ;if => $80, load position adder for 32 pixels up
0B141 98                        GetCent:  tya                         ;send central position adder to A
0B142 75 CF                               adc Enemy_Y_Position,x      ;add to current vertical coordinate
0B144 95 58                               sta RedPTroopaCenterYPos,x  ;store as central vertical coordinate
0B146 A9 03                     TallBBox: lda #$03                    ;set specific bounding box size control
0B148 9D 9A 04                  SetBBox:  sta Enemy_BoundBoxCtrl,x    ;set bounding box control here
0B14B A9 02                               lda #$02                    ;set moving direction for left
0B14D 95 46                               sta Enemy_MovingDir,x
0B14F A9 00                     InitVStf: lda #$00                    ;initialize vertical speed
0B151 95 A0                               sta Enemy_Y_Speed,x         ;and movement force
0B153 9D 34 04                            sta Enemy_Y_MoveForce,x
0B156 60                                  rts
0B157                           
0B157                           InitBulletBill:
0B157 A9 02                           lda #$02                  ;set moving direction for left
0B159 95 46                           sta Enemy_MovingDir,x
0B15B A9 09                           lda #$09                  ;set bounding box control for $09
0B15D 9D 9A 04                        sta Enemy_BoundBoxCtrl,x
0B160 60                              rts
0B161                           
0B161                           InitCheepCheep:
0B161 20 32 B1                        jsr SmallBBox              ;set vertical bounding box, speed, init others
0B164 BD A7 07                        lda PseudoRandomBitReg,x   ;check one portion of LSFR
0B167 29 10                           and #%00010000             ;get d4 from it
0B169 95 58                           sta CheepCheepMoveMFlag,x  ;save as movement flag of some sort
0B16B B5 CF                           lda Enemy_Y_Position,x
0B16D 9D 34 04                        sta CheepCheepOrigYPos,x   ;save original vertical coordinate here
0B170 60                              rts
0B171                           
0B171                           InitLakitu:
0B171 AD CB 06                        lda EnemyFrenzyBuffer      ;check to see if an enemy is already in
0B174 D0 0B                           bne KillLakitu             ;the frenzy buffer, and branch to kill lakitu if so
0B176                           
0B176                           SetupLakitu:
0B176 A9 00                           lda #$00                   ;erase counter for lakitu's reappearance
0B178 8D D1 06                        sta LakituReappearTimer
0B17B 20 29 B1                        jsr InitHorizFlySwimEnemy  ;set $03 as bounding box, set other attributes
0B17E 4C F2 B5                        jmp TallBBox2              ;set $03 as bounding box again (not necessary) and leave
0B181                           
0B181                           KillLakitu:
0B181 4C B1 B7                        jmp EraseEnemyObject
0B184                           
0B184                           ;--------------------------------
0B184                           ;$01-$03 - used to hold pseudorandom difference adjusters
0B184                           
0B184                           PRDiffAdjustData:
0B184 26 2C 32 38                     .db $26, $2c, $32, $38
0B188 20 22 24 26                     .db $20, $22, $24, $26
0B18C 13 14 15 16                     .db $13, $14, $15, $16
0B190                           
0B190                           LakituAndSpinyHandler:
0B190 AD 8F 07                            lda FrenzyEnemyTimer    ;if timer here not expired, leave
0B193 D0 4A                               bne ExLSHand
0B195 E0 05                               cpx #$05                ;if we are on the special use slot, leave
0B197 B0 46                               bcs ExLSHand
0B199 A9 80                               lda #$80                ;set timer
0B19B 8D 8F 07                            sta FrenzyEnemyTimer
0B19E A0 04                               ldy #$04                ;start with the last enemy slot
0B1A0 B9 16 00                  ChkLak:   lda Enemy_ID,y          ;check all enemy slots to see
0B1A3 C9 11                               cmp #Lakitu             ;if lakitu is on one of them
0B1A5 F0 39                               beq CreateSpiny         ;if so, branch out of this loop
0B1A7 88                                  dey                     ;otherwise check another slot
0B1A8 10 F6                               bpl ChkLak              ;loop until all slots are checked
0B1AA EE D1 06                            inc LakituReappearTimer ;increment reappearance timer
0B1AD AD D1 06                            lda LakituReappearTimer
0B1B0 C9 03                               cmp #$03                ;check to see if we're up to a certain value yet
0B1B2 90 2B                               bcc ExLSHand            ;if not, leave
0B1B4 A2 04                               ldx #$04                ;start with the last enemy slot again
0B1B6 B5 0F                     ChkNoEn:  lda Enemy_Flag,x        ;check enemy buffer flag for non-active enemy slot
0B1B8 F0 05                               beq CreateL             ;branch out of loop if found
0B1BA CA                                  dex                     ;otherwise check next slot
0B1BB 10 F9                               bpl ChkNoEn             ;branch until all slots are checked
0B1BD 30 1E                               bmi RetEOfs             ;if no empty slots were found, branch to leave
0B1BF A9 00                     CreateL:  lda #$00                ;initialize enemy state
0B1C1 95 1E                               sta Enemy_State,x
0B1C3 A9 11                               lda #Lakitu             ;create lakitu enemy object
0B1C5 95 16                               sta Enemy_ID,x
0B1C7 20 76 B1                            jsr SetupLakitu         ;do a sub to set up lakitu
0B1CA A9 20                               lda #$20
0B1CC AC FB 07                            ldy HardWorldFlag
0B1CF F0 09                               beq SetLakXY            ;if in SMB1 levels, use default high position
0B1D1 AC 5F 07                            ldy WorldNumber
0B1D4 C0 06                               cpy #World7             ;if in 2J worlds 1-6, branch to use default high position
0B1D6 90 02                               bcc SetLakXY            ;otherwise put lakitu lower on the screen
0B1D8 A9 60                     SetLowLY: lda #$60
0B1DA 20 EA B3                  SetLakXY: jsr PutAtRightExtent    ;finish setting up lakitu
0B1DD A6 08                     RetEOfs:  ldx ObjectOffset        ;get enemy object buffer offset again and leave
0B1DF 60                        ExLSHand: rts
0B1E0                           
0B1E0                           CreateSpiny:
0B1E0 A5 CE                               lda Player_Y_Position      ;if player above a certain point, branch to leave
0B1E2 C9 2C                               cmp #$2c
0B1E4 90 F9                               bcc ExLSHand
0B1E6 B9 1E 00                            lda Enemy_State,y          ;if lakitu is not in normal state, branch to leave
0B1E9 D0 F4                               bne ExLSHand
0B1EB B9 6E 00                            lda Enemy_PageLoc,y        ;store horizontal coordinates (high and low) of lakitu
0B1EE 95 6E                               sta Enemy_PageLoc,x        ;into the coordinates of the spiny we're going to create
0B1F0 B9 87 00                            lda Enemy_X_Position,y
0B1F3 95 87                               sta Enemy_X_Position,x
0B1F5 A9 01                               lda #$01                   ;put spiny within vertical screen unit
0B1F7 95 B6                               sta Enemy_Y_HighPos,x
0B1F9 B9 CF 00                            lda Enemy_Y_Position,y     ;put spiny eight pixels above where lakitu is
0B1FC 38                                  sec
0B1FD E9 08                               sbc #$08
0B1FF 95 CF                               sta Enemy_Y_Position,x
0B201 BD A7 07                            lda PseudoRandomBitReg,x   ;get 2 LSB of LSFR and save to Y
0B204 29 03                               and #%00000011
0B206 A8                                  tay
0B207 A2 02                               ldx #$02
0B209 B9 84 B1                  DifLoop:  lda PRDiffAdjustData,y     ;get three values and save them
0B20C 95 01                               sta $01,x                  ;to $01-$03
0B20E C8                                  iny
0B20F C8                                  iny                        ;increment Y four bytes for each value
0B210 C8                                  iny
0B211 C8                                  iny
0B212 CA                                  dex                        ;decrement X for each one
0B213 10 F4                               bpl DifLoop                ;loop until all three are written
0B215 A6 08                               ldx ObjectOffset           ;get enemy object buffer offset
0B217 20 85 BD                            jsr PlayerLakituDiff       ;move enemy, change direction, get value - difference
0B21A A4 57                               ldy Player_X_Speed         ;check player's horizontal speed
0B21C C0 08                               cpy #$08
0B21E B0 0E                               bcs SetSpSpd               ;if moving faster than a certain amount, branch elsewhere
0B220 A8                                  tay                        ;otherwise save value in A to Y for now
0B221 BD A8 07                            lda PseudoRandomBitReg+1,x
0B224 29 03                               and #%00000011             ;get one of the LSFR parts and save the 2 LSB
0B226 F0 05                               beq UsePosv                ;branch if neither bits are set
0B228 98                                  tya
0B229 49 FF                               eor #%11111111             ;otherwise get two's compliment of Y
0B22B A8                                  tay
0B22C C8                                  iny
0B22D 98                        UsePosv:  tya                        ;put value from A in Y back to A (they will be lost anyway)
0B22E 20 32 B1                  SetSpSpd: jsr SmallBBox              ;set bounding box control, init attributes, lose contents of A
0B231 A0 02                               ldy #$02                   ;(putting this call elsewhere will preserve A)
0B233 95 58                               sta Enemy_X_Speed,x        ;set horizontal speed to zero because previous contents
0B235 C9 00                               cmp #$00                   ;of A were lost...branch here will never be taken for
0B237 30 01                               bmi SpinyRte               ;the same reason
0B239 88                                  dey
0B23A 94 46                     SpinyRte: sty Enemy_MovingDir,x      ;set moving direction to the right
0B23C A9 FD                               lda #$fd
0B23E 95 A0                               sta Enemy_Y_Speed,x        ;set vertical speed to move upwards
0B240 A9 01                               lda #$01
0B242 95 0F                               sta Enemy_Flag,x           ;enable enemy object by setting flag
0B244 A9 05                               lda #$05
0B246 95 1E                               sta Enemy_State,x          ;put spiny in egg state and leave
0B248 60                        ChpChpEx: rts
0B249                           
0B249                           ;--------------------------------
0B249                           
0B249                           FirebarSpinSpdData:
0B249 28 38 28 38 28                  .db $28, $38, $28, $38, $28
0B24E                           
0B24E                           FirebarSpinDirData:
0B24E 00 00 10 10 00                  .db $00, $00, $10, $10, $00
0B253                           
0B253                           InitLongFirebar:
0B253 20 87 B3                        jsr DuplicateEnemyObj       ;create enemy object for long firebar
0B256                           
0B256                           InitShortFirebar:
0B256 A9 00                           lda #$00                    ;initialize low byte of spin state
0B258 95 58                           sta FirebarSpinState_Low,x
0B25A B5 16                           lda Enemy_ID,x              ;subtract $1b from enemy identifier
0B25C 38                              sec                         ;to get proper offset for firebar data
0B25D E9 1B                           sbc #$1b
0B25F A8                              tay
0B260 B9 49 B2                        lda FirebarSpinSpdData,y    ;get spinning speed of firebar
0B263 9D 88 03                        sta FirebarSpinSpeed,x
0B266 B9 4E B2                        lda FirebarSpinDirData,y    ;get spinning direction of firebar
0B269 95 34                           sta FirebarSpinDirection,x
0B26B B5 CF                           lda Enemy_Y_Position,x
0B26D 18                              clc                         ;add four pixels to vertical coordinate
0B26E 69 04                           adc #$04
0B270 95 CF                           sta Enemy_Y_Position,x
0B272 B5 87                           lda Enemy_X_Position,x
0B274 18                              clc                         ;add four pixels to horizontal coordinate
0B275 69 04                           adc #$04
0B277 95 87                           sta Enemy_X_Position,x
0B279 B5 6E                           lda Enemy_PageLoc,x
0B27B 69 00                           adc #$00                    ;add carry to page location
0B27D 95 6E                           sta Enemy_PageLoc,x
0B27F 4C F2 B5                        jmp TallBBox2               ;set bounding box control (not used) and leave
0B282                           
0B282                           ;--------------------------------
0B282                           ;$00-$01 - used to hold pseudorandom bits
0B282                           
0B282                           FlyCCXPositionData:
0B282 80 30 40 80                     .db $80, $30, $40, $80
0B286 30 50 50 70                     .db $30, $50, $50, $70
0B28A 20 40 80 A0                     .db $20, $40, $80, $a0
0B28E 70 40 90 68                     .db $70, $40, $90, $68
0B292                           
0B292                           FlyCCXSpeedData:
0B292 0E 05 06 0E                     .db $0e, $05, $06, $0e
0B296 1C 20 10 0C                     .db $1c, $20, $10, $0c
0B29A 1E 22 18 14                     .db $1e, $22, $18, $14
0B29E                           
0B29E                           FlyCCTimerData:
0B29E 10 60 20 48                     .db $10, $60, $20, $48
0B2A2                           
0B2A2                           InitFlyingCheepCheep:
0B2A2 AD 8F 07                           lda FrenzyEnemyTimer       ;if timer here not expired yet, branch to leave
0B2A5 D0 A1                              bne ChpChpEx
0B2A7 20 32 B1                           jsr SmallBBox              ;jump to set bounding box size $09 and init other values
0B2AA BD A8 07                           lda PseudoRandomBitReg+1,x
0B2AD 29 03                              and #%00000011             ;set pseudorandom offset here
0B2AF A8                                 tay
0B2B0 B9 9E B2                           lda FlyCCTimerData,y       ;load timer with pseudorandom offset
0B2B3 8D 8F 07                           sta FrenzyEnemyTimer
0B2B6 A0 03                              ldy #$03                   ;load Y with default value
0B2B8 AD CC 06                           lda SecondaryHardMode
0B2BB F0 01                              beq MaxCC                  ;if secondary hard mode flag not set, do not increment Y
0B2BD C8                                 iny                        ;otherwise, increment Y to allow as many as four onscreen
0B2BE 84 00                     MaxCC:   sty $00                    ;store whatever pseudorandom bits are in Y
0B2C0 E4 00                              cpx $00                    ;compare enemy object buffer offset with Y
0B2C2 B0 84                              bcs ChpChpEx               ;if X => Y, branch to leave
0B2C4 BD A7 07                           lda PseudoRandomBitReg,x
0B2C7 29 03                              and #%00000011             ;get last two bits of LSFR, first part
0B2C9 85 00                              sta $00                    ;and store in two places
0B2CB 85 01                              sta $01
0B2CD A9 FB                              lda #$fb                   ;set vertical speed for cheep-cheep
0B2CF 95 A0                              sta Enemy_Y_Speed,x
0B2D1 A9 00                              lda #$00                   ;load default value
0B2D3 A4 57                              ldy Player_X_Speed         ;check player's horizontal speed
0B2D5 F0 07                              beq GSeed                  ;if player not moving left or right, skip this part
0B2D7 A9 04                              lda #$04
0B2D9 C0 19                              cpy #$19                   ;if moving to the right but not very quickly,
0B2DB 90 01                              bcc GSeed                  ;do not change A
0B2DD 0A                                 asl                        ;otherwise, multiply A by 2
0B2DE 48                        GSeed:   pha                        ;save to stack
0B2DF 18                                 clc
0B2E0 65 00                              adc $00                    ;add to last two bits of LSFR we saved earlier
0B2E2 85 00                              sta $00                    ;save it there
0B2E4 BD A8 07                           lda PseudoRandomBitReg+1,x
0B2E7 29 03                              and #%00000011             ;if neither of the last two bits of second LSFR set,
0B2E9 F0 07                              beq RSeed                  ;skip this part and save contents of $00
0B2EB BD A9 07                           lda PseudoRandomBitReg+2,x
0B2EE 29 0F                              and #%00001111             ;otherwise overwrite with lower nybble of
0B2F0 85 00                              sta $00                    ;third LSFR part
0B2F2 68                        RSeed:   pla                        ;get value from stack we saved earlier
0B2F3 18                                 clc
0B2F4 65 01                              adc $01                    ;add to last two bits of LSFR we saved in other place
0B2F6 A8                                 tay                        ;use as pseudorandom offset here
0B2F7 B9 92 B2                           lda FlyCCXSpeedData,y      ;get horizontal speed using pseudorandom offset
0B2FA 95 58                              sta Enemy_X_Speed,x
0B2FC A9 01                              lda #$01                   ;set to move towards the right
0B2FE 95 46                              sta Enemy_MovingDir,x
0B300 A5 57                              lda Player_X_Speed         ;if player moving left or right, branch ahead of this part
0B302 D0 12                              bne D2XPos1
0B304 A4 00                              ldy $00                    ;get first LSFR or third LSFR lower nybble
0B306 98                                 tya                        ;and check for d1 set
0B307 29 02                              and #%00000010
0B309 F0 0B                              beq D2XPos1                ;if d1 not set, branch
0B30B B5 58                              lda Enemy_X_Speed,x
0B30D 49 FF                              eor #$ff                   ;if d1 set, change horizontal speed
0B30F 18                                 clc                        ;into two's compliment, thus moving in the opposite
0B310 69 01                              adc #$01                   ;direction
0B312 95 58                              sta Enemy_X_Speed,x
0B314 F6 46                              inc Enemy_MovingDir,x      ;increment to move towards the left
0B316 98                        D2XPos1: tya                        ;get first LSFR or third LSFR lower nybble again
0B317 29 02                              and #%00000010
0B319 F0 0F                              beq D2XPos2                ;check for d1 set again, branch again if not set
0B31B A5 86                              lda Player_X_Position      ;get player's horizontal position
0B31D 18                                 clc
0B31E 79 82 B2                           adc FlyCCXPositionData,y   ;if d1 set, add value obtained from pseudorandom offset
0B321 95 87                              sta Enemy_X_Position,x     ;and save as enemy's horizontal position
0B323 A5 6D                              lda Player_PageLoc         ;get player's page location
0B325 69 00                              adc #$00                   ;add carry and jump past this part
0B327 4C 36 B3                           jmp FinCCSt
0B32A A5 86                     D2XPos2: lda Player_X_Position      ;get player's horizontal position
0B32C 38                                 sec
0B32D F9 82 B2                           sbc FlyCCXPositionData,y   ;if d1 not set, subtract value obtained from pseudorandom
0B330 95 87                              sta Enemy_X_Position,x     ;offset and save as enemy's horizontal position
0B332 A5 6D                              lda Player_PageLoc         ;get player's page location
0B334 E9 00                              sbc #$00                   ;subtract borrow
0B336 95 6E                     FinCCSt: sta Enemy_PageLoc,x        ;save as enemy's page location
0B338 A9 01                              lda #$01
0B33A 95 0F                              sta Enemy_Flag,x           ;set enemy's buffer flag
0B33C 95 B6                              sta Enemy_Y_HighPos,x      ;set enemy's high vertical byte
0B33E A9 F8                              lda #$f8
0B340 95 CF                              sta Enemy_Y_Position,x     ;put enemy below the screen, and we are done
0B342 60                                 rts
0B343                           
0B343                           InitBowser:
0B343 A0 04                               ldy #$04              ;if the slot about to be checked is the slot
0B345 C4 08                     KKCheck:  cpy ObjectOffset      ;where bowser is being initialized, skip it
0B347 F0 0F                               beq NoBowser
0B349 B9 16 00                            lda Enemy_ID,y        ;otherwise check to see if a bowser object
0B34C C9 2D                               cmp #Bowser           ;exists in another slot
0B34E D0 08                               bne NoBowser          ;if not, branch to check another enemy slot
0B350 A9 00                               lda #$00
0B352 99 16 00                            sta Enemy_ID,y        ;do this until any previous bowser objects are erased
0B355 99 0F 00                            sta Enemy_Flag,y
0B358 88                        NoBowser: dey                   ;loop until all slots are checked
0B359 10 EA                               bpl KKCheck           ;except the slot where bowser is being initialized
0B35B                           
0B35B                           CreateBowser:
0B35B 20 87 B3                        jsr DuplicateEnemyObj     ;jump to create another bowser object
0B35E 8E 68 03                        stx BowserFront_Offset    ;save offset of first here
0B361 A9 00                           lda #$00
0B363 8D 63 03                        sta BowserBodyControls    ;initialize bowser's body controls
0B366 8D 69 03                        sta BridgeCollapseOffset  ;and bridge collapse offset
0B369 B5 87                           lda Enemy_X_Position,x
0B36B 8D 66 03                        sta BowserOrigXPos        ;store original horizontal position here
0B36E A9 DF                           lda #$df
0B370 8D 90 07                        sta BowserFireBreathTimer ;store something here
0B373 95 46                           sta Enemy_MovingDir,x     ;and in moving direction
0B375 A9 20                           lda #$20
0B377 8D 64 03                        sta BowserFeetCounter     ;set bowser's feet timer and in enemy timer
0B37A 9D 8A 07                        sta EnemyFrameTimer,x
0B37D A9 05                           lda #$05
0B37F 8D 83 04                        sta BowserHitPoints       ;give bowser 5 hit points
0B382 4A                              lsr
0B383 8D 65 03                        sta BowserMovementSpeed   ;set default movement speed here
0B386 60                              rts
0B387                           
0B387                           DuplicateEnemyObj:
0B387 A0 FF                             ldy #$ff                ;start at beginning of enemy slots
0B389 C8                        FSLoop: iny                     ;increment one slot
0B38A B9 0F 00                          lda Enemy_Flag,y        ;check enemy buffer flag for empty slot
0B38D D0 FA                             bne FSLoop              ;if set, branch and keep checking
0B38F 8C CF 06                          sty DuplicateObj_Offset ;otherwise set offset here
0B392 8A                                txa                     ;transfer original enemy buffer offset
0B393 09 80                             ora #%10000000          ;store with d7 set as flag in new enemy
0B395 99 0F 00                          sta Enemy_Flag,y        ;slot as well as enemy offset
0B398 B5 6E                             lda Enemy_PageLoc,x
0B39A 99 6E 00                          sta Enemy_PageLoc,y     ;copy page location and horizontal coordinates
0B39D B5 87                             lda Enemy_X_Position,x  ;from original enemy to new enemy
0B39F 99 87 00                          sta Enemy_X_Position,y
0B3A2 A9 01                             lda #$01
0B3A4 95 0F                             sta Enemy_Flag,x        ;set flag as normal for original enemy
0B3A6 99 B6 00                          sta Enemy_Y_HighPos,y   ;set high vertical byte for new enemy
0B3A9 B5 CF                             lda Enemy_Y_Position,x
0B3AB 99 CF 00                          sta Enemy_Y_Position,y  ;copy vertical coordinate from original to new
0B3AE 60                        FlmEx:  rts                     ;and then leave
0B3AF                           
0B3AF                           ;--------------------------------
0B3AF                           
0B3AF                           FlameYPosData:
0B3AF 90 80 70 90                     .db $90, $80, $70, $90
0B3B3                           
0B3B3                           FlameYMFAdderData:
0B3B3 FF 01                           .db $ff, $01
0B3B5                           
0B3B5                           InitBowserFlame:
0B3B5 AD 8F 07                          lda FrenzyEnemyTimer        ;if timer not expired yet, branch to leave
0B3B8 D0 F4                             bne FlmEx
0B3BA 9D 34 04                          sta Enemy_Y_MoveForce,x     ;reset something here
0B3BD A5 FD                             lda NoiseSoundQueue
0B3BF 09 02                             ora #Sfx_BowserFlame        ;load bowser's flame sound into queue
0B3C1 85 FD                             sta NoiseSoundQueue
0B3C3 AC 68 03                          ldy BowserFront_Offset      ;get bowser's buffer offset
0B3C6 B9 16 00                          lda Enemy_ID,y              ;check for bowser
0B3C9 C9 2D                             cmp #Bowser
0B3CB F0 31                             beq SpawnFromMouth          ;branch if found
0B3CD 20 FA BF                          jsr SetFlameTimer           ;get timer data based on flame counter
0B3D0 18                                clc
0B3D1 69 20                             adc #$20                    ;add 32 frames by default
0B3D3 AC CC 06                          ldy SecondaryHardMode
0B3D6 F0 03                             beq SetFrT                  ;if secondary mode flag not set, use as timer setting
0B3D8 38                                sec
0B3D9 E9 10                             sbc #$10                    ;otherwise subtract 16 frames for secondary hard mode
0B3DB 8D 8F 07                  SetFrT: sta FrenzyEnemyTimer        ;set timer accordingly
0B3DE BD A7 07                          lda PseudoRandomBitReg,x
0B3E1 29 03                             and #%00000011              ;get 2 LSB from first part of LSFR
0B3E3 9D 17 04                          sta BowserFlamePRandomOfs,x ;set here
0B3E6 A8                                tay                         ;use as offset
0B3E7 B9 AF B3                          lda FlameYPosData,y         ;load vertical position based on pseudorandom offset
0B3EA                           
0B3EA                           PutAtRightExtent:
0B3EA 95 CF                           sta Enemy_Y_Position,x    ;set vertical position
0B3EC AD 1D 07                        lda ScreenRight_X_Pos
0B3EF 18                              clc
0B3F0 69 20                           adc #$20                  ;place enemy 32 pixels beyond right side of screen
0B3F2 95 87                           sta Enemy_X_Position,x
0B3F4 AD 1B 07                        lda ScreenRight_PageLoc
0B3F7 69 00                           adc #$00                  ;add carry
0B3F9 95 6E                           sta Enemy_PageLoc,x
0B3FB 4C 31 B4                        jmp FinishFlame           ;skip this part to finish setting values
0B3FE                           
0B3FE                           SpawnFromMouth:
0B3FE B9 87 00                         lda Enemy_X_Position,y    ;get bowser's horizontal position
0B401 38                               sec
0B402 E9 0E                            sbc #$0e                  ;subtract 14 pixels
0B404 95 87                            sta Enemy_X_Position,x    ;save as flame's horizontal position
0B406 B9 6E 00                         lda Enemy_PageLoc,y
0B409 95 6E                            sta Enemy_PageLoc,x       ;copy page location from bowser to flame
0B40B B9 CF 00                         lda Enemy_Y_Position,y
0B40E 18                               clc                       ;add 8 pixels to bowser's vertical position
0B40F 69 08                            adc #$08
0B411 95 CF                            sta Enemy_Y_Position,x    ;save as flame's vertical position
0B413 BD A7 07                         lda PseudoRandomBitReg,x
0B416 29 03                            and #%00000011            ;get 2 LSB from first part of LSFR
0B418 9D 17 04                         sta Enemy_YMF_Dummy,x     ;save here
0B41B A8                               tay                       ;use as offset
0B41C B9 AF B3                         lda FlameYPosData,y       ;get value here using bits as offset
0B41F A0 00                            ldy #$00                  ;load default offset
0B421 D5 CF                            cmp Enemy_Y_Position,x    ;compare value to flame's current vertical position
0B423 90 01                            bcc SetMF                 ;if less, do not increment offset
0B425 C8                               iny                       ;otherwise increment now
0B426 B9 B3 B3                  SetMF: lda FlameYMFAdderData,y   ;get value here and save
0B429 9D 34 04                         sta Enemy_Y_MoveForce,x   ;to vertical movement force
0B42C A9 00                            lda #$00
0B42E 8D CB 06                         sta EnemyFrenzyBuffer     ;clear enemy frenzy buffer
0B431                           
0B431                           FinishFlame:
0B431 A9 08                           lda #$08                 ;set $08 for bounding box control
0B433 9D 9A 04                        sta Enemy_BoundBoxCtrl,x
0B436 A9 01                           lda #$01                 ;set high byte of vertical and
0B438 95 B6                           sta Enemy_Y_HighPos,x    ;enemy buffer flag
0B43A 95 0F                           sta Enemy_Flag,x
0B43C 4A                              lsr
0B43D 9D 01 04                        sta Enemy_X_MoveForce,x  ;initialize horizontal movement force, and
0B440 95 1E                           sta Enemy_State,x        ;enemy state
0B442 60                              rts
0B443                           
0B443                           ;--------------------------------
0B443                           
0B443                           FireworksXPosData:
0B443 00 30 60 60 00 20               .db $00, $30, $60, $60, $00, $20
0B449                           
0B449                           FireworksYPosData:
0B449 60 40 70 40 60 30               .db $60, $40, $70, $40, $60, $30
0B44F                           
0B44F                           InitFireworks:
0B44F AD 8F 07                            lda FrenzyEnemyTimer         ;if timer not expired yet, branch to leave
0B452 D0 47                               bne ExitFWk
0B454 A9 20                               lda #$20                     ;otherwise reset timer
0B456 8D 8F 07                            sta FrenzyEnemyTimer
0B459 CE D7 06                            dec FireworksCounter         ;decrement for each explosion
0B45C A0 06                               ldy #$06                     ;start at last slot
0B45E 88                        StarFChk: dey
0B45F B9 16 00                            lda Enemy_ID,y               ;check for presence of star flag object
0B462 C9 31                               cmp #StarFlagObject          ;if there isn't a star flag object,
0B464 D0 F8                               bne StarFChk                 ;routine goes into infinite loop = crash
0B466 B9 87 00                            lda Enemy_X_Position,y
0B469 38                                  sec                          ;get horizontal coordinate of star flag object, then
0B46A E9 30                               sbc #$30                     ;subtract 48 pixels from it and save to
0B46C 48                                  pha                          ;the stack
0B46D B9 6E 00                            lda Enemy_PageLoc,y
0B470 E9 00                               sbc #$00                     ;subtract the carry from the page location
0B472 85 00                               sta $00                      ;of the star flag object
0B474 AD D7 06                            lda FireworksCounter         ;get fireworks counter
0B477 18                                  clc
0B478 79 1E 00                            adc Enemy_State,y            ;add state of star flag object (possibly not necessary)
0B47B A8                                  tay                          ;use as offset
0B47C 68                                  pla                          ;get saved horizontal coordinate of star flag - 48 pixels
0B47D 18                                  clc
0B47E 79 43 B4                            adc FireworksXPosData,y      ;add number based on offset of fireworks counter
0B481 95 87                               sta Enemy_X_Position,x       ;store as the fireworks object horizontal coordinate
0B483 A5 00                               lda $00
0B485 69 00                               adc #$00                     ;add carry and store as page location for
0B487 95 6E                               sta Enemy_PageLoc,x          ;the fireworks object
0B489 B9 49 B4                            lda FireworksYPosData,y      ;get vertical position using same offset
0B48C 95 CF                               sta Enemy_Y_Position,x       ;and store as vertical coordinate for fireworks object
0B48E A9 01                               lda #$01
0B490 95 B6                               sta Enemy_Y_HighPos,x        ;store in vertical high byte
0B492 95 0F                               sta Enemy_Flag,x             ;and activate enemy buffer flag
0B494 4A                                  lsr
0B495 95 58                               sta ExplosionGfxCounter,x    ;initialize explosion counter
0B497 A9 08                               lda #$08
0B499 95 A0                               sta ExplosionTimerCounter,x  ;set explosion timing counter
0B49B 60                        ExitFWk:  rts
0B49C                           
0B49C                           ;--------------------------------
0B49C                           
0B49C                           Bitmasks:
0B49C 01 02 04 08 10 20 40 80         .db %00000001, %00000010, %00000100, %00001000, %00010000, %00100000, %01000000, %10000000
0B4A4                           
0B4A4                           Enemy17YPosData:
0B4A4 40 30 90 50 20 60 A0 70         .db $40, $30, $90, $50, $20, $60, $a0, $70
0B4AC                           
0B4AC                           SwimCC_IDData:
0B4AC 0A 0B                           .db $0a, $0b
0B4AE                           
0B4AE                           BulletBillCheepCheep:
0B4AE AD 8F 07                           lda FrenzyEnemyTimer      ;if timer not expired yet, branch to leave
0B4B1 D0 6F                              bne ExF17
0B4B3 AD 4E 07                           lda AreaType              ;are we in a water-type level?
0B4B6 D0 57                              bne DoBulletBills         ;if not, branch elsewhere
0B4B8 E0 03                              cpx #$03                  ;are we past third enemy slot?
0B4BA B0 66                              bcs ExF17                 ;if so, branch to leave
0B4BC A0 00                              ldy #$00                  ;load default offset
0B4BE BD A7 07                           lda PseudoRandomBitReg,x
0B4C1 C9 AA                              cmp #$aa                  ;check first part of LSFR against preset value
0B4C3 90 01                              bcc ChkW2                 ;if less than preset, do not increment offset
0B4C5 C8                                 iny                       ;otherwise increment
0B4C6 AD 5F 07                  ChkW2:   lda WorldNumber           ;check world number
0B4C9 C9 01                              cmp #World2
0B4CB F0 01                              beq Get17ID               ;if we're on world 2, do not increment offset
0B4CD C8                                 iny                       ;otherwise increment
0B4CE 98                        Get17ID: tya
0B4CF 29 01                              and #%00000001            ;mask out all but last bit of offset
0B4D1 A8                                 tay
0B4D2 B9 AC B4                           lda SwimCC_IDData,y       ;load identifier for cheep-cheeps
0B4D5 95 16                     Set17ID: sta Enemy_ID,x            ;store whatever's in A as enemy identifier
0B4D7 AD DD 06                           lda BitMFilter
0B4DA C9 FF                              cmp #$ff                  ;if not all bits set, skip init part and compare bits
0B4DC D0 05                              bne GetRBit
0B4DE A9 00                              lda #$00                  ;initialize vertical position filter
0B4E0 8D DD 06                           sta BitMFilter
0B4E3 BD A7 07                  GetRBit: lda PseudoRandomBitReg,x  ;get first part of LSFR
0B4E6 29 07                              and #%00000111            ;mask out all but 3 LSB
0B4E8 A8                        ChkRBit: tay                       ;use as offset
0B4E9 B9 9C B4                           lda Bitmasks,y            ;load bitmask
0B4EC 2C DD 06                           bit BitMFilter            ;perform AND on filter without changing it
0B4EF F0 07                              beq AddFBit
0B4F1 C8                                 iny                       ;increment offset
0B4F2 98                                 tya
0B4F3 29 07                              and #%00000111            ;mask out all but 3 LSB thus keeping it 0-7
0B4F5 4C E8 B4                           jmp ChkRBit               ;do another check
0B4F8 0D DD 06                  AddFBit: ora BitMFilter            ;add bit to already set bits in filter
0B4FB 8D DD 06                           sta BitMFilter            ;and store
0B4FE B9 A4 B4                           lda Enemy17YPosData,y     ;load vertical position using offset
0B501 20 EA B3                           jsr PutAtRightExtent      ;set vertical position and other values
0B504 9D 17 04                           sta Enemy_YMF_Dummy,x     ;initialize dummy variable
0B507 A9 20                              lda #$20                  ;set timer
0B509 8D 8F 07                           sta FrenzyEnemyTimer
0B50C 4C 4C B0                           jmp CheckpointEnemyID     ;process our new enemy object
0B50F                           
0B50F                           DoBulletBills:
0B50F A0 FF                               ldy #$ff                   ;start at beginning of enemy slots
0B511 C8                        BB_SLoop: iny                        ;move onto the next slot
0B512 C0 05                               cpy #$05                   ;branch to play sound if we've done all slots
0B514 B0 0D                               bcs FireBulletBill
0B516 B9 0F 00                            lda Enemy_Flag,y           ;if enemy buffer flag not set,
0B519 F0 F6                               beq BB_SLoop               ;loop back and check another slot
0B51B B9 16 00                            lda Enemy_ID,y
0B51E C9 08                               cmp #BulletBill_FrenzyVar  ;check enemy identifier for
0B520 D0 EF                               bne BB_SLoop               ;bullet bill object (frenzy variant)
0B522 60                        ExF17:    rts                        ;if found, leave
0B523                           
0B523                           FireBulletBill:
0B523 A5 FE                           lda Square2SoundQueue
0B525 09 08                           ora #Sfx_Blast            ;play fireworks/gunfire sound
0B527 85 FE                           sta Square2SoundQueue
0B529 A9 08                           lda #BulletBill_FrenzyVar ;load identifier for bullet bill object
0B52B D0 A8                           bne Set17ID               ;unconditional branch
0B52D                           
0B52D                           ;--------------------------------
0B52D                           ;$00 - used to store Y position of group enemies
0B52D                           ;$01 - used to store enemy ID
0B52D                           ;$02 - used to store page location of right side of screen
0B52D                           ;$03 - used to store X position of right side of screen
0B52D                           
0B52D                           HandleGroupEnemies:
0B52D A0 00                             ldy #$00                  ;load value for green koopa troopa
0B52F 38                                sec
0B530 E9 37                             sbc #$37                  ;subtract $37 from second byte read
0B532 48                                pha                       ;save result in stack for now
0B533 C9 04                             cmp #$04                  ;was byte in $3b-$3e range?
0B535 B0 0B                             bcs SnglID                ;if so, branch
0B537 48                                pha                       ;save another copy to stack
0B538 A0 06                             ldy #Goomba               ;load value for goomba enemy
0B53A AD 6A 07                          lda PrimaryHardMode       ;if primary hard mode flag not set,
0B53D F0 02                             beq PullID                ;branch, otherwise change to value
0B53F A0 02                             ldy #BuzzyBeetle          ;for buzzy beetle
0B541 68                        PullID: pla                       ;get second copy from stack
0B542 84 01                     SnglID: sty $01                   ;save enemy id here
0B544 A0 B0                             ldy #$b0                  ;load default y coordinate
0B546 29 02                             and #$02                  ;check to see if d1 was set
0B548 F0 02                             beq SetYGp                ;if so, move y coordinate up,
0B54A A0 70                             ldy #$70                  ;otherwise branch and use default
0B54C 84 00                     SetYGp: sty $00                   ;save y coordinate here
0B54E AD 1B 07                          lda ScreenRight_PageLoc   ;get page number of right edge of screen
0B551 85 02                             sta $02                   ;save here
0B553 AD 1D 07                          lda ScreenRight_X_Pos     ;get pixel coordinate of right edge
0B556 85 03                             sta $03                   ;save here
0B558 A0 02                             ldy #$02                  ;load two enemies by default
0B55A 68                                pla                       ;get first copy from stack
0B55B 4A                                lsr                       ;check to see if d0 was set
0B55C 90 01                             bcc CntGrp                ;if not, use default value
0B55E C8                                iny                       ;otherwise increment to three enemies
0B55F 8C D3 06                  CntGrp: sty NumberofGroupEnemies  ;save number of enemies here
0B562 A2 FF                     GrLoop: ldx #$ff                  ;start at beginning of enemy buffers
0B564 E8                        GSltLp: inx                       ;increment and branch if past
0B565 E0 05                             cpx #$05                  ;end of buffers
0B567 B0 2D                             bcs NextED
0B569 B5 0F                             lda Enemy_Flag,x          ;check to see if enemy is already
0B56B D0 F7                             bne GSltLp                ;stored in buffer, and branch if so
0B56D A5 01                             lda $01
0B56F 95 16                             sta Enemy_ID,x            ;store enemy object identifier
0B571 A5 02                             lda $02
0B573 95 6E                             sta Enemy_PageLoc,x       ;store page location for enemy object
0B575 A5 03                             lda $03
0B577 95 87                             sta Enemy_X_Position,x    ;store x coordinate for enemy object
0B579 18                                clc
0B57A 69 18                             adc #$18                  ;add 24 pixels for next enemy
0B57C 85 03                             sta $03
0B57E A5 02                             lda $02                   ;add carry to page location for
0B580 69 00                             adc #$00                  ;next enemy
0B582 85 02                             sta $02
0B584 A5 00                             lda $00                   ;store y coordinate for enemy object
0B586 95 CF                             sta Enemy_Y_Position,x
0B588 A9 01                             lda #$01                  ;activate flag for buffer, and
0B58A 95 B6                             sta Enemy_Y_HighPos,x     ;put enemy within the screen vertically
0B58C 95 0F                             sta Enemy_Flag,x
0B58E 20 4C B0                          jsr CheckpointEnemyID     ;process each enemy object separately
0B591 CE D3 06                          dec NumberofGroupEnemies  ;do this until we run out of enemy objects
0B594 D0 CC                             bne GrLoop
0B596 4C 3E B0                  NextED: jmp Inc2B                 ;jump to increment data offset and leave
0B599                           
0B599                           ;--------------------------------
0B599                           ;$00 - used to store piranha plant attribute data
0B599                           ;$01 - used to store piranha plant range data for player
0B599                           
0B599                           InitPiranhaPlant:
0B599 A9 01                              lda #$01                     ;set initial speed
0B59B 95 58                              sta PiranhaPlant_Y_Speed,x
0B59D 4A                                 lsr
0B59E 95 1E                              sta Enemy_State,x            ;initialize enemy state and what would normally
0B5A0 95 A0                              sta PiranhaPlant_MoveFlag,x  ;be used as vertical speed, but not in this case
0B5A2 B5 CF                              lda Enemy_Y_Position,x
0B5A4 9D 34 04                           sta PiranhaPlantDownYPos,x   ;save original vertical coordinate here
0B5A7 38                                 sec
0B5A8 E9 18                              sbc #$18
0B5AA 9D 17 04                           sta PiranhaPlantUpYPos,x     ;save original vertical coordinate - 24 pixels here
0B5AD A9 09                              lda #$09
0B5AF 4C F4 B5                           jmp SetBBox2                 ;set specific value for bounding box control
0B5B2                           
0B5B2                           ;--------------------------------
0B5B2                           
0B5B2                           InitEnemyFrenzy:
0B5B2 B5 16                           lda Enemy_ID,x        ;load enemy identifier
0B5B4 8D CB 06                        sta EnemyFrenzyBuffer ;save in enemy frenzy buffer
0B5B7 38                              sec
0B5B8 E9 12                           sbc #$12              ;subtract 12 and use as offset for jump engine
0B5BA 20 F8 8C                        jsr JumpEngine
0B5BD                           
0B5BD                           ;frenzy object jump table
0B5BD 90 B1                           .dw LakituAndSpinyHandler
0B5BF C9 B5                           .dw NoFrenzyCode
0B5C1 A2 B2                           .dw InitFlyingCheepCheep
0B5C3 B5 B3                           .dw InitBowserFlame
0B5C5 4F B4                           .dw InitFireworks
0B5C7 AE B4                           .dw BulletBillCheepCheep
0B5C9                           
0B5C9                           NoFrenzyCode:
0B5C9 60                              rts
0B5CA                           
0B5CA                           EndFrenzy:
0B5CA A0 05                                ldy #$05               ;start at last slot
0B5CC B9 16 00                  LakituChk: lda Enemy_ID,y         ;check enemy identifiers
0B5CF C9 11                                cmp #Lakitu            ;for lakitu
0B5D1 D0 05                                bne NextFSlot
0B5D3 A9 01                                lda #$01               ;if found, set state
0B5D5 99 1E 00                             sta Enemy_State,y
0B5D8 88                        NextFSlot: dey                    ;move onto the next slot
0B5D9 10 F1                                bpl LakituChk          ;do this until all slots are checked
0B5DB A9 00                                lda #$00
0B5DD 8D CB 06                             sta EnemyFrenzyBuffer  ;empty enemy frenzy buffer
0B5E0 95 0F                                sta Enemy_Flag,x       ;disable enemy buffer flag for this object
0B5E2 60                                   rts
0B5E3                           
0B5E3                           ;--------------------------------
0B5E3                           
0B5E3                           InitJumpGPTroopa:
0B5E3 A9 02                                lda #$02                  ;set for movement to the left
0B5E5 95 46                                sta Enemy_MovingDir,x
0B5E7 A9 F8                                lda #$f8                  ;load default horizontal speed
0B5E9 AC FB 07                             ldy HardWorldFlag         ;are we playing SMB1 levels?
0B5EC F0 02                                beq JumpGPSpd             ;use default horizontal speed if so
0B5EE A9 F4                                lda #$f4                  ;otherwise load alternate horizontal speed
0B5F0 95 58                     JumpGPSpd: sta Enemy_X_Speed,x       ;and store it
0B5F2 A9 03                     TallBBox2: lda #$03                  ;set specific value for bounding box control
0B5F4 9D 9A 04                  SetBBox2:  sta Enemy_BoundBoxCtrl,x  ;set bounding box control then leave
0B5F7 60                                   rts
0B5F8                           
0B5F8                           ;--------------------------------
0B5F8                           
0B5F8                           InitBalPlatform:
0B5F8 D6 CF                             dec Enemy_Y_Position,x    ;raise vertical position by two pixels
0B5FA D6 CF                             dec Enemy_Y_Position,x
0B5FC AC CC 06                          ldy SecondaryHardMode     ;if secondary hard mode flag not set,
0B5FF D0 05                             bne AlignP                ;branch ahead
0B601 A0 02                             ldy #$02                  ;otherwise set value here
0B603 20 8A B6                          jsr PosPlatform           ;do a sub to add or subtract pixels
0B606 A0 FF                     AlignP: ldy #$ff                  ;set default value here for now
0B608 AD A0 03                          lda BalPlatformAlignment  ;get current balance platform alignment
0B60B 95 1E                             sta Enemy_State,x         ;set platform alignment to object state here
0B60D 10 02                             bpl SetBPA                ;if old alignment $ff, put $ff as alignment for negative
0B60F 8A                                txa                       ;if old contents already $ff, put
0B610 A8                                tay                       ;object offset as alignment to make next positive
0B611 8C A0 03                  SetBPA: sty BalPlatformAlignment  ;store whatever value's in Y here
0B614 A9 00                             lda #$00
0B616 95 46                             sta Enemy_MovingDir,x     ;init moving direction
0B618 A8                                tay                       ;init Y
0B619 20 8A B6                          jsr PosPlatform           ;do a sub to add 8 pixels, then run shared code here
0B61C                           
0B61C                           ;--------------------------------
0B61C                           
0B61C                           InitDropPlatform:
0B61C A9 FF                           lda #$ff
0B61E 9D A2 03                        sta PlatformCollisionFlag,x  ;set some value here
0B621 4C 41 B6                        jmp CommonPlatCode           ;then jump ahead to execute more code
0B624                           
0B624                           ;--------------------------------
0B624                           
0B624                           InitHoriPlatform:
0B624 A9 00                           lda #$00
0B626 95 58                           sta XMoveSecondaryCounter,x  ;init one of the moving counters
0B628 4C 41 B6                        jmp CommonPlatCode           ;jump ahead to execute more code
0B62B                           
0B62B                           ;--------------------------------
0B62B                           
0B62B                           InitVertPlatform:
0B62B A0 40                            ldy #$40                    ;set default value here
0B62D B5 CF                            lda Enemy_Y_Position,x      ;check vertical position
0B62F 10 07                            bpl SetYO                   ;if above a certain point, skip this part
0B631 49 FF                            eor #$ff
0B633 18                               clc                         ;otherwise get two's compliment
0B634 69 01                            adc #$01
0B636 A0 C0                            ldy #$c0                    ;get alternate value to add to vertical position
0B638 9D 01 04                  SetYO: sta YPlatformTopYPos,x      ;save as top vertical position
0B63B 98                               tya
0B63C 18                               clc                         ;load value from earlier, add number of pixels 
0B63D 75 CF                            adc Enemy_Y_Position,x      ;to vertical position
0B63F 95 58                            sta YPlatformCenterYPos,x   ;save result as central vertical position
0B641                           
0B641                           ;--------------------------------
0B641                           
0B641                           CommonPlatCode: 
0B641 20 4F B1                          jsr InitVStf              ;do a sub to init certain other values 
0B644 A9 05                     SPBBox: lda #$05                  ;set default bounding box size control
0B646 AC 4E 07                          ldy AreaType
0B649 C0 03                             cpy #$03                  ;check for castle-type level
0B64B F0 07                             beq CasPBB                ;use default value if found
0B64D AC CC 06                          ldy SecondaryHardMode     ;otherwise check for secondary hard mode flag
0B650 D0 02                             bne CasPBB                ;if set, use default value
0B652 A9 06                             lda #$06                  ;use alternate value if not castle or secondary not set
0B654 9D 9A 04                  CasPBB: sta Enemy_BoundBoxCtrl,x  ;set bounding box size control here and leave
0B657 60                                rts
0B658                           
0B658                           ;--------------------------------
0B658                           
0B658                           LargeLiftUp:
0B658 20 64 B6                        jsr PlatLiftUp       ;execute code for platforms going up
0B65B 4C 61 B6                        jmp LargeLiftBBox    ;overwrite bounding box for large platforms
0B65E                           
0B65E                           LargeLiftDown:
0B65E 20 70 B6                        jsr PlatLiftDown     ;execute code for platforms going down
0B661                           
0B661                           LargeLiftBBox:
0B661 4C 44 B6                        jmp SPBBox           ;jump to overwrite bounding box size control
0B664                           
0B664                           ;--------------------------------
0B664                           
0B664                           PlatLiftUp:
0B664 A9 10                           lda #$10                 ;set movement amount here
0B666 9D 34 04                        sta Enemy_Y_MoveForce,x
0B669 A9 FF                           lda #$ff                 ;set moving speed for platforms going up
0B66B 95 A0                           sta Enemy_Y_Speed,x
0B66D 4C 79 B6                        jmp CommonSmallLift      ;skip ahead to part we should be executing
0B670                           
0B670                           ;--------------------------------
0B670                           
0B670                           PlatLiftDown:
0B670 A9 F0                           lda #$f0                 ;set movement amount here
0B672 9D 34 04                        sta Enemy_Y_MoveForce,x
0B675 A9 00                           lda #$00                 ;set moving speed for platforms going down
0B677 95 A0                           sta Enemy_Y_Speed,x
0B679                           
0B679                           ;--------------------------------
0B679                           
0B679                           CommonSmallLift:
0B679 A0 01                           ldy #$01
0B67B 20 8A B6                        jsr PosPlatform           ;do a sub to add 12 pixels due to preset value  
0B67E A9 04                           lda #$04
0B680 9D 9A 04                        sta Enemy_BoundBoxCtrl,x  ;set bounding box control for small platforms
0B683 60                              rts
0B684                           
0B684                           ;--------------------------------
0B684                           
0B684                           PlatPosDataLow:
0B684 08 0C F8                        .db $08,$0c,$f8
0B687                           
0B687                           PlatPosDataHigh:
0B687 00 00 FF                        .db $00,$00,$ff
0B68A                           
0B68A                           PosPlatform:
0B68A B5 87                           lda Enemy_X_Position,x  ;get horizontal coordinate
0B68C 18                              clc
0B68D 79 84 B6                        adc PlatPosDataLow,y    ;add or subtract pixels depending on offset
0B690 95 87                           sta Enemy_X_Position,x  ;store as new horizontal coordinate
0B692 B5 6E                           lda Enemy_PageLoc,x
0B694 79 87 B6                        adc PlatPosDataHigh,y   ;add or subtract page location depending on offset
0B697 95 6E                           sta Enemy_PageLoc,x     ;store as new page location
0B699 60                              rts                     ;and go back
0B69A                           
0B69A                           ;--------------------------------
0B69A                           
0B69A                           EndOfEnemyInitCode:
0B69A 60                              rts
0B69B                           
0B69B                           ;-------------------------------------------------------------------------------------
0B69B                           
0B69B                           RunEnemyObjectsCore:
0B69B A6 08                            ldx ObjectOffset  ;get offset for enemy object buffer
0B69D A9 00                            lda #$00          ;load value 0 for jump engine by default
0B69F B4 16                            ldy Enemy_ID,x
0B6A1 C0 15                            cpy #$15          ;if enemy object < $15, use default value
0B6A3 90 03                            bcc JmpEO
0B6A5 98                               tya               ;otherwise subtract $14 from the value and use
0B6A6 E9 14                            sbc #$14          ;as value for jump engine
0B6A8 20 F8 8C                  JmpEO: jsr JumpEngine
0B6AB                           
0B6AB F9 B6                           .dw RunNormalEnemies  ;for objects $00-$14
0B6AD                           
0B6AD 4E B7                           .dw RunBowserFlame    ;for objects $15-$1f
0B6AF B6 C0                           .dw RunFireworks
0B6B1 EF B6                           .dw NoRunCode
0B6B3 EF B6                           .dw NoRunCode
0B6B5 EF B6                           .dw NoRunCode
0B6B7 EF B6                           .dw NoRunCode
0B6B9 60 B7                           .dw RunFirebarObj
0B6BB 60 B7                           .dw RunFirebarObj
0B6BD 60 B7                           .dw RunFirebarObj
0B6BF 60 B7                           .dw RunFirebarObj
0B6C1 60 B7                           .dw RunFirebarObj
0B6C3                           
0B6C3 60 B7                           .dw RunFirebarObj     ;for objects $20-$2f
0B6C5 60 B7                           .dw RunFirebarObj
0B6C7 60 B7                           .dw RunFirebarObj
0B6C9 EF B6                           .dw NoRunCode
0B6CB 7E B7                           .dw RunLargePlatform
0B6CD 7E B7                           .dw RunLargePlatform
0B6CF 7E B7                           .dw RunLargePlatform
0B6D1 7E B7                           .dw RunLargePlatform
0B6D3 7E B7                           .dw RunLargePlatform
0B6D5 7E B7                           .dw RunLargePlatform
0B6D7 7E B7                           .dw RunLargePlatform
0B6D9 66 B7                           .dw RunSmallPlatform
0B6DB 66 B7                           .dw RunSmallPlatform
0B6DD 7E BE                           .dw RunBowser
0B6DF 8E A9                           .dw PowerUpObjHandler
0B6E1 2B A6                           .dw VineObjectHandler
0B6E3                           
0B6E3 EF B6                           .dw NoRunCode         ;for objects $30-$35
0B6E5 FA C0                           .dw RunStarFlagObj
0B6E7 7C A5                           .dw JumpspringHandler
0B6E9 EF B6                           .dw NoRunCode
0B6EB 5F A4                           .dw WarpZoneObject
0B6ED F0 B6                           .dw RunRetainerObj
0B6EF                           
0B6EF                           ;--------------------------------
0B6EF                           
0B6EF                           NoRunCode:
0B6EF 60                              rts
0B6F0                           
0B6F0                           ;--------------------------------
0B6F0                           
0B6F0                           RunRetainerObj:
0B6F0 20 BC E0                        jsr GetEnemyOffscreenBits
0B6F3 20 5F E0                        jsr RelativeEnemyPosition
0B6F6 4C 3E D7                        jmp EnemyGfxHandler
0B6F9                           
0B6F9                           ;--------------------------------
0B6F9                           
0B6F9                           RunNormalEnemies:
0B6F9 A9 00                               lda #$00                  ;init sprite attributes
0B6FB 9D C5 03                            sta Enemy_SprAttrib,x
0B6FE 20 BC E0                            jsr GetEnemyOffscreenBits
0B701 20 5F E0                            jsr RelativeEnemyPosition
0B704 20 3E D7                            jsr EnemyGfxHandler
0B707 20 FA D0                            jsr GetEnemyBoundBox
0B70A 20 63 CE                            jsr EnemyToBGCollisionDet
0B70D 20 A0 C8                            jsr EnemiesCollision
0B710 20 AF C6                            jsr PlayerEnemyCollision
0B713 AC 47 07                            ldy TimerControl          ;if master timer control set, skip to last routine
0B716 D0 03                               bne SkipMove
0B718 20 1E B7                            jsr EnemyMovementSubs
0B71B 4C B5 C4                  SkipMove: jmp OffscreenBoundsCheck
0B71E                           
0B71E                           EnemyMovementSubs:
0B71E B5 16                           lda Enemy_ID,x
0B720 20 F8 8C                        jsr JumpEngine
0B723                           
0B723 90 B8                           .dw MoveNormalEnemy      ;only objects $00-$14 use this table
0B725 90 B8                           .dw MoveNormalEnemy
0B727 90 B8                           .dw MoveNormalEnemy
0B729 90 B8                           .dw MoveNormalEnemy
0B72B 57 E6                           .dw MoveUpsideDownPiranhaP
0B72D F1 B7                           .dw ProcHammerBro
0B72F 90 B8                           .dw MoveNormalEnemy
0B731 A2 B9                           .dw MoveBloober
0B733 4F BA                           .dw MoveBulletBill
0B735 4D B7                           .dw NoMoveCode
0B737 63 BA                           .dw MoveSwimmingCheepCheep
0B739 63 BA                           .dw MoveSwimmingCheepCheep
0B73B C9 B7                           .dw MovePodoboo
0B73D C8 C1                           .dw MovePiranhaPlant
0B73F 12 B9                           .dw MoveJumpingEnemy
0B741 18 B9                           .dw ProcMoveRedPTroopa
0B743 3E B9                           .dw MoveFlyGreenPTroopa
0B745 41 BD                           .dw MoveLakitu
0B747 90 B8                           .dw MoveNormalEnemy
0B749 4D B7                           .dw NoMoveCode            ;dummy
0B74B F8 BC                           .dw MoveFlyingCheepCheep
0B74D                           
0B74D                           ;--------------------------------
0B74D                           
0B74D                           NoMoveCode:
0B74D 60                              rts
0B74E                           
0B74E                           ;--------------------------------
0B74E                           
0B74E                           RunBowserFlame:
0B74E 20 0C C0                        jsr ProcBowserFlame
0B751 20 BC E0                        jsr GetEnemyOffscreenBits
0B754 20 5F E0                        jsr RelativeEnemyPosition
0B757 20 FA D0                        jsr GetEnemyBoundBox
0B75A 20 AF C6                        jsr PlayerEnemyCollision
0B75D 4C B5 C4                        jmp OffscreenBoundsCheck
0B760                           
0B760                           ;--------------------------------
0B760                           
0B760                           RunFirebarObj:
0B760 20 55 BB                        jsr ProcFirebar
0B763 4C B5 C4                        jmp OffscreenBoundsCheck
0B766                           
0B766                           ;--------------------------------
0B766                           
0B766                           RunSmallPlatform:
0B766 20 BC E0                        jsr GetEnemyOffscreenBits
0B769 20 5F E0                        jsr RelativeEnemyPosition
0B76C 20 03 D1                        jsr SmallPlatformBoundBox
0B76F 20 F4 C9                        jsr SmallPlatformCollision
0B772 20 5F E0                        jsr RelativeEnemyPosition
0B775 20 69 DC                        jsr DrawSmallPlatform
0B778 20 90 C4                        jsr MoveSmallPlatform
0B77B 4C B5 C4                        jmp OffscreenBoundsCheck
0B77E                           
0B77E                           ;--------------------------------
0B77E                           
0B77E                           RunLargePlatform:
0B77E 20 BC E0                          jsr GetEnemyOffscreenBits
0B781 20 5F E0                          jsr RelativeEnemyPosition
0B784 20 2A D1                          jsr LargePlatformBoundBox
0B787 20 BE C9                          jsr LargePlatformCollision
0B78A AD 47 07                          lda TimerControl             ;if master timer control set,
0B78D D0 03                             bne SkipPT                   ;skip subroutine tree
0B78F 20 9B B7                          jsr LargePlatformSubroutines
0B792 20 5F E0                  SkipPT: jsr RelativeEnemyPosition
0B795 20 80 D4                          jsr DrawLargePlatform
0B798 4C B5 C4                          jmp OffscreenBoundsCheck
0B79B                           
0B79B                           ;--------------------------------
0B79B                           
0B79B                           LargePlatformSubroutines:
0B79B B5 16                           lda Enemy_ID,x  ;subtract $24 to get proper offset for jump table
0B79D 38                              sec
0B79E E9 24                           sbc #$24
0B7A0 20 F8 8C                        jsr JumpEngine
0B7A3                           
0B7A3 66 C2                           .dw BalancePlatform   ;table used by objects $24-$2a
0B7A5 0E C4                           .dw YMovingPlatform
0B7A7 8A C4                           .dw MoveLargeLiftPlat
0B7A9 8A C4                           .dw MoveLargeLiftPlat
0B7AB 42 C4                           .dw XMovingPlatform
0B7AD 6C C4                           .dw DropPlatform
0B7AF 78 C4                           .dw RightPlatform
0B7B1                           
0B7B1                           ;-------------------------------------------------------------------------------------
0B7B1                           
0B7B1                           EraseEnemyObject:
0B7B1 A9 00                           lda #$00                 ;clear all enemy object variables
0B7B3 95 0F                           sta Enemy_Flag,x
0B7B5 95 16                           sta Enemy_ID,x
0B7B7 95 1E                           sta Enemy_State,x
0B7B9 9D 10 01                        sta FloateyNum_Control,x
0B7BC 9D 96 07                        sta EnemyIntervalTimer,x
0B7BF 9D 25 01                        sta ShellChainCounter,x
0B7C2 9D C5 03                        sta Enemy_SprAttrib,x
0B7C5 9D 8A 07                        sta EnemyFrameTimer,x
0B7C8 60                              rts
0B7C9                           
0B7C9                           ;-------------------------------------------------------------------------------------
0B7C9                           
0B7C9                           MovePodoboo:
0B7C9 BD 96 07                        lda EnemyIntervalTimer,x   ;check enemy timer
0B7CC D0 16                           bne PdbM                   ;branch to move enemy if not expired
0B7CE 20 D7 B0                        jsr InitPodoboo            ;otherwise set up podoboo again
0B7D1 BD A8 07                        lda PseudoRandomBitReg+1,x ;get part of LSFR
0B7D4 09 80                           ora #%10000000             ;set d7
0B7D6 9D 34 04                        sta Enemy_Y_MoveForce,x    ;store as movement force
0B7D9 29 0F                           and #%00001111             ;mask out high nybble
0B7DB 09 06                           ora #$06                   ;set for at least six intervals
0B7DD 9D 96 07                        sta EnemyIntervalTimer,x   ;store as new enemy timer
0B7E0 A9 F9                           lda #$f9
0B7E2 95 A0                           sta Enemy_Y_Speed,x        ;set vertical speed to move podoboo upwards
0B7E4 4C B3 AC                  PdbM: jmp MoveJ_EnemyVertically  ;branch to impose gravity on podoboo
0B7E7                           
0B7E7                           ;--------------------------------
0B7E7                           ;$00 - used in HammerBroJumpCode as bitmask
0B7E7                           
0B7E7                           HammerThrowTmrData:
0B7E7 30 1C                           .db $30, $1c
0B7E9                           
0B7E9                           XSpeedAdderData:
0B7E9 00 E8 00 18                     .db $00, $e8, $00, $18
0B7ED                           
0B7ED                           RevivedXSpeed:
0B7ED 08 F8 0C F4                     .db $08, $f8, $0c, $f4
0B7F1                           
0B7F1                           ProcHammerBro:
0B7F1 B5 1E                            lda Enemy_State,x          ;check hammer bro's enemy state for d5 set
0B7F3 29 20                            and #%00100000
0B7F5 F0 03                            beq ChkJH                  ;if not set, go ahead with code
0B7F7 4C FE B8                         jmp MoveDefeatedEnemy      ;otherwise jump to something else
0B7FA B5 3C                     ChkJH: lda HammerBroJumpTimer,x   ;check jump timer
0B7FC F0 2D                            beq HammerBroJumpCode      ;if expired, branch to jump
0B7FE D6 3C                            dec HammerBroJumpTimer,x   ;otherwise decrement jump timer
0B800 AD D1 03                         lda Enemy_OffscreenBits
0B803 29 0C                            and #%00001100             ;check offscreen bits
0B805 D0 6A                            bne MoveHammerBroXDir      ;if hammer bro a little offscreen, skip to movement code
0B807 BD A2 03                         lda HammerThrowingTimer,x  ;check hammer throwing timer
0B80A D0 17                            bne DecHT                  ;if not expired, skip ahead, do not throw hammer
0B80C AC CC 06                         ldy SecondaryHardMode      ;otherwise get secondary hard mode flag
0B80F B9 E7 B7                         lda HammerThrowTmrData,y   ;get timer data using flag as offset
0B812 9D A2 03                         sta HammerThrowingTimer,x  ;set as new timer
0B815 20 B3 A7                         jsr SpawnHammerObj         ;do a sub here to spawn hammer object
0B818 90 09                            bcc DecHT                  ;if carry clear, hammer not spawned, skip to decrement timer
0B81A B5 1E                            lda Enemy_State,x
0B81C 09 08                            ora #%00001000             ;set d3 in enemy state for hammer throw
0B81E 95 1E                            sta Enemy_State,x
0B820 4C 71 B8                         jmp MoveHammerBroXDir      ;jump to move hammer bro
0B823 DE A2 03                  DecHT: dec HammerThrowingTimer,x  ;decrement timer
0B826 4C 71 B8                         jmp MoveHammerBroXDir      ;jump to move hammer bro
0B829                           
0B829                           HammerBroJumpLData:
0B829 20 37                           .db $20, $37
0B82B                           
0B82B                           HammerBroJumpCode:
0B82B B5 1E                            lda Enemy_State,x           ;get hammer bro's enemy state
0B82D 29 07                            and #%00000111              ;mask out all but 3 LSB
0B82F C9 01                            cmp #$01                    ;check for d0 set (for jumping)
0B831 F0 3E                            beq MoveHammerBroXDir       ;if set, branch ahead to moving code
0B833 A9 00                            lda #$00                    ;load default value here
0B835 85 00                            sta $00                     ;save into temp variable for now
0B837 A0 FA                            ldy #$fa                    ;set default vertical speed
0B839 B5 CF                            lda Enemy_Y_Position,x      ;check hammer bro's vertical coordinate
0B83B 30 13                            bmi SetHJ                   ;if on the bottom half of the screen, use current speed
0B83D A0 FD                            ldy #$fd                    ;otherwise set alternate vertical speed
0B83F C9 70                            cmp #$70                    ;check to see if hammer bro is above the middle of screen
0B841 E6 00                            inc $00                     ;increment preset value to $01
0B843 90 0B                            bcc SetHJ                   ;if above the middle of the screen, use current speed and $01
0B845 C6 00                            dec $00                     ;otherwise return value to $00
0B847 BD A8 07                         lda PseudoRandomBitReg+1,x  ;get part of LSFR, mask out all but LSB
0B84A 29 01                            and #$01
0B84C D0 02                            bne SetHJ                   ;if d0 of LSFR set, branch and use current speed and $00
0B84E A0 FA                            ldy #$fa                    ;otherwise reset to default vertical speed
0B850 94 A0                     SetHJ: sty Enemy_Y_Speed,x         ;set vertical speed for jumping
0B852 B5 1E                            lda Enemy_State,x           ;set d0 in enemy state for jumping
0B854 09 01                            ora #$01
0B856 95 1E                            sta Enemy_State,x
0B858 A5 00                            lda $00                     ;load preset value here to use as bitmask
0B85A 3D A9 07                         and PseudoRandomBitReg+2,x  ;and do bit-wise comparison with part of LSFR
0B85D A8                               tay                         ;then use as offset
0B85E AD CC 06                         lda SecondaryHardMode       ;check secondary hard mode flag
0B861 D0 01                            bne HJump
0B863 A8                               tay                         ;if secondary hard mode flag clear, set offset to 0
0B864 B9 29 B8                  HJump: lda HammerBroJumpLData,y    ;get jump length timer data using offset from before
0B867 9D 8A 07                         sta EnemyFrameTimer,x       ;save in enemy timer
0B86A BD A8 07                         lda PseudoRandomBitReg+1,x
0B86D 09 C0                            ora #%11000000              ;get contents of part of LSFR, set d7 and d6, then
0B86F 95 3C                            sta HammerBroJumpTimer,x    ;store in jump timer
0B871                           
0B871                           MoveHammerBroXDir:
0B871 A0 FC                              ldy #$fc                  ;move hammer bro a little to the left
0B873 A5 09                              lda FrameCounter
0B875 29 40                              and #%01000000            ;change hammer bro's direction every 64 frames
0B877 D0 02                              bne Shimmy
0B879 A0 04                              ldy #$04                  ;if d6 set in counter, move him a little to the right
0B87B 94 58                     Shimmy:  sty Enemy_X_Speed,x       ;store horizontal speed
0B87D A0 01                              ldy #$01                  ;set to face right by default
0B87F 20 F2 CF                           jsr PlayerEnemyDiff       ;get horizontal difference between player and hammer bro
0B882 30 0A                              bmi SetShim               ;if enemy to the left of player, skip this part
0B884 C8                                 iny                       ;set to face left
0B885 BD 96 07                           lda EnemyIntervalTimer,x  ;check walking timer
0B888 D0 04                              bne SetShim               ;if not yet expired, skip to set moving direction
0B88A A9 F8                              lda #$f8
0B88C 95 58                              sta Enemy_X_Speed,x       ;otherwise, make the hammer bro walk left towards player
0B88E 94 46                     SetShim: sty Enemy_MovingDir,x     ;set moving direction
0B890                           
0B890                           MoveNormalEnemy:
0B890 A0 00                            ldy #$00                   ;init Y to leave horizontal movement as-is 
0B892 B5 1E                            lda Enemy_State,x
0B894 29 40                            and #%01000000             ;check enemy state for d6 set, if set skip
0B896 D0 19                            bne FallE                  ;to move enemy vertically, then horizontally if necessary
0B898 B5 1E                            lda Enemy_State,x
0B89A 0A                               asl                        ;check enemy state for d7 set
0B89B B0 30                            bcs SteadM                 ;if set, branch to move enemy horizontally
0B89D B5 1E                            lda Enemy_State,x
0B89F 29 20                            and #%00100000             ;check enemy state for d5 set
0B8A1 D0 5B                            bne MoveDefeatedEnemy      ;if set, branch to move defeated enemy object
0B8A3 B5 1E                            lda Enemy_State,x
0B8A5 29 07                            and #%00000111             ;check d2-d0 of enemy state for any set bits
0B8A7 F0 24                            beq SteadM                 ;if enemy in normal state, branch to move enemy horizontally
0B8A9 C9 05                            cmp #$05
0B8AB F0 04                            beq FallE                  ;if enemy in state used by spiny's egg, go ahead here
0B8AD C9 03                            cmp #$03
0B8AF B0 30                            bcs ReviveStunned          ;if enemy in states $03 or $04, skip ahead to yet another part
0B8B1 20 84 AC                  FallE: jsr MoveD_EnemyVertically  ;do a sub here to move enemy downwards
0B8B4 A0 00                            ldy #$00
0B8B6 B5 1E                            lda Enemy_State,x          ;check for enemy state $02
0B8B8 C9 02                            cmp #$02
0B8BA F0 0C                            beq MEHor                  ;if found, branch to move enemy horizontally
0B8BC 29 40                            and #%01000000             ;check for d6 set
0B8BE F0 0D                            beq SteadM                 ;if not set, branch to something else
0B8C0 B5 16                            lda Enemy_ID,x
0B8C2 C9 2E                            cmp #PowerUpObject         ;check for power-up object
0B8C4 F0 07                            beq SteadM
0B8C6 D0 03                            bne SlowM                  ;if any other object where d6 set, jump to set Y
0B8C8 4C 23 AC                  MEHor: jmp MoveEnemyHorizontally  ;jump here to move enemy horizontally for <> $2e and d6 set
0B8CB                           
0B8CB A0 01                     SlowM:  ldy #$01                  ;if branched here, increment Y to slow horizontal movement
0B8CD B5 58                     SteadM: lda Enemy_X_Speed,x       ;get current horizontal speed
0B8CF 48                                pha                       ;save to stack
0B8D0 10 02                             bpl AddHS                 ;if not moving or moving right, skip, leave Y alone
0B8D2 C8                                iny
0B8D3 C8                                iny                       ;otherwise increment Y to next data
0B8D4 18                        AddHS:  clc
0B8D5 79 E9 B7                          adc XSpeedAdderData,y     ;add value here to slow enemy down if necessary
0B8D8 95 58                             sta Enemy_X_Speed,x       ;save as horizontal speed temporarily
0B8DA 20 23 AC                          jsr MoveEnemyHorizontally ;then do a sub to move horizontally
0B8DD 68                                pla
0B8DE 95 58                             sta Enemy_X_Speed,x       ;get old horizontal speed from stack and return to
0B8E0 60                                rts                       ;original memory location, then leave
0B8E1                           
0B8E1                           ReviveStunned:
0B8E1 BD 96 07                           lda EnemyIntervalTimer,x  ;if enemy timer not expired yet,
0B8E4 D0 1E                              bne ChkKillGoomba         ;skip ahead to something else
0B8E6 95 1E                              sta Enemy_State,x         ;otherwise initialize enemy state to normal
0B8E8 A5 09                              lda FrameCounter
0B8EA 29 01                              and #$01                  ;get d0 of frame counter
0B8EC A8                                 tay                       ;use as Y and increment for movement direction
0B8ED C8                                 iny
0B8EE 94 46                              sty Enemy_MovingDir,x     ;store as pseudorandom movement direction
0B8F0 88                                 dey                       ;decrement for use as pointer
0B8F1 AD 6A 07                           lda PrimaryHardMode       ;check primary hard mode flag
0B8F4 F0 02                              beq SetRSpd               ;if not set, use pointer as-is
0B8F6 C8                                 iny
0B8F7 C8                                 iny                       ;otherwise increment 2 bytes to next data
0B8F8 B9 ED B7                  SetRSpd: lda RevivedXSpeed,y       ;load and store new horizontal speed
0B8FB 95 58                              sta Enemy_X_Speed,x       ;and leave
0B8FD 60                                 rts
0B8FE                           
0B8FE                           MoveDefeatedEnemy:
0B8FE 20 84 AC                        jsr MoveD_EnemyVertically      ;execute sub to move defeated enemy downwards
0B901 4C 23 AC                        jmp MoveEnemyHorizontally      ;now move defeated enemy horizontally
0B904                           
0B904                           ChkKillGoomba:
0B904 C9 0E                             cmp #$0e              ;check to see if enemy timer has reached
0B906 D0 09                             bne NKGmba            ;a certain point, and branch to leave if not
0B908 B5 16                             lda Enemy_ID,x
0B90A C9 06                             cmp #Goomba           ;check for goomba object
0B90C D0 03                             bne NKGmba            ;branch if not found
0B90E 20 B1 B7                          jsr EraseEnemyObject  ;otherwise, kill this goomba object
0B911 60                        NKGmba: rts                   ;leave!
0B912                           
0B912                           ;--------------------------------
0B912                           
0B912                           MoveJumpingEnemy:
0B912 20 B3 AC                        jsr MoveJ_EnemyVertically  ;do a sub to impose gravity on green paratroopa
0B915 4C 23 AC                        jmp MoveEnemyHorizontally  ;jump to move enemy horizontally
0B918                           
0B918                           ;--------------------------------
0B918                           
0B918                           ProcMoveRedPTroopa:
0B918 B5 A0                               lda Enemy_Y_Speed,x
0B91A 1D 34 04                            ora Enemy_Y_MoveForce,x     ;check for any vertical force or speed
0B91D D0 13                               bne MoveRedPTUpOrDown       ;branch if any found
0B91F 9D 17 04                            sta Enemy_YMF_Dummy,x       ;initialize something here
0B922 B5 CF                               lda Enemy_Y_Position,x      ;check current vs. original vertical coordinate
0B924 DD 01 04                            cmp RedPTroopaOrigXPos,x
0B927 B0 09                               bcs MoveRedPTUpOrDown       ;if current => original, skip ahead to more code
0B929 A5 09                               lda FrameCounter            ;get frame counter
0B92B 29 07                               and #%00000111              ;mask out all but 3 LSB
0B92D D0 02                               bne NoIncPT                 ;if any bits set, branch to leave
0B92F F6 CF                               inc Enemy_Y_Position,x      ;otherwise increment red paratroopa's vertical position
0B931 60                        NoIncPT:  rts                         ;leave
0B932                           
0B932                           MoveRedPTUpOrDown:
0B932 B5 CF                               lda Enemy_Y_Position,x      ;check current vs. central vertical coordinate
0B934 D5 58                               cmp RedPTroopaCenterYPos,x
0B936 90 03                               bcc MovPTDwn                ;if current < central, jump to move downwards
0B938 4C 96 AC                            jmp MoveRedPTroopaUp        ;otherwise jump to move upwards
0B93B 4C 91 AC                  MovPTDwn: jmp MoveRedPTroopaDown      ;move downwards
0B93E                           
0B93E                           ;--------------------------------
0B93E                           ;$00 - used to store adder for movement, also used as adder for platform
0B93E                           ;$01 - used to store maximum value for secondary counter
0B93E                           
0B93E                           MoveFlyGreenPTroopa:
0B93E 20 5E B9                          jsr XMoveCntr_GreenPTroopa ;do sub to increment primary and secondary counters
0B941 20 7F B9                          jsr MoveWithXMCntrs        ;do sub to move green paratroopa accordingly, and horizontally
0B944 A0 01                             ldy #$01                   ;set Y to move green paratroopa down
0B946 A5 09                             lda FrameCounter
0B948 29 03                             and #%00000011             ;check frame counter 2 LSB for any bits set
0B94A D0 11                             bne NoMGPT                 ;branch to leave if set to move up/down every fourth frame
0B94C A5 09                             lda FrameCounter
0B94E 29 40                             and #%01000000             ;check frame counter for d6 set
0B950 D0 02                             bne YSway                  ;branch to move green paratroopa down if set
0B952 A0 FF                             ldy #$ff                   ;otherwise set Y to move green paratroopa up
0B954 84 00                     YSway:  sty $00                    ;store adder here
0B956 B5 CF                             lda Enemy_Y_Position,x
0B958 18                                clc                        ;add or subtract from vertical position
0B959 65 00                             adc $00                    ;to give green paratroopa a wavy flight
0B95B 95 CF                             sta Enemy_Y_Position,x
0B95D 60                        NoMGPT: rts                        ;leave!
0B95E                           
0B95E                           XMoveCntr_GreenPTroopa:
0B95E A9 13                              lda #$13                    ;load preset maximum value for secondary counter
0B960                           
0B960                           XMoveCntr_Platform:
0B960 85 01                              sta $01                     ;store value here
0B962 A5 09                              lda FrameCounter
0B964 29 03                              and #%00000011              ;branch to leave if not on
0B966 D0 0D                              bne NoIncXM                 ;every fourth frame
0B968 B4 58                              ldy XMoveSecondaryCounter,x ;get secondary counter
0B96A B5 A0                              lda XMovePrimaryCounter,x   ;get primary counter
0B96C 4A                                 lsr
0B96D B0 0A                              bcs DecSeXM                 ;if d0 of primary counter set, branch elsewhere
0B96F C4 01                              cpy $01                     ;compare secondary counter to preset maximum value
0B971 F0 03                              beq IncPXM                  ;if equal, branch ahead of this part
0B973 F6 58                              inc XMoveSecondaryCounter,x ;increment secondary counter and leave
0B975 60                        NoIncXM: rts
0B976 F6 A0                     IncPXM:  inc XMovePrimaryCounter,x   ;increment primary counter and leave
0B978 60                                 rts
0B979 98                        DecSeXM: tya                         ;put secondary counter in A
0B97A F0 FA                              beq IncPXM                  ;if secondary counter at zero, branch back
0B97C D6 58                              dec XMoveSecondaryCounter,x ;otherwise decrement secondary counter and leave
0B97E 60                                 rts
0B97F                           
0B97F                           MoveWithXMCntrs:
0B97F B5 58                              lda XMoveSecondaryCounter,x  ;save secondary counter to stack
0B981 48                                 pha
0B982 A0 01                              ldy #$01                     ;set value here by default
0B984 B5 A0                              lda XMovePrimaryCounter,x
0B986 29 02                              and #%00000010               ;if d1 of primary counter is
0B988 D0 0B                              bne XMRight                  ;set, branch ahead of this part here
0B98A B5 58                              lda XMoveSecondaryCounter,x
0B98C 49 FF                              eor #$ff                     ;otherwise change secondary
0B98E 18                                 clc                          ;counter to two's compliment
0B98F 69 01                              adc #$01
0B991 95 58                              sta XMoveSecondaryCounter,x
0B993 A0 02                              ldy #$02                     ;load alternate value here
0B995 94 46                     XMRight: sty Enemy_MovingDir,x        ;store as moving direction
0B997 20 23 AC                           jsr MoveEnemyHorizontally
0B99A 85 00                              sta $00                      ;save value obtained from sub here
0B99C 68                                 pla                          ;get secondary counter from stack
0B99D 95 58                              sta XMoveSecondaryCounter,x  ;and return to original place
0B99F 60                                 rts
0B9A0                           
0B9A0                           ;--------------------------------
0B9A0                           
0B9A0                           
0B9A0                           BlooberBitmasks:
0B9A0 3F 03                           .db %00111111, %00000011
0B9A2                           
0B9A2                           MoveBloober:
0B9A2 B5 1E                             lda Enemy_State,x
0B9A4 29 20                             and #%00100000             ;check enemy state for d5 set
0B9A6 D0 4D                             bne MoveDefeatedBloober    ;branch if set to move defeated bloober
0B9A8 AC CC 06                          ldy SecondaryHardMode      ;use secondary hard mode flag as offset
0B9AB BD A8 07                          lda PseudoRandomBitReg+1,x ;get LSFR
0B9AE 39 A0 B9                          and BlooberBitmasks,y      ;mask out bits in LSFR using bitmask loaded with offset
0B9B1 D0 12                             bne BlooberSwim            ;if any bits set, skip ahead to make swim
0B9B3 8A                                txa
0B9B4 4A                                lsr                        ;check to see if on second or fourth slot (1 or 3)
0B9B5 90 04                             bcc FBLeft                 ;if not, branch to figure out moving direction
0B9B7 A4 45                             ldy Player_MovingDir       ;otherwise, load player's moving direction and
0B9B9 B0 08                             bcs SBMDir                 ;do an unconditional branch to set
0B9BB A0 02                     FBLeft: ldy #$02                   ;set left moving direction by default
0B9BD 20 F2 CF                          jsr PlayerEnemyDiff        ;get horizontal difference between player and bloober
0B9C0 10 01                             bpl SBMDir                 ;if enemy to the right of player, keep left
0B9C2 88                                dey                        ;otherwise decrement to set right moving direction
0B9C3 94 46                     SBMDir: sty Enemy_MovingDir,x      ;set moving direction of bloober, then continue on here
0B9C5                           
0B9C5                           BlooberSwim:
0B9C5 20 F8 B9                         jsr ProcSwimmingB        ;execute sub to make bloober swim characteristically
0B9C8 B5 CF                            lda Enemy_Y_Position,x   ;get vertical coordinate
0B9CA 38                               sec
0B9CB FD 34 04                         sbc Enemy_Y_MoveForce,x  ;subtract movement force
0B9CE C9 20                            cmp #$20                 ;check to see if position is above edge of status bar
0B9D0 90 02                            bcc SwimX                ;if so, don't do it
0B9D2 95 CF                            sta Enemy_Y_Position,x   ;otherwise, set new vertical position, make bloober swim
0B9D4 B4 46                     SwimX: ldy Enemy_MovingDir,x    ;check moving direction
0B9D6 88                               dey
0B9D7 D0 0E                            bne LeftSwim             ;if moving to the left, branch to second part
0B9D9 B5 87                            lda Enemy_X_Position,x
0B9DB 18                               clc                      ;add movement speed to horizontal coordinate
0B9DC 75 58                            adc BlooperMoveSpeed,x
0B9DE 95 87                            sta Enemy_X_Position,x   ;store result as new horizontal coordinate
0B9E0 B5 6E                            lda Enemy_PageLoc,x
0B9E2 69 00                            adc #$00                 ;add carry to page location
0B9E4 95 6E                            sta Enemy_PageLoc,x      ;store as new page location and leave
0B9E6 60                               rts
0B9E7                           
0B9E7                           LeftSwim:
0B9E7 B5 87                           lda Enemy_X_Position,x
0B9E9 38                              sec                      ;subtract movement speed from horizontal coordinate
0B9EA F5 58                           sbc BlooperMoveSpeed,x
0B9EC 95 87                           sta Enemy_X_Position,x   ;store result as new horizontal coordinate
0B9EE B5 6E                           lda Enemy_PageLoc,x
0B9F0 E9 00                           sbc #$00                 ;subtract borrow from page location
0B9F2 95 6E                           sta Enemy_PageLoc,x      ;store as new page location and leave
0B9F4 60                              rts
0B9F5                           
0B9F5                           MoveDefeatedBloober:
0B9F5 4C AD AC                        jmp MoveEnemySlowVert    ;jump to move defeated bloober downwards
0B9F8                           
0B9F8                           ProcSwimmingB:
0B9F8 B5 A0                             lda BlooperMoveCounter,x  ;get enemy's movement counter
0B9FA 29 02                             and #%00000010            ;check for d1 set
0B9FC D0 37                             bne ChkForFloatdown       ;branch if set
0B9FE A5 09                             lda FrameCounter
0BA00 29 07                             and #%00000111            ;get 3 LSB of frame counter
0BA02 48                                pha                       ;and save it to the stack
0BA03 B5 A0                             lda BlooperMoveCounter,x  ;get enemy's movement counter
0BA05 4A                                lsr                       ;check for d0 set
0BA06 B0 15                             bcs SlowSwim              ;branch if set
0BA08 68                                pla                       ;pull 3 LSB of frame counter from the stack
0BA09 D0 11                             bne BSwimE                ;branch to leave, execute code only every eighth frame
0BA0B BD 34 04                          lda Enemy_Y_MoveForce,x
0BA0E 18                                clc                       ;add to movement force to speed up swim
0BA0F 69 01                             adc #$01
0BA11 9D 34 04                          sta Enemy_Y_MoveForce,x   ;set movement force
0BA14 95 58                             sta BlooperMoveSpeed,x    ;set as movement speed
0BA16 C9 02                             cmp #$02
0BA18 D0 02                             bne BSwimE                ;if certain horizontal speed, branch to leave
0BA1A F6 A0                             inc BlooperMoveCounter,x  ;otherwise increment movement counter
0BA1C 60                        BSwimE: rts
0BA1D                           
0BA1D                           SlowSwim:
0BA1D 68                               pla                      ;pull 3 LSB of frame counter from the stack
0BA1E D0 14                            bne NoSSw                ;branch to leave, execute code only every eighth frame
0BA20 BD 34 04                         lda Enemy_Y_MoveForce,x
0BA23 38                               sec                      ;subtract from movement force to slow swim
0BA24 E9 01                            sbc #$01
0BA26 9D 34 04                         sta Enemy_Y_MoveForce,x  ;set movement force
0BA29 95 58                            sta BlooperMoveSpeed,x   ;set as movement speed
0BA2B D0 07                            bne NoSSw                ;if any speed, branch to leave
0BA2D F6 A0                            inc BlooperMoveCounter,x ;otherwise increment movement counter
0BA2F A9 02                            lda #$02
0BA31 9D 96 07                         sta EnemyIntervalTimer,x ;set enemy's timer
0BA34 60                        NoSSw: rts                      ;leave
0BA35                           
0BA35                           ChkForFloatdown:
0BA35 BD 96 07                        lda EnemyIntervalTimer,x ;get enemy timer
0BA38 F0 08                           beq ChkNearPlayer        ;branch if expired
0BA3A                           
0BA3A                           Floatdown:
0BA3A A5 09                           lda FrameCounter        ;get frame counter
0BA3C 4A                              lsr                     ;check for d0 set
0BA3D B0 02                           bcs NoFD                ;branch to leave on every other frame
0BA3F F6 CF                           inc Enemy_Y_Position,x  ;otherwise increment vertical coordinate
0BA41 60                        NoFD: rts                     ;leave
0BA42                           
0BA42                           ChkNearPlayer:
0BA42 B5 CF                           lda Enemy_Y_Position,x    ;get vertical coordinate
0BA44 69 10                           adc #$10                  ;add sixteen pixels
0BA46 C5 CE                           cmp Player_Y_Position     ;compare result with player's vertical coordinate
0BA48 90 F0                           bcc Floatdown             ;if modified vertical less than player's, branch
0BA4A A9 00                           lda #$00
0BA4C 95 A0                           sta BlooperMoveCounter,x  ;otherwise nullify movement counter
0BA4E 60                              rts
0BA4F                           
0BA4F                           ;--------------------------------
0BA4F                           
0BA4F                           MoveBulletBill:
0BA4F B5 1E                              lda Enemy_State,x          ;check bullet bill's enemy object state for d5 set
0BA51 29 20                              and #%00100000
0BA53 F0 03                              beq NotDefB                ;if not set, continue with movement code
0BA55 4C B3 AC                           jmp MoveJ_EnemyVertically  ;otherwise jump to move defeated bullet bill downwards
0BA58 A9 E8                     NotDefB: lda #$e8                   ;set bullet bill's horizontal speed
0BA5A 95 58                              sta Enemy_X_Speed,x        ;and move it accordingly (note: this bullet bill
0BA5C 4C 23 AC                           jmp MoveEnemyHorizontally  ;object occurs in frenzy object $17, not from cannons)
0BA5F                           
0BA5F                           ;--------------------------------
0BA5F                           ;$02 - used to hold preset values
0BA5F                           ;$03 - used to hold enemy state
0BA5F                           
0BA5F                           SwimCCXMoveData:
0BA5F 40 80                           .db $40, $80
0BA61 04 04                           .db $04, $04 ;residual data, not used
0BA63                           
0BA63                           MoveSwimmingCheepCheep:
0BA63 B5 1E                             lda Enemy_State,x         ;check cheep-cheep's enemy object state
0BA65 29 20                             and #%00100000            ;for d5 set
0BA67 F0 03                             beq CCSwim                ;if not set, continue with movement code
0BA69 4C AD AC                          jmp MoveEnemySlowVert     ;otherwise jump to move defeated cheep-cheep downwards
0BA6C 85 03                     CCSwim: sta $03                   ;save enemy state in $03
0BA6E B5 16                             lda Enemy_ID,x            ;get enemy identifier
0BA70 38                                sec
0BA71 E9 0A                             sbc #$0a                  ;subtract ten for cheep-cheep identifiers
0BA73 A8                                tay                       ;use as offset
0BA74 B9 5F BA                          lda SwimCCXMoveData,y     ;load value here
0BA77 85 02                             sta $02
0BA79 BD 01 04                          lda Enemy_X_MoveForce,x   ;load horizontal force
0BA7C 38                                sec
0BA7D E5 02                             sbc $02                   ;subtract preset value from horizontal force
0BA7F 9D 01 04                          sta Enemy_X_MoveForce,x   ;store as new horizontal force
0BA82 B5 87                             lda Enemy_X_Position,x    ;get horizontal coordinate
0BA84 E9 00                             sbc #$00                  ;subtract borrow (thus moving it slowly)
0BA86 95 87                             sta Enemy_X_Position,x    ;and save as new horizontal coordinate
0BA88 B5 6E                             lda Enemy_PageLoc,x
0BA8A E9 00                             sbc #$00                  ;subtract borrow again, this time from the
0BA8C 95 6E                             sta Enemy_PageLoc,x       ;page location, then save
0BA8E A9 40                             lda #$40
0BA90 85 02                             sta $02                   ;save new value here
0BA92 E0 02                             cpx #$02                  ;check enemy object offset
0BA94 90 49                             bcc ExSwCC                ;if in first or second slot, branch to leave
0BA96 B5 58                             lda CheepCheepMoveMFlag,x ;check movement flag
0BA98 C9 10                             cmp #$10                  ;if movement speed set to $00,
0BA9A 90 16                             bcc CCSwimUpwards         ;branch to move upwards
0BA9C BD 17 04                          lda Enemy_YMF_Dummy,x
0BA9F 18                                clc
0BAA0 65 02                             adc $02                   ;add preset value to dummy variable to get carry
0BAA2 9D 17 04                          sta Enemy_YMF_Dummy,x     ;and save dummy
0BAA5 B5 CF                             lda Enemy_Y_Position,x    ;get vertical coordinate
0BAA7 65 03                             adc $03                   ;add carry to it plus enemy state to slowly move it downwards
0BAA9 95 CF                             sta Enemy_Y_Position,x    ;save as new vertical coordinate
0BAAB B5 B6                             lda Enemy_Y_HighPos,x
0BAAD 69 00                             adc #$00                  ;add carry to page location and
0BAAF 4C C5 BA                          jmp ChkSwimYPos           ;jump to end of movement code
0BAB2                           
0BAB2                           CCSwimUpwards:
0BAB2 BD 17 04                          lda Enemy_YMF_Dummy,x
0BAB5 38                                sec
0BAB6 E5 02                             sbc $02                   ;subtract preset value to dummy variable to get borrow
0BAB8 9D 17 04                          sta Enemy_YMF_Dummy,x     ;and save dummy
0BABB B5 CF                             lda Enemy_Y_Position,x    ;get vertical coordinate
0BABD E5 03                             sbc $03                   ;subtract borrow to it plus enemy state to slowly move it upwards
0BABF 95 CF                             sta Enemy_Y_Position,x    ;save as new vertical coordinate
0BAC1 B5 B6                             lda Enemy_Y_HighPos,x
0BAC3 E9 00                             sbc #$00                  ;subtract borrow from page location
0BAC5                           
0BAC5                           ChkSwimYPos:
0BAC5 95 B6                             sta Enemy_Y_HighPos,x     ;save new page location here
0BAC7 A0 00                             ldy #$00                  ;load movement speed to upwards by default
0BAC9 B5 CF                             lda Enemy_Y_Position,x    ;get vertical coordinate
0BACB 38                                sec
0BACC FD 34 04                          sbc CheepCheepOrigYPos,x  ;subtract original coordinate from current
0BACF 10 07                             bpl YPDiff                ;if result positive, skip to next part
0BAD1 A0 10                             ldy #$10                  ;otherwise load movement speed to downwards
0BAD3 49 FF                             eor #$ff
0BAD5 18                                clc                       ;get two's compliment of result
0BAD6 69 01                             adc #$01                  ;to obtain total difference of original vs. current
0BAD8 C9 0F                     YPDiff: cmp #$0f                  ;if difference between original vs. current vertical
0BADA 90 03                             bcc ExSwCC                ;coordinates < 15 pixels, leave movement speed alone
0BADC 98                                tya
0BADD 95 58                             sta CheepCheepMoveMFlag,x ;otherwise change movement speed
0BADF 60                        ExSwCC: rts                       ;leave
0BAE0                           
0BAE0                           ;--------------------------------
0BAE0                           ;$00 - used as counter for firebar parts
0BAE0                           ;$01 - used for oscillated high byte of spin state or to hold horizontal adder
0BAE0                           ;$02 - used for oscillated high byte of spin state or to hold vertical adder
0BAE0                           ;$03 - used for mirror data
0BAE0                           ;$04 - used to store player's sprite 1 X coordinate
0BAE0                           ;$05 - used to evaluate mirror data
0BAE0                           ;$06 - used to store either screen X coordinate or sprite data offset
0BAE0                           ;$07 - used to store screen Y coordinate
0BAE0                           ;$ed - used to hold maximum length of firebar
0BAE0                           ;$ef - used to hold high byte of spinstate
0BAE0                           
0BAE0                           ;horizontal adder is at first byte + high byte of spinstate,
0BAE0                           ;vertical adder is same + 8 bytes, two's compliment
0BAE0                           ;if greater than $08 for proper oscillation
0BAE0                           FirebarPosLookupTbl:
0BAE0 00 01 03 04 05 06 07 07..       .db $00, $01, $03, $04, $05, $06, $07, $07, $08
0BAE9 00 03 06 09 0B 0D 0E 0F..       .db $00, $03, $06, $09, $0b, $0d, $0e, $0f, $10
0BAF2 00 04 09 0D 10 13 16 17..       .db $00, $04, $09, $0d, $10, $13, $16, $17, $18
0BAFB 00 06 0C 12 16 1A 1D 1F..       .db $00, $06, $0c, $12, $16, $1a, $1d, $1f, $20
0BB04 00 07 0F 16 1C 21 25 27..       .db $00, $07, $0f, $16, $1c, $21, $25, $27, $28
0BB0D 00 09 12 1B 21 27 2C 2F..       .db $00, $09, $12, $1b, $21, $27, $2c, $2f, $30
0BB16 00 0B 15 1F 27 2E 33 37..       .db $00, $0b, $15, $1f, $27, $2e, $33, $37, $38
0BB1F 00 0C 18 24 2D 35 3B 3E..       .db $00, $0c, $18, $24, $2d, $35, $3b, $3e, $40
0BB28 00 0E 1B 28 32 3B 42 46..       .db $00, $0e, $1b, $28, $32, $3b, $42, $46, $48
0BB31 00 0F 1F 2D 38 42 4A 4E..       .db $00, $0f, $1f, $2d, $38, $42, $4a, $4e, $50
0BB3A 00 11 22 31 3E 49 51 56..       .db $00, $11, $22, $31, $3e, $49, $51, $56, $58
0BB43                           
0BB43                           FirebarMirrorData:
0BB43 01 03 02 00                     .db $01, $03, $02, $00
0BB47                           
0BB47                           FirebarTblOffsets:
0BB47 00 09 12 1B 24 2D               .db $00, $09, $12, $1b, $24, $2d
0BB4D 36 3F 48 51 5A 63               .db $36, $3f, $48, $51, $5a, $63
0BB53                           
0BB53                           FirebarYPos:
0BB53 0C 18                           .db $0c, $18
0BB55                           
0BB55                           ProcFirebar:
0BB55 20 BC E0                            jsr GetEnemyOffscreenBits   ;get offscreen information
0BB58 AD D1 03                            lda Enemy_OffscreenBits     ;check for d3 set
0BB5B 29 08                               and #%00001000              ;if so, branch to leave
0BB5D D0 74                               bne SkipFBar
0BB5F AD 47 07                            lda TimerControl            ;if master timer control set, branch
0BB62 D0 0A                               bne SusFbar                 ;ahead of this part
0BB64 BD 88 03                            lda FirebarSpinSpeed,x      ;load spinning speed of firebar
0BB67 20 44 C2                            jsr FirebarSpin             ;modify current spinstate
0BB6A 29 1F                               and #%00011111              ;mask out all but 5 LSB
0BB6C 95 A0                               sta FirebarSpinState_High,x ;and store as new high byte of spinstate
0BB6E B5 A0                     SusFbar:  lda FirebarSpinState_High,x ;get high byte of spinstate
0BB70 B4 16                               ldy Enemy_ID,x              ;check enemy identifier
0BB72 C0 1F                               cpy #$1f
0BB74 90 0D                               bcc SetupGFB                ;if < $1f (long firebar), branch
0BB76 C9 08                               cmp #$08                    ;check high byte of spinstate
0BB78 F0 04                               beq SkpFSte                 ;if eight, branch to change
0BB7A C9 18                               cmp #$18
0BB7C D0 05                               bne SetupGFB                ;if not at twenty-four branch to not change
0BB7E 18                        SkpFSte:  clc
0BB7F 69 01                               adc #$01                    ;add one to spinning thing to avoid horizontal state
0BB81 95 A0                               sta FirebarSpinState_High,x
0BB83 85 EF                     SetupGFB: sta $ef                     ;save high byte of spinning thing, modified or otherwise
0BB85 20 5F E0                            jsr RelativeEnemyPosition   ;get relative coordinates to screen
0BB88 20 A7 BC                            jsr GetFirebarPosition      ;do a sub here (residual, too early to be used now)
0BB8B BC E5 06                            ldy Enemy_SprDataOffset,x   ;get OAM data offset
0BB8E AD B9 03                            lda Enemy_Rel_YPos          ;get relative vertical coordinate
0BB91 99 00 02                            sta Sprite_Y_Position,y     ;store as Y in OAM data
0BB94 85 07                               sta $07                     ;also save here
0BB96 AD AE 03                            lda Enemy_Rel_XPos          ;get relative horizontal coordinate
0BB99 99 03 02                            sta Sprite_X_Position,y     ;store as X in OAM data
0BB9C 85 06                               sta $06                     ;also save here
0BB9E A9 01                               lda #$01
0BBA0 85 00                               sta $00                     ;set $01 value here (not necessary)
0BBA2 20 21 BC                            jsr FirebarCollision        ;draw fireball part and do collision detection
0BBA5 A0 05                               ldy #$05                    ;load value for short firebars by default
0BBA7 B5 16                               lda Enemy_ID,x
0BBA9 C9 1F                               cmp #$1f                    ;are we doing a long firebar?
0BBAB 90 02                               bcc SetMFbar                ;no, branch then
0BBAD A0 0B                               ldy #$0b                    ;otherwise load value for long firebars
0BBAF 84 ED                     SetMFbar: sty $ed                     ;store maximum value for length of firebars
0BBB1 A9 00                               lda #$00
0BBB3 85 00                               sta $00                     ;initialize counter here
0BBB5 A5 EF                     DrawFbar: lda $ef                     ;load high byte of spinstate
0BBB7 20 A7 BC                            jsr GetFirebarPosition      ;get fireball position data depending on firebar part
0BBBA 20 D4 BB                            jsr DrawFirebar_Collision   ;position it properly, draw it and do collision detection
0BBBD A5 00                               lda $00                     ;check which firebar part
0BBBF C9 04                               cmp #$04
0BBC1 D0 08                               bne NextFbar
0BBC3 AC CF 06                            ldy DuplicateObj_Offset     ;if we arrive at fifth firebar part,
0BBC6 B9 E5 06                            lda Enemy_SprDataOffset,y   ;get offset from long firebar and load OAM data offset
0BBC9 85 06                               sta $06                     ;using long firebar offset, then store as new one here
0BBCB E6 00                     NextFbar: inc $00                     ;move onto the next firebar part
0BBCD A5 00                               lda $00
0BBCF C5 ED                               cmp $ed                     ;if we end up at the maximum part, go on and leave
0BBD1 90 E2                               bcc DrawFbar                ;otherwise go back and do another
0BBD3 60                        SkipFBar: rts
0BBD4                           
0BBD4                           DrawFirebar_Collision:
0BBD4 A5 03                              lda $03                  ;store mirror data elsewhere
0BBD6 85 05                              sta $05          
0BBD8 A4 06                              ldy $06                  ;load OAM data offset for firebar
0BBDA A5 01                              lda $01                  ;load horizontal adder we got from position loader
0BBDC 46 05                              lsr $05                  ;shift LSB of mirror data
0BBDE B0 04                              bcs AddHA                ;if carry was set, skip this part
0BBE0 49 FF                              eor #$ff
0BBE2 69 01                              adc #$01                 ;otherwise get two's compliment of horizontal adder
0BBE4 18                        AddHA:   clc                      ;add horizontal coordinate relative to screen to
0BBE5 6D AE 03                           adc Enemy_Rel_XPos       ;horizontal adder, modified or otherwise
0BBE8 99 03 02                           sta Sprite_X_Position,y  ;store as X coordinate here
0BBEB 85 06                              sta $06                  ;store here for now, note offset is saved in Y still
0BBED CD AE 03                           cmp Enemy_Rel_XPos       ;compare X coordinate of sprite to original X of firebar
0BBF0 B0 09                              bcs SubtR1               ;if sprite coordinate => original coordinate, branch
0BBF2 AD AE 03                           lda Enemy_Rel_XPos
0BBF5 38                                 sec                      ;otherwise subtract sprite X from the
0BBF6 E5 06                              sbc $06                  ;original one and skip this part
0BBF8 4C FF BB                           jmp ChkFOfs
0BBFB 38                        SubtR1:  sec                      ;subtract original X from the
0BBFC ED AE 03                           sbc Enemy_Rel_XPos       ;current sprite X
0BBFF C9 59                     ChkFOfs: cmp #$59                 ;if difference of coordinates within a certain range,
0BC01 90 04                              bcc VAHandl              ;continue by handling vertical adder
0BC03 A9 F8                              lda #$f8                 ;otherwise, load offscreen Y coordinate
0BC05 D0 15                              bne SetVFbr              ;and unconditionally branch to move sprite offscreen
0BC07 AD B9 03                  VAHandl: lda Enemy_Rel_YPos       ;if vertical relative coordinate offscreen,
0BC0A C9 F8                              cmp #$f8                 ;skip ahead of this part and write into sprite Y coordinate
0BC0C F0 0E                              beq SetVFbr
0BC0E A5 02                              lda $02                  ;load vertical adder we got from position loader
0BC10 46 05                              lsr $05                  ;shift LSB of mirror data one more time
0BC12 B0 04                              bcs AddVA                ;if carry was set, skip this part
0BC14 49 FF                              eor #$ff
0BC16 69 01                              adc #$01                 ;otherwise get two's compliment of second part
0BC18 18                        AddVA:   clc                      ;add vertical coordinate relative to screen to 
0BC19 6D B9 03                           adc Enemy_Rel_YPos       ;the second data, modified or otherwise
0BC1C 99 00 02                  SetVFbr: sta Sprite_Y_Position,y  ;store as Y coordinate here
0BC1F 85 07                              sta $07                  ;also store here for now
0BC21                           
0BC21                           FirebarCollision:
0BC21 20 F0 DB                           jsr DrawFirebar          ;run sub here to draw current tile of firebar
0BC24 98                                 tya                      ;return OAM data offset and save
0BC25 48                                 pha                      ;to the stack for now
0BC26 AD 9F 07                           lda StarInvincibleTimer  ;if star mario invincibility timer
0BC29 0D 47 07                           ora TimerControl         ;or master timer controls set
0BC2C D0 70                              bne NoColFB              ;then skip all of this
0BC2E 85 05                              sta $05                  ;otherwise initialize counter
0BC30 A4 B5                              ldy Player_Y_HighPos
0BC32 88                                 dey                      ;if player's vertical high byte offscreen,
0BC33 D0 69                              bne NoColFB              ;skip all of this
0BC35 A4 CE                              ldy Player_Y_Position    ;get player's vertical position
0BC37 AD 54 07                           lda PlayerSize           ;get player's size
0BC3A D0 05                              bne AdjSm                ;if player small, branch to alter variables
0BC3C AD 14 07                           lda CrouchingFlag
0BC3F F0 09                              beq BigJp                ;if player big and not crouching, jump ahead
0BC41 E6 05                     AdjSm:   inc $05                  ;if small or big but crouching, execute this part
0BC43 E6 05                              inc $05                  ;first increment our counter twice (setting $02 as flag)
0BC45 98                                 tya
0BC46 18                                 clc                      ;then add 24 pixels to the player's
0BC47 69 18                              adc #$18                 ;vertical coordinate
0BC49 A8                                 tay
0BC4A 98                        BigJp:   tya                      ;get vertical coordinate, altered or otherwise, from Y
0BC4B 38                        FBCLoop: sec                      ;subtract vertical position of firebar
0BC4C E5 07                              sbc $07                  ;from the vertical coordinate of the player
0BC4E 10 05                              bpl ChkVFBD              ;if player lower on the screen than firebar, 
0BC50 49 FF                              eor #$ff                 ;skip two's compliment part
0BC52 18                                 clc                      ;otherwise get two's compliment
0BC53 69 01                              adc #$01
0BC55 C9 08                     ChkVFBD: cmp #$08                 ;if difference => 8 pixels, skip ahead of this part
0BC57 B0 1C                              bcs Chk2Ofs
0BC59 A5 06                              lda $06                  ;if firebar on far right on the screen, skip this,
0BC5B C9 F0                              cmp #$f0                 ;because, really, what's the point?
0BC5D B0 16                              bcs Chk2Ofs
0BC5F AD 07 02                           lda Sprite_X_Position+4  ;get OAM X coordinate for sprite #1
0BC62 18                                 clc
0BC63 69 04                              adc #$04                 ;add four pixels
0BC65 85 04                              sta $04                  ;store here
0BC67 38                                 sec                      ;subtract horizontal coordinate of firebar
0BC68 E5 06                              sbc $06                  ;from the X coordinate of player's sprite 1
0BC6A 10 05                              bpl ChkFBCl              ;if modded X coordinate to the right of firebar
0BC6C 49 FF                              eor #$ff                 ;skip two's compliment part
0BC6E 18                                 clc                      ;otherwise get two's compliment
0BC6F 69 01                              adc #$01
0BC71 C9 08                     ChkFBCl: cmp #$08                 ;if difference < 8 pixels, collision, thus branch
0BC73 90 13                              bcc ChgSDir              ;to process
0BC75 A5 05                     Chk2Ofs: lda $05                  ;if value of $02 was set earlier for whatever reason,
0BC77 C9 02                              cmp #$02                 ;branch to increment OAM offset and leave, no collision
0BC79 F0 23                              beq NoColFB
0BC7B A4 05                              ldy $05                  ;otherwise get temp here and use as offset
0BC7D A5 CE                              lda Player_Y_Position
0BC7F 18                                 clc
0BC80 79 53 BB                           adc FirebarYPos,y        ;add value loaded with offset to player's vertical coordinate
0BC83 E6 05                              inc $05                  ;then increment temp and jump back
0BC85 4C 4B BC                           jmp FBCLoop
0BC88 A2 01                     ChgSDir: ldx #$01                 ;set movement direction by default
0BC8A A5 04                              lda $04                  ;if OAM X coordinate of player's sprite 1
0BC8C C5 06                              cmp $06                  ;is greater than horizontal coordinate of firebar
0BC8E B0 01                              bcs SetSDir              ;then do not alter movement direction
0BC90 E8                                 inx                      ;otherwise increment it
0BC91 86 46                     SetSDir: stx Enemy_MovingDir      ;store movement direction here
0BC93 A2 00                              ldx #$00
0BC95 A5 00                              lda $00                  ;save value written to $00 to stack
0BC97 48                                 pha
0BC98 20 8B C7                           jsr InjurePlayer         ;perform sub to hurt or kill player
0BC9B 68                                 pla
0BC9C 85 00                              sta $00                  ;get value of $00 from stack
0BC9E 68                        NoColFB: pla                      ;get OAM data offset
0BC9F 18                                 clc                      ;add four to it and save
0BCA0 69 04                              adc #$04
0BCA2 85 06                              sta $06
0BCA4 A6 08                              ldx ObjectOffset         ;get enemy object buffer offset and leave
0BCA6 60                                 rts
0BCA7                           
0BCA7                           GetFirebarPosition:
0BCA7 48                                   pha                        ;save high byte of spinstate to the stack
0BCA8 29 0F                                and #%00001111             ;mask out low nybble
0BCAA C9 09                                cmp #$09
0BCAC 90 05                                bcc GetHAdder              ;if lower than $09, branch ahead
0BCAE 49 0F                                eor #%00001111             ;otherwise get two's compliment to oscillate
0BCB0 18                                   clc
0BCB1 69 01                                adc #$01
0BCB3 85 01                     GetHAdder: sta $01                    ;store result, modified or not, here
0BCB5 A4 00                                ldy $00                    ;load number of firebar ball where we're at
0BCB7 B9 47 BB                             lda FirebarTblOffsets,y    ;load offset to firebar position data
0BCBA 18                                   clc
0BCBB 65 01                                adc $01                    ;add oscillated high byte of spinstate
0BCBD A8                                   tay                        ;to offset here and use as new offset
0BCBE B9 E0 BA                             lda FirebarPosLookupTbl,y  ;get data here and store as horizontal adder
0BCC1 85 01                                sta $01
0BCC3 68                                   pla                        ;pull whatever was in A from the stack
0BCC4 48                                   pha                        ;save it again because we still need it
0BCC5 18                                   clc
0BCC6 69 08                                adc #$08                   ;add eight this time, to get vertical adder
0BCC8 29 0F                                and #%00001111             ;mask out high nybble
0BCCA C9 09                                cmp #$09                   ;if lower than $09, branch ahead
0BCCC 90 05                                bcc GetVAdder
0BCCE 49 0F                                eor #%00001111             ;otherwise get two's compliment
0BCD0 18                                   clc
0BCD1 69 01                                adc #$01
0BCD3 85 02                     GetVAdder: sta $02                    ;store result here
0BCD5 A4 00                                ldy $00
0BCD7 B9 47 BB                             lda FirebarTblOffsets,y    ;load offset to firebar position data again
0BCDA 18                                   clc
0BCDB 65 02                                adc $02                    ;this time add value in $02 to offset here and use as offset
0BCDD A8                                   tay
0BCDE B9 E0 BA                             lda FirebarPosLookupTbl,y  ;get data here and store as vertica adder
0BCE1 85 02                                sta $02
0BCE3 68                                   pla                        ;pull out whatever was in A one last time
0BCE4 4A                                   lsr                        ;divide by eight or shift three to the right
0BCE5 4A                                   lsr
0BCE6 4A                                   lsr
0BCE7 A8                                   tay                        ;use as offset
0BCE8 B9 43 BB                             lda FirebarMirrorData,y    ;load mirroring data here
0BCEB 85 03                                sta $03                    ;store
0BCED 60                                   rts
0BCEE                           
0BCEE                           ;--------------------------------
0BCEE                           
0BCEE                           PRandomSubtracter:
0BCEE F8 A0 70 BD 00                  .db $f8, $a0, $70, $bd, $00
0BCF3                           
0BCF3                           FlyCCBPriority:
0BCF3 20 20 20 00 00                  .db $20, $20, $20, $00, $00
0BCF8                           
0BCF8                           MoveFlyingCheepCheep:
0BCF8 B5 1E                             lda Enemy_State,x          ;check cheep-cheep's enemy state
0BCFA 29 20                             and #%00100000             ;for d5 set
0BCFC F0 08                             beq FlyCC                  ;branch to continue code if not set
0BCFE A9 00                             lda #$00
0BD00 9D C5 03                          sta Enemy_SprAttrib,x      ;otherwise clear sprite attributes
0BD03 4C B3 AC                          jmp MoveJ_EnemyVertically  ;and jump to move defeated cheep-cheep downwards
0BD06 20 23 AC                  FlyCC:  jsr MoveEnemyHorizontally  ;move cheep-cheep horizontally based on speed and force
0BD09 A0 0D                             ldy #$0d                   ;set vertical movement amount
0BD0B A9 05                             lda #$05                   ;set maximum speed
0BD0D 20 B7 AC                          jsr SetXMoveAmt            ;branch to impose gravity on flying cheep-cheep
0BD10 BD 34 04                          lda Enemy_Y_MoveForce,x
0BD13 4A                                lsr                        ;get vertical movement force and
0BD14 4A                                lsr                        ;move high nybble to low
0BD15 4A                                lsr
0BD16 4A                                lsr
0BD17 A8                                tay                        ;save as offset (note this tends to go into reach of code)
0BD18 B5 CF                             lda Enemy_Y_Position,x     ;get vertical position
0BD1A 38                                sec                        ;subtract pseudorandom value based on offset from position
0BD1B F9 EE BC                          sbc PRandomSubtracter,y
0BD1E 10 05                             bpl AddCCF                  ;if result within top half of screen, skip this part
0BD20 49 FF                             eor #$ff
0BD22 18                                clc                        ;otherwise get two's compliment
0BD23 69 01                             adc #$01
0BD25 C9 08                     AddCCF: cmp #$08                   ;if result or two's compliment greater than eight,
0BD27 B0 0E                             bcs BPGet                  ;skip to the end without changing movement force
0BD29 BD 34 04                          lda Enemy_Y_MoveForce,x
0BD2C 18                                clc
0BD2D 69 10                             adc #$10                   ;otherwise add to it
0BD2F 9D 34 04                          sta Enemy_Y_MoveForce,x
0BD32 4A                                lsr                        ;move high nybble to low again
0BD33 4A                                lsr
0BD34 4A                                lsr
0BD35 4A                                lsr
0BD36 A8                                tay
0BD37 B9 F3 BC                  BPGet:  lda FlyCCBPriority,y       ;load bg priority data and store (this is very likely
0BD3A 9D C5 03                          sta Enemy_SprAttrib,x      ;broken or residual code, value is overwritten before
0BD3D 60                                rts                        ;drawing it next frame), then leave
0BD3E                           
0BD3E                           ;--------------------------------
0BD3E                           ;$00 - used to hold horizontal difference
0BD3E                           ;$01-$03 - used to hold difference adjusters
0BD3E                           
0BD3E                           LakituDiffAdj:
0BD3E 15 30 40                        .db $15, $30, $40
0BD41                           
0BD41                           MoveLakitu:
0BD41 B5 1E                              lda Enemy_State,x          ;check lakitu's enemy state
0BD43 29 20                              and #%00100000             ;for d5 set
0BD45 F0 03                              beq ChkLS                  ;if not set, continue with code
0BD47 4C 84 AC                           jmp MoveD_EnemyVertically  ;otherwise jump to move defeated lakitu downwards
0BD4A B5 1E                     ChkLS:   lda Enemy_State,x          ;if lakitu's enemy state not set at all,
0BD4C F0 0B                              beq Fr12S                  ;go ahead and continue with code
0BD4E A9 00                              lda #$00
0BD50 95 A0                              sta LakituMoveDirection,x  ;otherwise initialize moving direction to move to left
0BD52 8D CB 06                           sta EnemyFrenzyBuffer      ;initialize frenzy buffer
0BD55 A9 10                              lda #$10
0BD57 D0 13                              bne SetLSpd                ;load horizontal speed and do unconditional branch
0BD59 A9 12                     Fr12S:   lda #Spiny
0BD5B 8D CB 06                           sta EnemyFrenzyBuffer      ;set spiny identifier in frenzy buffer
0BD5E A0 02                              ldy #$02
0BD60 B9 3E BD                  LdLDa:   lda LakituDiffAdj,y        ;load values
0BD63 99 01 00                           sta $0001,y                ;store in zero page
0BD66 88                                 dey
0BD67 10 F7                              bpl LdLDa                  ;do this until all values are stired
0BD69 20 85 BD                           jsr PlayerLakituDiff       ;execute sub to set speed and create spinys
0BD6C 95 58                     SetLSpd: sta LakituMoveSpeed,x      ;set movement speed returned from sub
0BD6E A0 01                              ldy #$01                   ;set moving direction to right by default
0BD70 B5 A0                              lda LakituMoveDirection,x
0BD72 29 01                              and #$01                   ;get LSB of moving direction
0BD74 D0 0A                              bne SetLMov                ;if set, branch to the end to use moving direction
0BD76 B5 58                              lda LakituMoveSpeed,x
0BD78 49 FF                              eor #$ff                   ;get two's compliment of moving speed
0BD7A 18                                 clc
0BD7B 69 01                              adc #$01
0BD7D 95 58                              sta LakituMoveSpeed,x      ;store as new moving speed
0BD7F C8                                 iny                        ;increment moving direction to left
0BD80 94 46                     SetLMov: sty Enemy_MovingDir,x      ;store moving direction
0BD82 4C 23 AC                           jmp MoveEnemyHorizontally  ;move lakitu horizontally
0BD85                           
0BD85                           PlayerLakituDiff:
0BD85 A0 00                                ldy #$00                   ;set Y for default value
0BD87 20 F2 CF                             jsr PlayerEnemyDiff        ;get horizontal difference between enemy and player
0BD8A 10 0A                                bpl ChkLakDif              ;branch if enemy is to the right of the player
0BD8C C8                                   iny                        ;increment Y for left of player
0BD8D A5 00                                lda $00
0BD8F 49 FF                                eor #$ff                   ;get two's compliment of low byte of horizontal difference
0BD91 18                                   clc
0BD92 69 01                                adc #$01                   ;store two's compliment as horizontal difference
0BD94 85 00                                sta $00
0BD96 A5 00                     ChkLakDif: lda $00                    ;get low byte of horizontal difference
0BD98 C9 3C                                cmp #$3c                   ;if within a certain distance of player, branch
0BD9A 90 1C                                bcc ChkPSpeed
0BD9C A9 3C                                lda #$3c                   ;otherwise set maximum distance
0BD9E 85 00                                sta $00
0BDA0 B5 16                                lda Enemy_ID,x             ;check if lakitu is in our current enemy slot
0BDA2 C9 11                                cmp #Lakitu
0BDA4 D0 12                                bne ChkPSpeed              ;if not, branch elsewhere
0BDA6 98                                   tya                        ;compare contents of Y, now in A
0BDA7 D5 A0                                cmp LakituMoveDirection,x  ;to what is being used as horizontal movement direction
0BDA9 F0 0D                                beq ChkPSpeed              ;if moving toward the player, branch, do not alter
0BDAB B5 A0                                lda LakituMoveDirection,x  ;if moving to the left beyond maximum distance,
0BDAD F0 06                                beq SetLMovD               ;branch and alter without delay
0BDAF D6 58                                dec LakituMoveSpeed,x      ;decrement horizontal speed
0BDB1 B5 58                                lda LakituMoveSpeed,x      ;if horizontal speed not yet at zero, branch to leave
0BDB3 D0 40                                bne ExMoveLak
0BDB5 98                        SetLMovD:  tya                        ;set horizontal direction depending on horizontal
0BDB6 95 A0                                sta LakituMoveDirection,x  ;difference between enemy and player if necessary
0BDB8 A5 00                     ChkPSpeed: lda $00
0BDBA 29 3C                                and #%00111100             ;mask out all but four bits in the middle
0BDBC 4A                                   lsr                        ;divide masked difference by four
0BDBD 4A                                   lsr
0BDBE 85 00                                sta $00                    ;store as new value
0BDC0 A0 00                                ldy #$00                   ;init offset
0BDC2 A5 57                                lda Player_X_Speed
0BDC4 F0 24                                beq SubDifAdj              ;if player not moving horizontally, branch
0BDC6 AD 75 07                             lda ScrollAmount
0BDC9 F0 1F                                beq SubDifAdj              ;if scroll speed not set, branch to same place
0BDCB C8                                   iny                        ;otherwise increment offset
0BDCC A5 57                                lda Player_X_Speed
0BDCE C9 19                                cmp #$19                   ;if player not running, branch
0BDD0 90 08                                bcc ChkSpinyO
0BDD2 AD 75 07                             lda ScrollAmount
0BDD5 C9 02                                cmp #$02                   ;if scroll speed below a certain amount, branch
0BDD7 90 01                                bcc ChkSpinyO              ;to same place
0BDD9 C8                                   iny                        ;otherwise increment once more
0BDDA B5 16                     ChkSpinyO: lda Enemy_ID,x             ;check for spiny object
0BDDC C9 12                                cmp #Spiny
0BDDE D0 04                                bne ChkEmySpd              ;branch if not found
0BDE0 A5 57                                lda Player_X_Speed         ;if player not moving, skip this part
0BDE2 D0 06                                bne SubDifAdj
0BDE4 B5 A0                     ChkEmySpd: lda Enemy_Y_Speed,x        ;check vertical speed
0BDE6 D0 02                                bne SubDifAdj              ;branch if nonzero
0BDE8 A0 00                                ldy #$00                   ;otherwise reinit offset
0BDEA B9 01 00                  SubDifAdj: lda $0001,y                ;get one of three saved values from earlier
0BDED A4 00                                ldy $00                    ;get saved horizontal difference
0BDEF 38                        SPixelLak: sec                        ;subtract one for each pixel of horizontal difference
0BDF0 E9 01                                sbc #$01                   ;from one of three saved values
0BDF2 88                                   dey
0BDF3 10 FA                                bpl SPixelLak              ;branch until all pixels are subtracted, to adjust difference
0BDF5 60                        ExMoveLak: rts                        ;leave!!!
0BDF6                           
0BDF6                           ;-------------------------------------------------------------------------------------
0BDF6                           ;$04-$05 - used to store name table address in little endian order
0BDF6                           
0BDF6                           BridgeCollapseData:
0BDF6 1A                              .db $1a ;axe
0BDF7 58                              .db $58 ;chain
0BDF8 98 96 94 92 90 8E 8C            .db $98, $96, $94, $92, $90, $8e, $8c ;bridge
0BDFF 8A 88 86 84 82 80               .db $8a, $88, $86, $84, $82, $80
0BE05                           
0BE05                           BridgeCollapse:
0BE05 AE 68 03                         ldx BowserFront_Offset    ;get enemy offset for bowser
0BE08 B5 16                            lda Enemy_ID,x            ;check enemy object identifier for bowser
0BE0A C9 2D                            cmp #Bowser               ;if not found, branch ahead,
0BE0C D0 10                            bne SetM2                 ;metatile removal not necessary
0BE0E 86 08                            stx ObjectOffset          ;store as enemy offset here
0BE10 B5 1E                            lda Enemy_State,x         ;if bowser in normal state, skip all of this
0BE12 F0 1A                            beq RemoveBridge
0BE14 29 40                            and #%01000000            ;if bowser's state has d6 clear, skip to silence music
0BE16 F0 06                            beq SetM2
0BE18 B5 CF                            lda Enemy_Y_Position,x    ;check bowser's vertical coordinate
0BE1A C9 E0                            cmp #$e0                  ;if bowser not yet low enough, skip this part ahead
0BE1C 90 0A                            bcc MoveD_Bowser
0BE1E A9 80                     SetM2: lda #Silence              ;silence music
0BE20 85 FC                            sta EventMusicQueue
0BE22 EE 72 07                         inc OperMode_Task         ;move onto next secondary mode in victory mode
0BE25 4C 8A BE                         jmp KillAllEnemies        ;jump to empty all enemy slots and then leave  
0BE28                           
0BE28                           MoveD_Bowser:
0BE28 20 AD AC                         jsr MoveEnemySlowVert     ;do a sub to move bowser downwards
0BE2B 4C 9C BF                         jmp BowserGfxHandler      ;jump to draw bowser's front and rear, then leave
0BE2E                           
0BE2E                           RemoveBridge:
0BE2E CE 64 03                           dec BowserFeetCounter     ;decrement timer to control bowser's feet
0BE31 D0 44                              bne NoBFall               ;if not expired, skip all of this
0BE33 A9 04                              lda #$04
0BE35 8D 64 03                           sta BowserFeetCounter     ;otherwise, set timer now
0BE38 AD 63 03                           lda BowserBodyControls
0BE3B 49 01                              eor #$01                  ;invert bit to control bowser's feet
0BE3D 8D 63 03                           sta BowserBodyControls
0BE40 A9 22                              lda #$22                  ;put high byte of name table address here for now
0BE42 85 05                              sta $05
0BE44 AC 69 03                           ldy BridgeCollapseOffset  ;get bridge collapse offset here
0BE47 B9 F6 BD                           lda BridgeCollapseData,y  ;load low byte of name table address and store here
0BE4A 85 04                              sta $04
0BE4C AC 00 03                           ldy VRAM_Buffer1_Offset   ;increment vram buffer offset
0BE4F C8                                 iny
0BE50 A2 0C                              ldx #$0c                  ;set offset for tile data for sub to draw blank metatile
0BE52 20 FD 89                           jsr RemBridge             ;do sub here to remove bowser's bridge metatiles
0BE55 A6 08                              ldx ObjectOffset          ;get enemy offset
0BE57 20 BF 89                           jsr MoveVOffset           ;set new vram buffer offset
0BE5A A9 08                              lda #Sfx_Blast            ;load the fireworks/gunfire sound into the square 2 sfx
0BE5C 85 FE                              sta Square2SoundQueue     ;queue while at the same time loading the brick
0BE5E A9 01                              lda #Sfx_BrickShatter     ;shatter sound into the noise sfx queue thus
0BE60 85 FD                              sta NoiseSoundQueue       ;producing the unique sound of the bridge collapsing 
0BE62 EE 69 03                           inc BridgeCollapseOffset  ;increment bridge collapse offset
0BE65 AD 69 03                           lda BridgeCollapseOffset
0BE68 C9 0F                              cmp #$0f                  ;if bridge collapse offset has not yet reached
0BE6A D0 0B                              bne NoBFall               ;the end, go ahead and skip this part
0BE6C 20 4F B1                           jsr InitVStf              ;initialize whatever vertical speed bowser has
0BE6F A9 40                              lda #%01000000
0BE71 95 1E                              sta Enemy_State,x         ;set bowser's state to one of defeated states (d6 set)
0BE73 A9 80                              lda #Sfx_BowserFall
0BE75 85 FE                              sta Square2SoundQueue     ;play bowser defeat sound
0BE77 4C 9C BF                  NoBFall: jmp BowserGfxHandler      ;jump to code that draws bowser
0BE7A                           
0BE7A                           ;--------------------------------
0BE7A                           
0BE7A                           PRandomRange:
0BE7A 21 41 11 31                     .db $21, $41, $11, $31
0BE7E                           
0BE7E                           RunBowser:
0BE7E B5 1E                           lda Enemy_State,x       ;if d5 in enemy state is not set
0BE80 29 20                           and #%00100000          ;then branch elsewhere to run bowser
0BE82 F0 14                           beq BowserControl
0BE84 B5 CF                           lda Enemy_Y_Position,x  ;otherwise check vertical position
0BE86 C9 E0                           cmp #$e0                ;if above a certain point, branch to move defeated bowser
0BE88 90 9E                           bcc MoveD_Bowser        ;otherwise proceed to KillAllEnemies
0BE8A                           
0BE8A                           KillAllEnemies:
0BE8A A2 04                               ldx #$04              ;start with last enemy slot
0BE8C 20 B1 B7                  KillLoop: jsr EraseEnemyObject  ;branch to kill enemy objects
0BE8F CA                                  dex                   ;move onto next enemy slot
0BE90 10 FA                               bpl KillLoop          ;do this until all slots are emptied
0BE92 8D CB 06                            sta EnemyFrenzyBuffer ;empty frenzy buffer
0BE95 A6 08                               ldx ObjectOffset      ;get enemy object offset and leave
0BE97 60                                  rts
0BE98                           
0BE98                           BowserControl:
0BE98 A9 00                                lda #$00
0BE9A 8D CB 06                             sta EnemyFrenzyBuffer      ;empty frenzy buffer
0BE9D AD 47 07                             lda TimerControl           ;if master timer control not set,
0BEA0 F0 03                                beq ChkMouth               ;skip jump and execute code here
0BEA2 4C 52 BF                             jmp SkipToFB               ;otherwise, jump over a bunch of code
0BEA5 AD 63 03                  ChkMouth:  lda BowserBodyControls     ;check bowser's mouth
0BEA8 10 03                                bpl FeetTmr                ;if bit clear, go ahead with code here
0BEAA 4C 28 BF                             jmp HammerChk              ;otherwise skip a whole section starting here
0BEAD CE 64 03                  FeetTmr:   dec BowserFeetCounter      ;decrement timer to control bowser's feet
0BEB0 D0 0D                                bne ResetMDr               ;if not expired, skip this part
0BEB2 A9 20                                lda #$20                   ;otherwise, reset timer
0BEB4 8D 64 03                             sta BowserFeetCounter        
0BEB7 AD 63 03                             lda BowserBodyControls     ;and invert bit used
0BEBA 49 01                                eor #%00000001             ;to control bowser's feet
0BEBC 8D 63 03                             sta BowserBodyControls
0BEBF A5 09                     ResetMDr:  lda FrameCounter           ;check frame counter
0BEC1 29 0F                                and #%00001111             ;if not on every sixteenth frame, skip
0BEC3 D0 04                                bne B_FaceP                ;ahead to continue code
0BEC5 A9 02                                lda #$02                   ;otherwise reset moving/facing direction every
0BEC7 95 46                                sta Enemy_MovingDir,x      ;sixteen frames
0BEC9 BD 8A 07                  B_FaceP:   lda EnemyFrameTimer,x      ;if timer set here expired,
0BECC F0 1C                                beq GetPRCmp               ;branch to next section
0BECE 20 F2 CF                             jsr PlayerEnemyDiff        ;get horizontal difference between player and bowser,
0BED1 10 17                                bpl GetPRCmp               ;and branch if bowser to the right of the player
0BED3 A9 01                                lda #$01
0BED5 95 46                                sta Enemy_MovingDir,x      ;set bowser to move and face to the right
0BED7 A9 02                                lda #$02
0BED9 8D 65 03                             sta BowserMovementSpeed    ;set movement speed
0BEDC A9 20                                lda #$20
0BEDE 9D 8A 07                             sta EnemyFrameTimer,x      ;set timer here
0BEE1 8D 90 07                             sta BowserFireBreathTimer  ;set timer used for bowser's flame
0BEE4 B5 87                                lda Enemy_X_Position,x        
0BEE6 C9 C8                                cmp #$c8                   ;if bowser to the right past a certain point,
0BEE8 B0 3E                                bcs HammerChk              ;skip ahead to some other section
0BEEA A5 09                     GetPRCmp:  lda FrameCounter           ;get frame counter
0BEEC 29 03                                and #%00000011
0BEEE D0 38                                bne HammerChk              ;execute this code every fourth frame, otherwise branch
0BEF0 B5 87                                lda Enemy_X_Position,x
0BEF2 CD 66 03                             cmp BowserOrigXPos         ;if bowser not at original horizontal position,
0BEF5 D0 0C                                bne GetDToO                ;branch to skip this part
0BEF7 BD A7 07                             lda PseudoRandomBitReg,x
0BEFA 29 03                                and #%00000011             ;get pseudorandom offset
0BEFC A8                                   tay
0BEFD B9 7A BE                             lda PRandomRange,y         ;load value using pseudorandom offset
0BF00 8D DC 06                             sta MaxRangeFromOrigin     ;and store here
0BF03 B5 87                     GetDToO:   lda Enemy_X_Position,x
0BF05 18                                   clc                        ;add movement speed to bowser's horizontal
0BF06 6D 65 03                             adc BowserMovementSpeed    ;coordinate and save as new horizontal position
0BF09 95 87                                sta Enemy_X_Position,x
0BF0B B4 46                                ldy Enemy_MovingDir,x
0BF0D C0 01                                cpy #$01                   ;if bowser moving and facing to the right, skip ahead
0BF0F F0 17                                beq HammerChk
0BF11 A0 FF                                ldy #$ff                   ;set default movement speed here (move left)
0BF13 38                                   sec                        ;get difference of current vs. original
0BF14 ED 66 03                             sbc BowserOrigXPos         ;horizontal position
0BF17 10 07                                bpl CompDToO               ;if current position to the right of original, skip ahead
0BF19 49 FF                                eor #$ff
0BF1B 18                                   clc                        ;get two's compliment
0BF1C 69 01                                adc #$01
0BF1E A0 01                                ldy #$01                   ;set alternate movement speed here (move right)
0BF20 CD DC 06                  CompDToO:  cmp MaxRangeFromOrigin     ;compare difference with pseudorandom value
0BF23 90 03                                bcc HammerChk              ;if difference < pseudorandom value, leave speed alone
0BF25 8C 65 03                             sty BowserMovementSpeed    ;otherwise change bowser's movement speed
0BF28 BD 8A 07                  HammerChk: lda EnemyFrameTimer,x      ;if timer set here not expired yet, skip ahead to
0BF2B D0 28                                bne MakeBJump              ;some other section of code
0BF2D 20 AD AC                             jsr MoveEnemySlowVert      ;otherwise start by moving bowser downwards
0BF30 AD 5F 07                             lda WorldNumber            ;check world number
0BF33 C9 05                                cmp #World6
0BF35 90 09                                bcc SetHmrTmr              ;if world 1-5, skip this part (not time to throw hammers yet)
0BF37 A5 09                                lda FrameCounter
0BF39 29 03                                and #%00000011             ;check to see if it's time to execute sub
0BF3B D0 03                                bne SetHmrTmr              ;if not, skip sub, otherwise
0BF3D 20 B3 A7                             jsr SpawnHammerObj         ;execute sub on every fourth frame to spawn hammer
0BF40 B5 CF                     SetHmrTmr: lda Enemy_Y_Position,x     ;get current vertical position
0BF42 C9 80                                cmp #$80                   ;if still above a certain point
0BF44 90 1C                                bcc ChkFireB               ;then skip to world number check for flames
0BF46 BD A7 07                             lda PseudoRandomBitReg,x
0BF49 29 03                                and #%00000011             ;get pseudorandom offset
0BF4B A8                                   tay
0BF4C B9 7A BE                             lda PRandomRange,y         ;get value using pseudorandom offset
0BF4F 9D 8A 07                             sta EnemyFrameTimer,x      ;set for timer here
0BF52 4C 62 BF                  SkipToFB:  jmp ChkFireB               ;jump to execute flames code
0BF55 C9 01                     MakeBJump: cmp #$01                   ;if timer not yet about to expire,
0BF57 D0 09                                bne ChkFireB               ;skip ahead to next part
0BF59 D6 CF                                dec Enemy_Y_Position,x     ;otherwise decrement vertical coordinate
0BF5B 20 4F B1                             jsr InitVStf               ;initialize movement amount
0BF5E A9 FE                                lda #$fe
0BF60 95 A0                                sta Enemy_Y_Speed,x        ;set vertical speed to move bowser upwards
0BF62 AD 5F 07                  ChkFireB:  lda WorldNumber            ;check world number here
0BF65 C9 07                                cmp #World8                ;world 8?
0BF67 F0 0C                                beq SpawnFBr               ;if so, execute this part here
0BF69 C9 08                                cmp #World9                ;world 9?
0BF6B F0 08                                beq SpawnFBr               ;if so, execute this part here
0BF6D C9 0C                                cmp #WorldD                ;world D?
0BF6F F0 04                                beq SpawnFBr               ;if so, execute this part here
0BF71 C9 05                                cmp #World6                ;world 6-7 or A-C?
0BF73 B0 27                                bcs BowserGfxHandler       ;if so, skip this part here
0BF75 AD 90 07                  SpawnFBr:  lda BowserFireBreathTimer  ;check timer here
0BF78 D0 22                                bne BowserGfxHandler       ;if not expired yet, skip all of this
0BF7A A9 20                                lda #$20
0BF7C 8D 90 07                             sta BowserFireBreathTimer  ;set timer here
0BF7F AD 63 03                             lda BowserBodyControls
0BF82 49 80                                eor #%10000000             ;invert bowser's mouth bit to open
0BF84 8D 63 03                             sta BowserBodyControls     ;and close bowser's mouth
0BF87 30 D9                                bmi ChkFireB               ;if bowser's mouth open, loop back
0BF89 20 FA BF                             jsr SetFlameTimer          ;get timing for bowser's flame
0BF8C AC CC 06                             ldy SecondaryHardMode
0BF8F F0 03                                beq SetFBTmr               ;if secondary hard mode flag not set, skip this
0BF91 38                                   sec
0BF92 E9 10                                sbc #$10                   ;otherwise subtract from value in A
0BF94 8D 90 07                  SetFBTmr:  sta BowserFireBreathTimer  ;set value as timer here
0BF97 A9 15                                lda #BowserFlame           ;put bowser's flame identifier
0BF99 8D CB 06                             sta EnemyFrenzyBuffer      ;in enemy frenzy buffer
0BF9C                           
0BF9C                           ;--------------------------------
0BF9C                           
0BF9C                           BowserGfxHandler:
0BF9C 20 DD BF                            jsr ProcessBowserHalf    ;do a sub here to process bowser's front
0BF9F A0 10                               ldy #$10                 ;load default value here to position bowser's rear
0BFA1 B5 46                               lda Enemy_MovingDir,x    ;check moving direction
0BFA3 4A                                  lsr
0BFA4 90 02                               bcc CopyFToR             ;if moving left, use default
0BFA6 A0 F0                               ldy #$f0                 ;otherwise load alternate positioning value here
0BFA8 98                        CopyFToR: tya                      ;move bowser's rear object position value to A
0BFA9 18                                  clc
0BFAA 75 87                               adc Enemy_X_Position,x   ;add to bowser's front object horizontal coordinate
0BFAC AC CF 06                            ldy DuplicateObj_Offset  ;get bowser's rear object offset
0BFAF 99 87 00                            sta Enemy_X_Position,y   ;store A as bowser's rear horizontal coordinate
0BFB2 B5 CF                               lda Enemy_Y_Position,x
0BFB4 18                                  clc                      ;add eight pixels to bowser's front object
0BFB5 69 08                               adc #$08                 ;vertical coordinate and store as vertical coordinate
0BFB7 99 CF 00                            sta Enemy_Y_Position,y   ;for bowser's rear
0BFBA B5 1E                               lda Enemy_State,x
0BFBC 99 1E 00                            sta Enemy_State,y        ;copy enemy state directly from front to rear
0BFBF B5 46                               lda Enemy_MovingDir,x
0BFC1 99 46 00                            sta Enemy_MovingDir,y    ;copy moving direction also
0BFC4 A5 08                               lda ObjectOffset         ;save enemy object offset of front to stack
0BFC6 48                                  pha
0BFC7 AE CF 06                            ldx DuplicateObj_Offset  ;put enemy object offset of rear as current
0BFCA 86 08                               stx ObjectOffset
0BFCC A9 2D                               lda #Bowser              ;set bowser's enemy identifier
0BFCE 95 16                               sta Enemy_ID,x           ;store in bowser's rear object
0BFD0 20 DD BF                            jsr ProcessBowserHalf    ;do a sub here to process bowser's rear
0BFD3 68                                  pla
0BFD4 85 08                               sta ObjectOffset         ;get original enemy object offset
0BFD6 AA                                  tax
0BFD7 A9 00                               lda #$00                 ;nullify bowser's front/rear graphics flag
0BFD9 8D 6A 03                            sta BowserGfxFlag
0BFDC 60                        ExBGfxH:  rts                      ;leave!
0BFDD                           
0BFDD                           ProcessBowserHalf:
0BFDD EE 6A 03                        inc BowserGfxFlag         ;increment bowser's graphics flag, then run subroutines
0BFE0 20 F0 B6                        jsr RunRetainerObj        ;to get offscreen bits, relative position and draw bowser (finally!)
0BFE3 B5 1E                           lda Enemy_State,x
0BFE5 D0 F5                           bne ExBGfxH               ;if either enemy object not in normal state, branch to leave
0BFE7 A9 0A                           lda #$0a
0BFE9 9D 9A 04                        sta Enemy_BoundBoxCtrl,x  ;set bounding box size control
0BFEC 20 FA D0                        jsr GetEnemyBoundBox      ;get bounding box coordinates
0BFEF 4C AF C6                        jmp PlayerEnemyCollision  ;do player-to-enemy collision detection
0BFF2                           
0BFF2                           ;-------------------------------------------------------------------------------------
0BFF2                           ;$00 - used to hold movement force and tile number
0BFF2                           ;$01 - used to hold sprite attribute data
0BFF2                           
0BFF2                           FlameTimerData:
0BFF2 BF 40 BF BF BF 40 40 BF         .db $bf, $40, $bf, $bf, $bf, $40, $40, $bf
0BFFA                           
0BFFA                           SetFlameTimer:
0BFFA AC 67 03                        ldy BowserFlameTimerCtrl  ;load counter as offset
0BFFD EE 67 03                        inc BowserFlameTimerCtrl  ;increment
0C000 AD 67 03                        lda BowserFlameTimerCtrl  ;mask out all but 3 LSB
0C003 29 07                           and #%00000111            ;to keep in range of 0-7
0C005 8D 67 03                        sta BowserFlameTimerCtrl
0C008 B9 F2 BF                        lda FlameTimerData,y      ;load value to be used then leave
0C00B 60                        ExFl: rts
0C00C                           
0C00C                           ProcBowserFlame:
0C00C AD 47 07                           lda TimerControl            ;if master timer control flag set,
0C00F D0 30                              bne SetGfxF                 ;skip all of this
0C011 A9 40                              lda #$40                    ;load default movement force
0C013 AC CC 06                           ldy SecondaryHardMode
0C016 F0 02                              beq SFlmX                   ;if secondary hard mode flag not set, use default
0C018 A9 60                              lda #$60                    ;otherwise load alternate movement force to go faster
0C01A 85 00                     SFlmX:   sta $00                     ;store value here
0C01C BD 01 04                           lda Enemy_X_MoveForce,x
0C01F 38                                 sec                         ;subtract value from movement force
0C020 E5 00                              sbc $00
0C022 9D 01 04                           sta Enemy_X_MoveForce,x     ;save new value
0C025 B5 87                              lda Enemy_X_Position,x
0C027 E9 01                              sbc #$01                    ;subtract one from horizontal position to move
0C029 95 87                              sta Enemy_X_Position,x      ;to the left
0C02B B5 6E                              lda Enemy_PageLoc,x
0C02D E9 00                              sbc #$00                    ;subtract borrow from page location
0C02F 95 6E                              sta Enemy_PageLoc,x
0C031 BC 17 04                           ldy BowserFlamePRandomOfs,x ;get some value here and use as offset
0C034 B5 CF                              lda Enemy_Y_Position,x      ;load vertical coordinate
0C036 D9 AF B3                           cmp FlameYPosData,y         ;compare against coordinate data using $0417,x as offset
0C039 F0 06                              beq SetGfxF                 ;if equal, branch and do not modify coordinate
0C03B 18                                 clc
0C03C 7D 34 04                           adc Enemy_Y_MoveForce,x     ;otherwise add value here to coordinate and store
0C03F 95 CF                              sta Enemy_Y_Position,x      ;as new vertical coordinate
0C041 20 5F E0                  SetGfxF: jsr RelativeEnemyPosition   ;get new relative coordinates
0C044 B5 1E                              lda Enemy_State,x           ;if bowser's flame not in normal state,
0C046 D0 C3                              bne ExFl                    ;branch to leave
0C048 A9 51                              lda #$51                    ;otherwise, continue
0C04A 85 00                              sta $00                     ;write first tile number
0C04C A0 02                              ldy #$02                    ;load attributes without vertical flip by default
0C04E A5 09                              lda FrameCounter
0C050 29 02                              and #%00000010              ;invert vertical flip bit every 2 frames
0C052 F0 02                              beq FlmeAt                  ;if d1 not set, write default value
0C054 A0 82                              ldy #$82                    ;otherwise write value with vertical flip bit set
0C056 84 01                     FlmeAt:  sty $01                     ;set bowser's flame sprite attributes here
0C058 BC E5 06                           ldy Enemy_SprDataOffset,x   ;get OAM data offset
0C05B A2 00                              ldx #$00
0C05D                           
0C05D                           DrawFlameLoop:
0C05D AD B9 03                           lda Enemy_Rel_YPos         ;get Y relative coordinate of current enemy object
0C060 99 00 02                           sta Sprite_Y_Position,y    ;write into Y coordinate of OAM data
0C063 A5 00                              lda $00
0C065 99 01 02                           sta Sprite_Tilenumber,y    ;write current tile number into OAM data
0C068 E6 00                              inc $00                    ;increment tile number to draw more bowser's flame
0C06A A5 01                              lda $01
0C06C 99 02 02                           sta Sprite_Attributes,y    ;write saved attributes into OAM data
0C06F AD AE 03                           lda Enemy_Rel_XPos
0C072 99 03 02                           sta Sprite_X_Position,y    ;write X relative coordinate of current enemy object
0C075 18                                 clc
0C076 69 08                              adc #$08
0C078 8D AE 03                           sta Enemy_Rel_XPos         ;then add eight to it and store
0C07B C8                                 iny
0C07C C8                                 iny
0C07D C8                                 iny
0C07E C8                                 iny                        ;increment Y four times to move onto the next OAM
0C07F E8                                 inx                        ;move onto the next OAM, and branch if three
0C080 E0 03                              cpx #$03                   ;have not yet been done
0C082 90 D9                              bcc DrawFlameLoop
0C084 A6 08                              ldx ObjectOffset           ;reload original enemy offset
0C086 20 BC E0                           jsr GetEnemyOffscreenBits  ;get offscreen information
0C089 BC E5 06                           ldy Enemy_SprDataOffset,x  ;get OAM data offset
0C08C AD D1 03                           lda Enemy_OffscreenBits    ;get enemy object offscreen bits
0C08F 4A                                 lsr                        ;move d0 to carry and result to stack
0C090 48                                 pha
0C091 90 05                              bcc M3FOfs                 ;branch if carry not set
0C093 A9 F8                              lda #$f8                   ;otherwise move sprite offscreen, this part likely
0C095 99 0C 02                           sta Sprite_Y_Position+12,y ;residual since flame is only made of three sprites
0C098 68                        M3FOfs:  pla                        ;get bits from stack
0C099 4A                                 lsr                        ;move d1 to carry and move bits back to stack
0C09A 48                                 pha
0C09B 90 05                              bcc M2FOfs                 ;branch if carry not set again
0C09D A9 F8                              lda #$f8                   ;otherwise move third sprite offscreen
0C09F 99 08 02                           sta Sprite_Y_Position+8,y
0C0A2 68                        M2FOfs:  pla                        ;get bits from stack again
0C0A3 4A                                 lsr                        ;move d2 to carry and move bits back to stack again
0C0A4 48                                 pha
0C0A5 90 05                              bcc M1FOfs                 ;branch if carry not set yet again
0C0A7 A9 F8                              lda #$f8                   ;otherwise move second sprite offscreen
0C0A9 99 04 02                           sta Sprite_Y_Position+4,y
0C0AC 68                        M1FOfs:  pla                        ;get bits from stack one last time
0C0AD 4A                                 lsr                        ;move d3 to carry
0C0AE 90 05                              bcc ExFlmeD                ;branch if carry not set one last time
0C0B0 A9 F8                              lda #$f8
0C0B2 99 00 02                           sta Sprite_Y_Position,y    ;otherwise move first sprite offscreen
0C0B5 60                        ExFlmeD: rts                        ;leave
0C0B6                           
0C0B6                           ;--------------------------------
0C0B6                           
0C0B6                           RunFireworks:
0C0B6 D6 A0                                dec ExplosionTimerCounter,x ;decrement explosion timing counter here
0C0B8 D0 0C                                bne SetupExpl               ;if not expired, skip this part
0C0BA A9 08                                lda #$08
0C0BC 95 A0                                sta ExplosionTimerCounter,x ;reset counter
0C0BE F6 58                                inc ExplosionGfxCounter,x   ;increment explosion graphics counter
0C0C0 B5 58                                lda ExplosionGfxCounter,x
0C0C2 C9 03                                cmp #$03                    ;check explosion graphics counter
0C0C4 B0 18                                bcs FireworksSoundScore     ;if at a certain point, branch to kill this object
0C0C6 20 5F E0                  SetupExpl: jsr RelativeEnemyPosition   ;get relative coordinates of explosion
0C0C9 AD B9 03                             lda Enemy_Rel_YPos          ;copy relative coordinates
0C0CC 8D BA 03                             sta Fireball_Rel_YPos       ;from the enemy object to the fireball object
0C0CF AD AE 03                             lda Enemy_Rel_XPos          ;first vertical, then horizontal
0C0D2 8D AF 03                             sta Fireball_Rel_XPos
0C0D5 BC E5 06                             ldy Enemy_SprDataOffset,x   ;get OAM data offset
0C0D8 B5 58                                lda ExplosionGfxCounter,x   ;get explosion graphics counter
0C0DA 20 1A DC                             jsr DrawExplosion_Fireworks ;do a sub to draw the explosion then leave
0C0DD 60                                   rts
0C0DE                           
0C0DE                           FireworksSoundScore:
0C0DE A9 00                           lda #$00               ;disable enemy buffer flag
0C0E0 95 0F                           sta Enemy_Flag,x
0C0E2 A9 08                           lda #Sfx_Blast         ;play fireworks/gunfire sound
0C0E4 85 FE                           sta Square2SoundQueue
0C0E6 A9 05                           lda #$05               ;set part of score modifier for 500 points
0C0E8 8D 38 01                        sta DigitModifier+4
0C0EB 4C 5C C1                        jmp EndAreaPoints     ;jump to award points accordingly then leave
0C0EE                           
0C0EE                           ;--------------------------------
0C0EE                           
0C0EE                           StarFlagYPosAdder:
0C0EE 00 00 08 08                     .db $00, $00, $08, $08
0C0F2                           
0C0F2                           StarFlagXPosAdder:
0C0F2 00 08 00 08                     .db $00, $08, $00, $08
0C0F6                           
0C0F6                           StarFlagTileData:
0C0F6 54 55 56 57                     .db $54, $55, $56, $57
0C0FA                           
0C0FA                           RunStarFlagObj:
0C0FA A9 00                           lda #$00                 ;initialize enemy frenzy buffer
0C0FC 8D CB 06                        sta EnemyFrenzyBuffer
0C0FF AD 46 07                        lda StarFlagTaskControl  ;check star flag object task number here
0C102 C9 05                           cmp #$05                 ;if greater than 5, branch to exit
0C104 B0 31                           bcs StarFlagExit
0C106 20 F8 8C                        jsr JumpEngine           ;otherwise jump to appropriate sub
0C109                                 
0C109 37 C1                           .dw StarFlagExit
0C10B 13 C1                           .dw GameTimerFireworks
0C10D 38 C1                           .dw AwardGameTimerPoints
0C10F 66 C1                           .dw RaiseFlagSetoffFWorks
0C111 BA C1                           .dw DelayToAreaEnd
0C113                           
0C113                           GameTimerFireworks:
0C113 AD EE 07                           lda GameTimerDisplay+2 ;check to see if last digit of timer matches
0C116 CD E8 07                           cmp CoinDisplay+1      ;the last digit in the coin tally
0C119 D0 10                              bne NoFWks             ;if not, skip the fireworks
0C11B 29 01                              and #$01
0C11D F0 06                              beq EvenDgs            ;if so, check to see if they are both odd or even
0C11F A0 03                              ldy #$03
0C121 A9 03                              lda #$03               ;if they are both odd, set state and counter
0C123 D0 0A                              bne SetFWC             ;for 3 fireworks to go off
0C125 A0 00                     EvenDgs: ldy #$00               ;if they are both even, set state and counter
0C127 A9 06                              lda #$06               ;for 6 fireworks to go off
0C129 D0 04                              bne SetFWC
0C12B A0 00                     NoFWks:  ldy #$00
0C12D A9 FF                              lda #$ff               ;otherwise set value for no fireworks
0C12F 8D D7 06                  SetFWC:  sta FireworksCounter   ;set fireworks counter here
0C132 94 1E                              sty Enemy_State,x      ;set whatever state we have in star flag object
0C134                           
0C134                           IncrementSFTask1:
0C134 EE 46 07                        inc StarFlagTaskControl  ;increment star flag object task number
0C137                           
0C137                           StarFlagExit:
0C137 60                              rts                      ;leave
0C138                           
0C138                           AwardGameTimerPoints:
0C138 AD EC 07                           lda GameTimerDisplay   ;check all game timer digits for any intervals left
0C13B 0D ED 07                           ora GameTimerDisplay+1
0C13E 0D EE 07                           ora GameTimerDisplay+2
0C141 F0 F1                              beq IncrementSFTask1   ;if no time left on game timer at all, branch to next task
0C143                           AwardTimerCastle:
0C143 A5 09                              lda FrameCounter
0C145 29 04                              and #%00000100         ;check frame counter for d2 set (skip ahead
0C147 F0 04                              beq NoTTick            ;for four frames every four frames) branch if not set
0C149 A9 10                              lda #Sfx_TimerTick
0C14B 85 FE                              sta Square2SoundQueue  ;load timer tick sound
0C14D A0 17                     NoTTick: ldy #$17               ;set offset here to subtract from game timer's last digit
0C14F A9 FF                              lda #$ff               ;set adder here to $ff, or -1, to subtract one
0C151 8D 39 01                           sta DigitModifier+5    ;from the last digit of the game timer
0C154 20 4D 8E                           jsr DigitsMathRoutine  ;subtract digit
0C157 A9 05                              lda #$05               ;set now to add 50 points
0C159 8D 39 01                           sta DigitModifier+5    ;per game timer interval subtracted
0C15C                           
0C15C                           EndAreaPoints:
0C15C A0 0B                              ldy #$0b               ;load offset for score, then jump to handle the awarding
0C15E 20 4D 8E                           jsr DigitsMathRoutine
0C161 A9 02                              lda #$02               ;now update the score on the screen
0C163 4C 3F A9                           jmp WriteDigits
0C166                           
0C166                           RaiseFlagSetoffFWorks:
0C166 B5 CF                              lda Enemy_Y_Position,x  ;check star flag's vertical position
0C168 C9 72                              cmp #$72                ;against preset value
0C16A 90 05                              bcc SetoffF             ;if star flag higher vertically, branch to other code
0C16C D6 CF                              dec Enemy_Y_Position,x  ;otherwise, raise star flag by one pixel
0C16E 4C 7D C1                           jmp DrawStarFlag        ;and skip this part here
0C171 AD D7 06                  SetoffF: lda FireworksCounter    ;check fireworks counter
0C174 F0 38                              beq DrawFlagSetTimer    ;if no fireworks left to go off, skip this part
0C176 30 36                              bmi DrawFlagSetTimer    ;if no fireworks set to go off, skip this part
0C178 A9 16                              lda #Fireworks
0C17A 8D CB 06                           sta EnemyFrenzyBuffer   ;otherwise set fireworks object in frenzy queue
0C17D                           
0C17D                           DrawStarFlag:
0C17D 20 5F E0                           jsr RelativeEnemyPosition  ;get relative coordinates of star flag
0C180 BC E5 06                           ldy Enemy_SprDataOffset,x  ;get OAM data offset
0C183 A2 03                              ldx #$03                   ;do four sprites
0C185 AD B9 03                  DSFLoop: lda Enemy_Rel_YPos         ;get relative vertical coordinate
0C188 18                                 clc
0C189 7D EE C0                           adc StarFlagYPosAdder,x    ;add Y coordinate adder data
0C18C 99 00 02                           sta Sprite_Y_Position,y    ;store as Y coordinate
0C18F BD F6 C0                           lda StarFlagTileData,x     ;get tile number
0C192 99 01 02                           sta Sprite_Tilenumber,y    ;store as tile number
0C195 A9 22                              lda #$22                   ;set palette and background priority bits
0C197 99 02 02                           sta Sprite_Attributes,y    ;store as attributes
0C19A AD AE 03                           lda Enemy_Rel_XPos         ;get relative horizontal coordinate
0C19D 18                                 clc
0C19E 7D F2 C0                           adc StarFlagXPosAdder,x    ;add X coordinate adder data
0C1A1 99 03 02                           sta Sprite_X_Position,y    ;store as X coordinate
0C1A4 C8                                 iny
0C1A5 C8                                 iny                        ;increment OAM data offset four bytes
0C1A6 C8                                 iny                        ;for next sprite
0C1A7 C8                                 iny
0C1A8 CA                                 dex                        ;move onto next sprite
0C1A9 10 DA                              bpl DSFLoop                ;do this until all sprites are done
0C1AB A6 08                              ldx ObjectOffset           ;get enemy object offset and leave
0C1AD 60                                 rts
0C1AE                           
0C1AE                           DrawFlagSetTimer:
0C1AE 20 7D C1                        jsr DrawStarFlag          ;do sub to draw star flag
0C1B1 A9 06                           lda #$06
0C1B3 9D 96 07                        sta EnemyIntervalTimer,x  ;set interval timer here
0C1B6                           
0C1B6                           IncrementSFTask2:
0C1B6 EE 46 07                        inc StarFlagTaskControl   ;move onto next task
0C1B9 60                              rts
0C1BA                           
0C1BA                           DelayToAreaEnd:
0C1BA 20 7D C1                        jsr DrawStarFlag          ;do sub to draw star flag
0C1BD BD 96 07                        lda EnemyIntervalTimer,x  ;if interval timer set in previous task
0C1C0 D0 05                           bne StarFlagExit2         ;not yet expired, branch to leave
0C1C2 AD B1 07                        lda EventMusicBuffer      ;if event music buffer empty,
0C1C5 F0 EF                           beq IncrementSFTask2      ;branch to increment task
0C1C7                           
0C1C7                           StarFlagExit2:
0C1C7 60                              rts                       ;otherwise leave
0C1C8                           
0C1C8                           ;--------------------------------
0C1C8                           ;$00 - used to store horizontal difference between player and piranha plant
0C1C8                           
0C1C8                           MovePiranhaPlant:
0C1C8 B5 1E                           lda Enemy_State,x           ;check enemy state
0C1CA D0 72                           bne PutinPipe               ;if set at all, branch to leave
0C1CC BD 8A 07                        lda EnemyFrameTimer,x       ;check enemy's timer here
0C1CF D0 6D                           bne PutinPipe               ;branch to end if not yet expired
0C1D1 B5 A0                           lda PiranhaPlant_MoveFlag,x ;check movement flag
0C1D3 D0 33                           bne SetupToMovePPlant       ;if moving, skip to part ahead
0C1D5 B5 58                           lda PiranhaPlant_Y_Speed,x  ;if currently rising, branch 
0C1D7 30 24                           bmi ReversePlantSpeed       ;to move enemy upwards out of pipe
0C1D9 20 F2 CF                        jsr PlayerEnemyDiff         ;get horizontal difference between player and
0C1DC 10 09                           bpl ChkPlayerNearPipe       ;piranha plant, and branch if enemy to right of player
0C1DE A5 00                           lda $00                     ;otherwise get saved horizontal difference
0C1E0 49 FF                           eor #$ff
0C1E2 18                              clc                         ;and change to two's compliment
0C1E3 69 01                           adc #$01
0C1E5 85 00                           sta $00                     ;save as new horizontal difference
0C1E7                           
0C1E7                           ChkPlayerNearPipe:
0C1E7 A5 00                           lda $00                     ;get saved horizontal difference
0C1E9 C9 13                           cmp #$13
0C1EB 90 51                           bcc PutinPipe               ;if player within a certain distance, branch to leave
0C1ED AC FB 07                        ldy HardWorldFlag           ;are we dealing with red piranha plants?
0C1F0 F0 07                           beq ExtD                    ;if we're playing SMB1 levels, nope!
0C1F2 AC 5F 07                        ldy WorldNumber             ;otherwise, check for world 4+ of SMB2J
0C1F5 C0 03                           cpy #World4
0C1F7 B0 04                           bcs ReversePlantSpeed       ;if found, we're done here
0C1F9 C9 21                     ExtD: cmp #$21                    ;otherwise, extend distance for green piranha plants
0C1FB 90 41                           bcc PutinPipe
0C1FD                           
0C1FD                           ReversePlantSpeed:
0C1FD B5 58                           lda PiranhaPlant_Y_Speed,x  ;get vertical speed
0C1FF 49 FF                           eor #$ff
0C201 18                              clc                         ;change to two's compliment
0C202 69 01                           adc #$01
0C204 95 58                           sta PiranhaPlant_Y_Speed,x  ;save as new vertical speed
0C206 F6 A0                           inc PiranhaPlant_MoveFlag,x ;increment to set movement flag
0C208                           
0C208                           SetupToMovePPlant:
0C208 BD 34 04                        lda PiranhaPlantDownYPos,x  ;get original vertical coordinate (lowest point)
0C20B B4 58                           ldy PiranhaPlant_Y_Speed,x  ;get vertical speed
0C20D 10 03                           bpl RiseFallPiranhaPlant    ;branch if moving downwards
0C20F BD 17 04                        lda PiranhaPlantUpYPos,x    ;otherwise get other vertical coordinate (highest point)
0C212                           
0C212                           RiseFallPiranhaPlant:
0C212 85 00                            sta $00                     ;save vertical coordinate here
0C214 AD FB 07                         lda HardWorldFlag           ;check for red piranha plants
0C217 F0 07                            beq GrnPP                   ;no red piranha plants in SMB1 levels
0C219 AD 5F 07                         lda WorldNumber             ;only red piranha plants in world 4+ of SMB2J
0C21C C9 03                            cmp #World4
0C21E B0 05                            bcs RedPP                   ;if found, skip to next part to execute code on every frame
0C220 A5 09                     GrnPP: lda FrameCounter            ;get frame counter
0C222 4A                               lsr
0C223 90 19                            bcc PutinPipe               ;branch to leave if d0 set (execute code every other frame)
0C225 AD 47 07                  RedPP: lda TimerControl            ;get master timer control
0C228 D0 14                            bne PutinPipe               ;branch to leave if set (likely not necessary)
0C22A B5 CF                            lda Enemy_Y_Position,x      ;get current vertical coordinate
0C22C 18                               clc
0C22D 75 58                            adc PiranhaPlant_Y_Speed,x  ;add vertical speed to move up or down
0C22F 95 CF                            sta Enemy_Y_Position,x      ;save as new vertical coordinate
0C231 C5 00                            cmp $00                     ;compare against low or high coordinate
0C233 D0 09                            bne PutinPipe               ;branch to leave if not yet reached
0C235 A9 00                            lda #$00
0C237 95 A0                            sta PiranhaPlant_MoveFlag,x ;otherwise clear movement flag
0C239 A9 40                            lda #$40
0C23B 9D 8A 07                         sta EnemyFrameTimer,x       ;set timer to delay piranha plant movement
0C23E                           
0C23E                           PutinPipe:
0C23E A9 20                           lda #%00100000              ;set background priority bit in sprite
0C240 9D C5 03                        sta Enemy_SprAttrib,x       ;attributes to give illusion of being inside pipe
0C243 60                              rts                         ;then leave
0C244                           
0C244                           ;-------------------------------------------------------------------------------------
0C244                           ;$07 - spinning speed
0C244                           
0C244                           FirebarSpin:
0C244 85 07                           sta $07                     ;save spinning speed here
0C246 B5 34                           lda FirebarSpinDirection,x  ;check spinning direction
0C248 D0 0E                           bne SpinCounterClockwise    ;if moving counter-clockwise, branch to other part
0C24A A0 18                           ldy #$18                    ;possibly residual ldy
0C24C B5 58                           lda FirebarSpinState_Low,x
0C24E 18                              clc                         ;add spinning speed to what would normally be
0C24F 65 07                           adc $07                     ;the horizontal speed
0C251 95 58                           sta FirebarSpinState_Low,x
0C253 B5 A0                           lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
0C255 69 00                           adc #$00
0C257 60                              rts
0C258                           
0C258                           SpinCounterClockwise:
0C258 A0 08                           ldy #$08                    ;possibly residual ldy
0C25A B5 58                           lda FirebarSpinState_Low,x
0C25C 38                              sec                         ;subtract spinning speed to what would normally be
0C25D E5 07                           sbc $07                     ;the horizontal speed
0C25F 95 58                           sta FirebarSpinState_Low,x
0C261 B5 A0                           lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
0C263 E9 00                           sbc #$00
0C265 60                              rts
0C266                           
0C266                           
0C266                           ;-------------------------------------------------------------------------------------
0C266                           ;$00 - used to hold collision flag, Y movement force + 5 or low byte of name table for rope
0C266                           ;$01 - used to hold high byte of name table for rope
0C266                           ;$02 - used to hold page location of rope
0C266                           
0C266                           BalancePlatform:
0C266 B5 B6                             lda Enemy_Y_HighPos,x       ;check high byte of vertical position
0C268 C9 03                             cmp #$03
0C26A D0 03                             bne DoBPl
0C26C 4C B1 B7                          jmp EraseEnemyObject        ;if far below screen, kill the object
0C26F B5 1E                     DoBPl:  lda Enemy_State,x           ;get object's state (set to $ff or other platform offset)
0C271 10 01                             bpl CheckBalPlatform        ;if doing other balance platform, branch to handle it
0C273 60                        ExBalP: rts
0C274                           
0C274                           
0C274                           CheckBalPlatform:
0C274 A8                               tay                         ;save offset from state as Y
0C275 B9 16 00                         lda Enemy_ID,y
0C278 C9 24                            cmp #$24                    ;check to see if other object is balance platform
0C27A D0 F7                            bne ExBalP                  ;if not, branch to leave
0C27C BD A2 03                         lda PlatformCollisionFlag,x ;get collision flag of platform
0C27F 85 00                            sta $00                     ;store here
0C281 B5 46                            lda Enemy_MovingDir,x       ;get moving direction
0C283 F0 03                            beq ChkForFall
0C285 4C F6 C3                         jmp PlatformFall            ;if set, jump here
0C288                           
0C288                           ChkForFall:
0C288 A9 2D                            lda #$2d                    ;check if platform is above a certain point
0C28A D5 CF                            cmp Enemy_Y_Position,x
0C28C 90 0F                            bcc ChkOtherForFall         ;if not, branch elsewhere
0C28E C4 00                            cpy $00                     ;if collision flag is set to same value as
0C290 F0 08                            beq MakePlatformFall        ;enemy state, branch to make platforms fall
0C292 18                               clc
0C293 69 02                            adc #$02                    ;otherwise add 2 pixels to vertical position
0C295 95 CF                            sta Enemy_Y_Position,x      ;of current platform and branch elsewhere
0C297 4C EC C3                         jmp StopPlatforms           ;to make platforms stop
0C29A                           
0C29A                           MakePlatformFall:
0C29A 4C D3 C3                         jmp InitPlatformFall        ;make platforms fall
0C29D                           
0C29D                           ChkOtherForFall:
0C29D D9 CF 00                         cmp Enemy_Y_Position,y      ;check if other platform is above a certain point
0C2A0 90 0D                            bcc ChkToMoveBalPlat        ;if not, branch elsewhere
0C2A2 E4 00                            cpx $00                     ;if collision flag is set to same value as
0C2A4 F0 F4                            beq MakePlatformFall        ;enemy state, branch to make platforms fall
0C2A6 18                               clc
0C2A7 69 02                            adc #$02                    ;otherwise add 2 pixels to vertical position
0C2A9 99 CF 00                         sta Enemy_Y_Position,y      ;of other platform and branch elsewhere
0C2AC 4C EC C3                         jmp StopPlatforms           ;jump to stop movement and do not return
0C2AF                           
0C2AF                           ChkToMoveBalPlat:
0C2AF B5 CF                             lda Enemy_Y_Position,x      ;save vertical position to stack
0C2B1 48                                pha
0C2B2 BD A2 03                          lda PlatformCollisionFlag,x ;get collision flag
0C2B5 10 18                             bpl ColFlg                  ;branch if collision
0C2B7 BD 34 04                          lda Enemy_Y_MoveForce,x
0C2BA 18                                clc                         ;add $05 to contents of moveforce, whatever they be
0C2BB 69 05                             adc #$05
0C2BD 85 00                             sta $00                     ;store here
0C2BF B5 A0                             lda Enemy_Y_Speed,x
0C2C1 69 00                             adc #$00                    ;add carry to vertical speed
0C2C3 30 1A                             bmi PlatDn                  ;branch if moving downwards
0C2C5 D0 0C                             bne PlatUp                  ;branch elsewhere if moving upwards
0C2C7 A5 00                             lda $00
0C2C9 C9 0B                             cmp #$0b                    ;check if there's still a little force left
0C2CB 90 0C                             bcc PlatSt                  ;if not enough, branch to stop movement
0C2CD B0 04                             bcs PlatUp                  ;otherwise keep branch to move upwards
0C2CF C5 08                     ColFlg: cmp ObjectOffset            ;if collision flag matches
0C2D1 F0 0C                             beq PlatDn                  ;current enemy object offset, branch
0C2D3 20 D8 AC                  PlatUp: jsr MovePlatformUp          ;do a sub to move upwards
0C2D6 4C E2 C2                          jmp DoOtherPlatform         ;jump ahead to remaining code
0C2D9 20 EC C3                  PlatSt: jsr StopPlatforms           ;do a sub to stop movement
0C2DC 4C E2 C2                          jmp DoOtherPlatform         ;jump ahead to remaining code
0C2DF 20 D5 AC                  PlatDn: jsr MovePlatformDown        ;do a sub to move downwards
0C2E2                           
0C2E2                           DoOtherPlatform:
0C2E2 B4 1E                            ldy Enemy_State,x           ;get offset of other platform
0C2E4 68                               pla                         ;get old vertical coordinate from stack
0C2E5 38                               sec
0C2E6 F5 CF                            sbc Enemy_Y_Position,x      ;get difference of old vs. new coordinate
0C2E8 18                               clc
0C2E9 79 CF 00                         adc Enemy_Y_Position,y      ;add difference to vertical coordinate of other
0C2EC 99 CF 00                         sta Enemy_Y_Position,y      ;platform to move it in the opposite direction
0C2EF BD A2 03                         lda PlatformCollisionFlag,x ;if no collision, skip this part here
0C2F2 30 04                            bmi DrawEraseRope
0C2F4 AA                               tax                         ;put offset which collision occurred here
0C2F5 20 AA CA                         jsr PositionPlayerOnVPlat   ;and use it to position player accordingly
0C2F8                           
0C2F8                           DrawEraseRope:
0C2F8 A4 08                              ldy ObjectOffset            ;get enemy object offset
0C2FA B9 A0 00                           lda Enemy_Y_Speed,y         ;check to see if current platform is
0C2FD 19 34 04                           ora Enemy_Y_MoveForce,y     ;moving at all
0C300 F0 77                              beq ExitRp                  ;if not, skip all of this and branch to leave
0C302 AE 00 03                           ldx VRAM_Buffer1_Offset     ;get vram buffer offset
0C305 E0 20                              cpx #$20                    ;if offset beyond a certain point, go ahead
0C307 B0 70                              bcs ExitRp                  ;and skip this, branch to leave
0C309 B9 A0 00                           lda Enemy_Y_Speed,y
0C30C 48                                 pha                         ;save two copies of vertical speed to stack
0C30D 48                                 pha
0C30E 20 7C C3                           jsr SetupPlatformRope       ;do a sub to figure out where to put new bg tiles
0C311 A5 01                              lda $01                     ;write name table address to vram buffer
0C313 9D 01 03                           sta VRAM_Buffer1,x          ;first the high byte, then the low
0C316 A5 00                              lda $00
0C318 9D 02 03                           sta VRAM_Buffer1+1,x
0C31B A9 02                              lda #$02                    ;set length for 2 bytes
0C31D 9D 03 03                           sta VRAM_Buffer1+2,x
0C320 B9 A0 00                           lda Enemy_Y_Speed,y         ;if platform moving upwards, branch 
0C323 30 0D                              bmi EraseR1                 ;to do something else
0C325 A9 A2                              lda #$a2
0C327 9D 04 03                           sta VRAM_Buffer1+3,x        ;otherwise put tile numbers for left
0C32A A9 A3                              lda #$a3                    ;and right sides of rope in vram buffer
0C32C 9D 05 03                           sta VRAM_Buffer1+4,x
0C32F 4C 3A C3                           jmp OtherRope               ;jump to skip this part
0C332 A9 24                     EraseR1: lda #$24                    ;put blank tiles in vram buffer
0C334 9D 04 03                           sta VRAM_Buffer1+3,x        ;to erase rope
0C337 9D 05 03                           sta VRAM_Buffer1+4,x
0C33A                           
0C33A                           OtherRope:
0C33A B9 1E 00                           lda Enemy_State,y           ;get offset of other platform from state
0C33D A8                                 tay                         ;use as Y here
0C33E 68                                 pla                         ;pull second copy of vertical speed from stack
0C33F 49 FF                              eor #$ff                    ;invert bits to reverse speed
0C341 20 7C C3                           jsr SetupPlatformRope       ;do sub again to figure out where to put bg tiles  
0C344 A5 01                              lda $01                     ;write name table address to vram buffer
0C346 9D 06 03                           sta VRAM_Buffer1+5,x        ;this time we're doing putting tiles for
0C349 A5 00                              lda $00                     ;the other platform
0C34B 9D 07 03                           sta VRAM_Buffer1+6,x
0C34E A9 02                              lda #$02
0C350 9D 08 03                           sta VRAM_Buffer1+7,x        ;set length again for 2 bytes
0C353 68                                 pla                         ;pull first copy of vertical speed from stack
0C354 10 0D                              bpl EraseR2                 ;if moving upwards (note inversion earlier), skip this
0C356 A9 A2                              lda #$a2
0C358 9D 09 03                           sta VRAM_Buffer1+8,x        ;otherwise put tile numbers for left
0C35B A9 A3                              lda #$a3                    ;and right sides of rope in vram
0C35D 9D 0A 03                           sta VRAM_Buffer1+9,x        ;transfer buffer
0C360 4C 6B C3                           jmp EndRp                   ;jump to skip this part
0C363 A9 24                     EraseR2: lda #$24                    ;put blank tiles in vram buffer
0C365 9D 09 03                           sta VRAM_Buffer1+8,x        ;to erase rope
0C368 9D 0A 03                           sta VRAM_Buffer1+9,x
0C36B A9 00                     EndRp:   lda #$00                    ;put null terminator at the end
0C36D 9D 0B 03                           sta VRAM_Buffer1+10,x
0C370 AD 00 03                           lda VRAM_Buffer1_Offset     ;add ten bytes to the vram buffer offset
0C373 18                                 clc                         ;and store
0C374 69 0A                              adc #10
0C376 8D 00 03                           sta VRAM_Buffer1_Offset
0C379 A6 08                     ExitRp:  ldx ObjectOffset            ;get enemy object buffer offset and leave
0C37B 60                                 rts
0C37C                           
0C37C                           SetupPlatformRope:
0C37C 48                                pha                     ;save second/third copy to stack
0C37D B9 87 00                          lda Enemy_X_Position,y  ;get horizontal coordinate
0C380 18                                clc
0C381 69 08                             adc #$08                ;add eight pixels
0C383 AE CC 06                          ldx SecondaryHardMode   ;if secondary hard mode flag set,
0C386 D0 03                             bne GetLRp              ;use coordinate as-is
0C388 18                                clc
0C389 69 10                             adc #$10                ;otherwise add sixteen more pixels
0C38B 48                        GetLRp: pha                     ;save modified horizontal coordinate to stack
0C38C B9 6E 00                          lda Enemy_PageLoc,y
0C38F 69 00                             adc #$00                ;add carry to page location
0C391 85 02                             sta $02                 ;and save here
0C393 68                                pla                     ;pull modified horizontal coordinate
0C394 29 F0                             and #%11110000          ;from the stack, mask out low nybble
0C396 4A                                lsr                     ;and shift three bits to the right
0C397 4A                                lsr
0C398 4A                                lsr
0C399 85 00                             sta $00                 ;store result here as part of name table low byte
0C39B B6 CF                             ldx Enemy_Y_Position,y  ;get vertical coordinate
0C39D 68                                pla                     ;get second/third copy of vertical speed from stack
0C39E 10 05                             bpl GetHRp              ;skip this part if moving downwards or not at all
0C3A0 8A                                txa
0C3A1 18                                clc
0C3A2 69 08                             adc #$08                ;add eight to vertical coordinate and
0C3A4 AA                                tax                     ;save as X
0C3A5 8A                        GetHRp: txa                     ;move vertical coordinate to A
0C3A6 AE 00 03                          ldx VRAM_Buffer1_Offset ;get vram buffer offset
0C3A9 0A                                asl
0C3AA 2A                                rol                     ;rotate d7 to d0 and d6 into carry
0C3AB 48                                pha                     ;save modified vertical coordinate to stack
0C3AC 2A                                rol                     ;rotate carry to d0, thus d7 and d6 are at 2 LSB
0C3AD 29 03                             and #%00000011          ;mask out all bits but d7 and d6, then set
0C3AF 09 20                             ora #%00100000          ;d5 to get appropriate high byte of name table
0C3B1 85 01                             sta $01                 ;address, then store
0C3B3 A5 02                             lda $02                 ;get saved page location from earlier
0C3B5 29 01                             and #$01                ;mask out all but LSB
0C3B7 0A                                asl
0C3B8 0A                                asl                     ;shift twice to the left and save with the
0C3B9 05 01                             ora $01                 ;rest of the bits of the high byte, to get
0C3BB 85 01                             sta $01                 ;the proper name table and the right place on it
0C3BD 68                                pla                     ;get modified vertical coordinate from stack
0C3BE 29 E0                             and #%11100000          ;mask out low nybble and LSB of high nybble
0C3C0 18                                clc
0C3C1 65 00                             adc $00                 ;add to horizontal part saved here
0C3C3 85 00                             sta $00                 ;save as name table low byte
0C3C5 B9 CF 00                          lda Enemy_Y_Position,y
0C3C8 C9 E8                             cmp #$e8                ;if vertical position not below the
0C3CA 90 06                             bcc ExPRp               ;bottom of the screen, we're done, branch to leave
0C3CC A5 00                             lda $00
0C3CE 29 BF                             and #%10111111          ;mask out d6 of low byte of name table address
0C3D0 85 00                             sta $00
0C3D2 60                        ExPRp:  rts                     ;leave!
0C3D3                           
0C3D3                           InitPlatformFall:
0C3D3 98                              tya                        ;move offset of other platform from Y to X
0C3D4 AA                              tax
0C3D5 20 BC E0                        jsr GetEnemyOffscreenBits  ;get offscreen bits
0C3D8 A9 06                           lda #$06
0C3DA 20 7E C8                        jsr SetupFloateyNumber     ;award 1000 points to player
0C3DD AD AD 03                        lda Player_Rel_XPos
0C3E0 9D 17 01                        sta FloateyNum_X_Pos,x     ;put floatey number coordinates where player is
0C3E3 A5 CE                           lda Player_Y_Position
0C3E5 9D 1E 01                        sta FloateyNum_Y_Pos,x
0C3E8 A9 01                           lda #$01                   ;set moving direction as flag for
0C3EA 95 46                           sta Enemy_MovingDir,x      ;falling platforms
0C3EC                           
0C3EC                           StopPlatforms:
0C3EC 20 4F B1                        jsr InitVStf             ;initialize vertical speed and low byte
0C3EF 99 A0 00                        sta Enemy_Y_Speed,y      ;for both platforms and leave
0C3F2 99 34 04                        sta Enemy_Y_MoveForce,y
0C3F5 60                              rts
0C3F6                           
0C3F6                           PlatformFall:
0C3F6 98                              tya                         ;save offset for other platform to stack
0C3F7 48                              pha
0C3F8 20 8C AC                        jsr MoveFallingPlatform     ;make current platform fall
0C3FB 68                              pla
0C3FC AA                              tax                         ;pull offset from stack and save to X
0C3FD 20 8C AC                        jsr MoveFallingPlatform     ;make other platform fall
0C400 A6 08                           ldx ObjectOffset
0C402 BD A2 03                        lda PlatformCollisionFlag,x ;if player not standing on either platform,
0C405 30 04                           bmi ExPF                    ;skip this part
0C407 AA                              tax                         ;transfer collision flag offset as offset to X
0C408 20 AA CA                        jsr PositionPlayerOnVPlat   ;and position player appropriately
0C40B A6 08                     ExPF: ldx ObjectOffset            ;get enemy object buffer offset and leave
0C40D 60                              rts
0C40E                           
0C40E                           ;--------------------------------
0C40E                           
0C40E                           YMovingPlatform:
0C40E B5 A0                             lda Enemy_Y_Speed,x          ;if platform moving up or down, skip ahead to
0C410 1D 34 04                          ora Enemy_Y_MoveForce,x      ;check on other position
0C413 D0 15                             bne ChkYCenterPos
0C415 9D 17 04                          sta Enemy_YMF_Dummy,x        ;initialize dummy variable
0C418 B5 CF                             lda Enemy_Y_Position,x
0C41A DD 01 04                          cmp YPlatformTopYPos,x       ;if current vertical position => top position, branch
0C41D B0 0B                             bcs ChkYCenterPos            ;ahead of all this
0C41F A5 09                             lda FrameCounter
0C421 29 07                             and #%00000111               ;check for every eighth frame
0C423 D0 02                             bne SkipIY
0C425 F6 CF                             inc Enemy_Y_Position,x       ;increase vertical position every eighth frame
0C427 4C 39 C4                  SkipIY: jmp ChkYPCollision           ;skip ahead to last part
0C42A                           
0C42A                           ChkYCenterPos:
0C42A B5 CF                             lda Enemy_Y_Position,x       ;if current vertical position < central position, branch
0C42C D5 58                             cmp YPlatformCenterYPos,x    ;to slow ascent/move downwards
0C42E 90 06                             bcc YMDown
0C430 20 D8 AC                          jsr MovePlatformUp           ;otherwise start slowing descent/moving upwards
0C433 4C 39 C4                          jmp ChkYPCollision
0C436 20 D5 AC                  YMDown: jsr MovePlatformDown         ;start slowing ascent/moving downwards
0C439                           
0C439                           ChkYPCollision:
0C439 BD A2 03                         lda PlatformCollisionFlag,x  ;if collision flag not set here, branch
0C43C 30 03                            bmi ExYPl                    ;to leave
0C43E 20 AA CA                         jsr PositionPlayerOnVPlat    ;otherwise position player appropriately
0C441 60                        ExYPl: rts                          ;leave
0C442                           
0C442                           ;--------------------------------
0C442                           ;$00 - used as adder to position player hotizontally
0C442                           
0C442                           XMovingPlatform:
0C442 A9 0E                           lda #$0e                     ;load preset maximum value for secondary counter
0C444 20 60 B9                        jsr XMoveCntr_Platform       ;do a sub to increment counters for movement
0C447 20 7F B9                        jsr MoveWithXMCntrs          ;do a sub to move platform accordingly, and return value
0C44A BD A2 03                        lda PlatformCollisionFlag,x  ;if no collision with player,
0C44D 30 1C                           bmi ExXMP                    ;branch ahead to leave
0C44F                           
0C44F                           PositionPlayerOnHPlat:
0C44F A5 86                              lda Player_X_Position
0C451 18                                 clc                       ;add saved value from second subroutine to
0C452 65 00                              adc $00                   ;current player's position to position
0C454 85 86                              sta Player_X_Position     ;player accordingly in horizontal position
0C456 A5 6D                              lda Player_PageLoc        ;get player's page location
0C458 A4 00                              ldy $00                   ;check to see if saved value here is positive or negative
0C45A 30 05                              bmi PPHSubt               ;if negative, branch to subtract
0C45C 69 00                              adc #$00                  ;otherwise add carry to page location
0C45E 4C 63 C4                           jmp SetPVar               ;jump to skip subtraction
0C461 E9 00                     PPHSubt: sbc #$00                  ;subtract borrow from page location
0C463 85 6D                     SetPVar: sta Player_PageLoc        ;save result to player's page location
0C465 8C A1 03                           sty Platform_X_Scroll     ;put saved value from second sub here to be used later
0C468 20 AA CA                           jsr PositionPlayerOnVPlat ;position player vertically and appropriately
0C46B 60                        ExXMP:   rts                       ;and we are done here
0C46C                           
0C46C                           ;--------------------------------
0C46C                           
0C46C                           DropPlatform:
0C46C BD A2 03                         lda PlatformCollisionFlag,x  ;if no collision between platform and player
0C46F 30 06                            bmi ExDPl                    ;occurred, just leave without moving anything
0C471 20 A9 AC                         jsr MoveDropPlatform         ;otherwise do a sub to move platform down very quickly
0C474 20 AA CA                         jsr PositionPlayerOnVPlat    ;do a sub to position player appropriately
0C477 60                        ExDPl: rts                          ;leave
0C478                           
0C478                           ;--------------------------------
0C478                           ;$00 - residual value from sub
0C478                           
0C478                           RightPlatform:
0C478 20 23 AC                         jsr MoveEnemyHorizontally     ;move platform with current horizontal speed, if any
0C47B 85 00                            sta $00                       ;store saved value here (residual code)
0C47D BD A2 03                         lda PlatformCollisionFlag,x   ;check collision flag, if no collision between player
0C480 30 07                            bmi ExRPl                     ;and platform, branch ahead, leave speed unaltered
0C482 A9 10                            lda #$10
0C484 95 58                            sta Enemy_X_Speed,x           ;otherwise set new speed (gets moving if motionless)
0C486 20 4F C4                         jsr PositionPlayerOnHPlat     ;use saved value from earlier sub to position player
0C489 60                        ExRPl: rts                           ;then leave
0C48A                           
0C48A                           ;--------------------------------
0C48A                           
0C48A                           MoveLargeLiftPlat:
0C48A 20 96 C4                        jsr MoveLiftPlatforms  ;execute common to all large and small lift platforms
0C48D 4C 39 C4                        jmp ChkYPCollision     ;branch to position player correctly
0C490                           
0C490                           MoveSmallPlatform:
0C490 20 96 C4                        jsr MoveLiftPlatforms      ;execute common to all large and small lift platforms
0C493 4C AC C4                        jmp ChkSmallPlatCollision  ;branch to position player correctly
0C496                           
0C496                           MoveLiftPlatforms:
0C496 AD 47 07                        lda TimerControl         ;if master timer control set, skip all of this
0C499 D0 19                           bne ExLiftP              ;and branch to leave
0C49B BD 17 04                        lda Enemy_YMF_Dummy,x
0C49E 18                              clc                      ;add contents of movement amount to whatever's here
0C49F 7D 34 04                        adc Enemy_Y_MoveForce,x
0C4A2 9D 17 04                        sta Enemy_YMF_Dummy,x
0C4A5 B5 CF                           lda Enemy_Y_Position,x   ;add whatever vertical speed is set to current
0C4A7 75 A0                           adc Enemy_Y_Speed,x      ;vertical position plus carry to move up or down
0C4A9 95 CF                           sta Enemy_Y_Position,x   ;and then leave
0C4AB 60                              rts
0C4AC                           
0C4AC                           ChkSmallPlatCollision:
0C4AC BD A2 03                           lda PlatformCollisionFlag,x ;get bounding box counter saved in collision flag
0C4AF F0 03                              beq ExLiftP                 ;if none found, leave player position alone
0C4B1 20 A2 CA                           jsr PositionPlayerOnS_Plat  ;use to position player correctly
0C4B4 60                        ExLiftP: rts                         ;then leave
0C4B5                           
0C4B5                           ;-------------------------------------------------------------------------------------
0C4B5                           ;$00 - page location of extended left boundary
0C4B5                           ;$01 - extended left boundary position
0C4B5                           ;$02 - page location of extended right boundary
0C4B5                           ;$03 - extended right boundary position
0C4B5                           
0C4B5                           OffscreenBoundsCheck:
0C4B5 B5 16                               lda Enemy_ID,x          ;check for cheep-cheep object
0C4B7 C9 14                               cmp #FlyingCheepCheep   ;branch to leave if found
0C4B9 F0 5D                               beq ExScrnBd
0C4BB AD 1C 07                            lda ScreenLeft_X_Pos    ;get horizontal coordinate for left side of screen
0C4BE B4 16                               ldy Enemy_ID,x
0C4C0 C0 05                               cpy #HammerBro          ;check for hammer bro object
0C4C2 F0 08                               beq LimitB
0C4C4 C0 04                               cpy #UpsideDownPiranhaP ;check for upside-down piranha plant object
0C4C6 F0 04                               beq LimitB
0C4C8 C0 0D                               cpy #PiranhaPlant       ;check for piranha plant object
0C4CA D0 02                               bne ExtendLB            ;these three will be erased sooner than others if too far left
0C4CC 69 38                     LimitB:   adc #$38                ;add 56 pixels to coordinate if hammer bro or piranha plant
0C4CE E9 48                     ExtendLB: sbc #$48                ;subtract 72 pixels regardless of enemy object
0C4D0 85 01                               sta $01                 ;store result here
0C4D2 AD 1A 07                            lda ScreenLeft_PageLoc
0C4D5 E9 00                               sbc #$00                ;subtract borrow from page location of left side
0C4D7 85 00                               sta $00                 ;store result here
0C4D9 AD 1D 07                            lda ScreenRight_X_Pos   ;add 72 pixels to the right side horizontal coordinate
0C4DC 69 48                               adc #$48
0C4DE 85 03                               sta $03                 ;store result here
0C4E0 AD 1B 07                            lda ScreenRight_PageLoc     
0C4E3 69 00                               adc #$00                ;then add the carry to the page location
0C4E5 85 02                               sta $02                 ;and store result here
0C4E7 B5 87                               lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
0C4E9 C5 01                               cmp $01                 ;to modified horizontal left edge coordinate to get carry
0C4EB B5 6E                               lda Enemy_PageLoc,x
0C4ED E5 00                               sbc $00                 ;then subtract it from the page coordinate of the enemy object
0C4EF 30 24                               bmi TooFar              ;if enemy object is too far left, branch to erase it
0C4F1 B5 87                               lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
0C4F3 C5 03                               cmp $03                 ;to modified horizontal right edge coordinate to get carry
0C4F5 B5 6E                               lda Enemy_PageLoc,x
0C4F7 E5 02                               sbc $02                 ;then subtract it from the page coordinate of the enemy object
0C4F9 30 1D                               bmi ExScrnBd            ;if enemy object is on the screen, leave, do not erase enemy
0C4FB B5 1E                               lda Enemy_State,x       ;if at this point, enemy is offscreen to the right, so check
0C4FD C9 05                               cmp #HammerBro          ;if in state used by spiny's egg, do not erase
0C4FF F0 17                               beq ExScrnBd
0C501 C0 0D                               cpy #PiranhaPlant       ;if piranha plant, do not erase
0C503 F0 13                               beq ExScrnBd
0C505 C0 04                               cpy #UpsideDownPiranhaP ;if upside-down piranha plant, do not erase
0C507 F0 0F                               beq ExScrnBd
0C509 C0 30                               cpy #FlagpoleFlagObject ;if flagpole flag, do not erase
0C50B F0 0B                               beq ExScrnBd
0C50D C0 31                               cpy #StarFlagObject     ;if star flag, do not erase
0C50F F0 07                               beq ExScrnBd
0C511 C0 32                               cpy #JumpspringObject   ;if jumpspring, do not erase
0C513 F0 03                               beq ExScrnBd            ;erase all others too far to the right
0C515 20 B1 B7                  TooFar:   jsr EraseEnemyObject    ;erase object if necessary
0C518 60                        ExScrnBd: rts                     ;leave
0C519                           
0C519                           ;-------------------------------------------------------------------------------------
0C519                           ;$01 - enemy buffer offset
0C519                           
0C519                           FireballEnemyCollision:
0C519 B5 24                           lda Fireball_State,x  ;check to see if fireball state is set at all
0C51B F0 56                           beq ExitFBallEnemy    ;branch to leave if not
0C51D 0A                              asl
0C51E B0 53                           bcs ExitFBallEnemy    ;branch to leave also if d7 in state is set
0C520 A5 09                           lda FrameCounter
0C522 4A                              lsr                   ;get LSB of frame counter
0C523 B0 4E                           bcs ExitFBallEnemy    ;branch to leave if set (do routine every other frame)
0C525 8A                              txa
0C526 0A                              asl                   ;multiply fireball offset by four
0C527 0A                              asl
0C528 18                              clc
0C529 69 1C                           adc #$1c              ;then add $1c or 28 bytes to it
0C52B A8                              tay                   ;to use fireball's bounding box coordinates 
0C52C A2 04                           ldx #$04
0C52E                           
0C52E                           FireballEnemyCDLoop:
0C52E 86 01                                stx $01                     ;store enemy object offset here
0C530 98                                   tya
0C531 48                                   pha                         ;push fireball offset to the stack
0C532 B5 1E                                lda Enemy_State,x
0C534 29 20                                and #%00100000              ;check to see if d5 is set in enemy state
0C536 D0 34                                bne NoFToECol               ;if so, skip to next enemy slot
0C538 B5 0F                                lda Enemy_Flag,x            ;check to see if buffer flag is set
0C53A F0 30                                beq NoFToECol               ;if not, skip to next enemy slot
0C53C B5 16                                lda Enemy_ID,x              ;check enemy identifier
0C53E C9 24                                cmp #$24
0C540 90 04                                bcc GoombaDie               ;if < $24, branch to check further
0C542 C9 2B                                cmp #$2b
0C544 90 26                                bcc NoFToECol               ;if in range $24-$2a, skip to next enemy slot
0C546 C9 06                     GoombaDie: cmp #Goomba                 ;check for goomba identifier
0C548 D0 06                                bne NotGoomba               ;if not found, continue with code
0C54A B5 1E                                lda Enemy_State,x           ;otherwise check for defeated state
0C54C C9 02                                cmp #$02                    ;if stomped or otherwise defeated,
0C54E B0 1C                                bcs NoFToECol               ;skip to next enemy slot
0C550 BD D8 03                  NotGoomba: lda EnemyOffscrBitsMasked,x ;if any masked offscreen bits set,
0C553 D0 17                                bne NoFToECol               ;skip to next enemy slot
0C555 8A                                   txa
0C556 0A                                   asl                         ;otherwise multiply enemy offset by four
0C557 0A                                   asl
0C558 18                                   clc
0C559 69 04                                adc #$04                    ;add 4 bytes to it
0C55B AA                                   tax                         ;to use enemy's bounding box coordinates
0C55C 20 DE D1                             jsr SprObjectCollisionCore  ;do fireball-to-enemy collision detection
0C55F A6 08                                ldx ObjectOffset            ;return fireball's original offset
0C561 90 09                                bcc NoFToECol               ;if carry clear, no collision, thus do next enemy slot
0C563 A9 80                                lda #%10000000
0C565 95 24                                sta Fireball_State,x        ;set d7 in enemy state
0C567 A6 01                                ldx $01                     ;get enemy offset
0C569 20 83 C5                             jsr HandleEnemyFBallCol     ;jump to handle fireball to enemy collision
0C56C 68                        NoFToECol: pla                         ;pull fireball offset from stack
0C56D A8                                   tay                         ;put it in Y
0C56E A6 01                                ldx $01                     ;get enemy object offset
0C570 CA                                   dex                         ;decrement it
0C571 10 BB                                bpl FireballEnemyCDLoop     ;loop back until collision detection done on all enemies
0C573                           
0C573                           ExitFBallEnemy:
0C573 A6 08                           ldx ObjectOffset                 ;get original fireball offset and leave
0C575 60                              rts
0C576                           
0C576                           BowserIdentities:
0C576 06 00 02 12 11 07 05 2D..       .db Goomba, GreenKoopa, BuzzyBeetle, Spiny, Lakitu, Bloober, HammerBro, Bowser, Bowser
0C57F 03 0A 33 2D                     .db RedKoopa, GreyCheepCheep, BulletBill_CannonVar, Bowser
0C583                           
0C583                           HandleEnemyFBallCol:
0C583 20 5F E0                        jsr RelativeEnemyPosition  ;get relative coordinate of enemy
0C586 A6 01                           ldx $01                    ;get current enemy object offset
0C588 B5 0F                           lda Enemy_Flag,x           ;check buffer flag for d7 set
0C58A 10 0B                           bpl ChkBuzzyBeetle         ;branch if not set to continue
0C58C 29 0F                           and #%00001111             ;otherwise mask out high nybble and
0C58E AA                              tax                        ;use low nybble as enemy offset
0C58F B5 16                           lda Enemy_ID,x
0C591 C9 2D                           cmp #Bowser                ;check enemy identifier for bowser
0C593 F0 0C                           beq HurtBowser             ;branch if found
0C595 A6 01                           ldx $01                    ;otherwise retrieve current enemy offset
0C597                           
0C597                           ChkBuzzyBeetle:
0C597 B5 16                           lda Enemy_ID,x
0C599 C9 02                           cmp #BuzzyBeetle           ;check for buzzy beetle
0C59B F0 76                           beq ExHCF                  ;branch if found to leave (buzzy beetles fireproof)
0C59D C9 2D                           cmp #Bowser                ;check for bowser one more time (necessary if d7 of flag was clear)
0C59F D0 2D                           bne ChkOtherEnemies        ;if not found, branch to check other enemies
0C5A1                           
0C5A1                           HurtBowser:
0C5A1 CE 83 04                            dec BowserHitPoints        ;decrement bowser's hit points
0C5A4 D0 6D                               bne ExHCF                  ;if bowser still has hit points, branch to leave
0C5A6 20 4F B1                            jsr InitVStf               ;otherwise do sub to init vertical speed and movement force
0C5A9 95 58                               sta Enemy_X_Speed,x        ;initialize horizontal speed
0C5AB 8D CB 06                            sta EnemyFrenzyBuffer      ;init enemy frenzy buffer
0C5AE A9 FE                               lda #$fe
0C5B0 95 A0                               sta Enemy_Y_Speed,x        ;set vertical speed to make defeated bowser jump a little
0C5B2 AC 5F 07                            ldy WorldNumber            ;use world number as offset
0C5B5 B9 76 C5                            lda BowserIdentities,y     ;get enemy identifier to replace bowser with
0C5B8 95 16                               sta Enemy_ID,x             ;set as new enemy identifier
0C5BA A9 20                               lda #$20                   ;set A to use starting value for state
0C5BC C0 03                               cpy #$03                   ;check to see if using offset of 3 or more
0C5BE B0 02                               bcs SetDBSte               ;branch if so
0C5C0 09 03                               ora #$03                   ;otherwise add 3 to enemy state
0C5C2 95 1E                     SetDBSte: sta Enemy_State,x          ;set defeated enemy state
0C5C4 A9 80                               lda #Sfx_BowserFall
0C5C6 85 FE                               sta Square2SoundQueue      ;load bowser defeat sound
0C5C8 A6 01                               ldx $01                    ;get enemy offset
0C5CA A9 09                               lda #$09                   ;award 5000 points to player for defeating bowser
0C5CC D0 3E                               bne EnemySmackScore        ;unconditional branch to award points
0C5CE                           
0C5CE                           ChkOtherEnemies:
0C5CE C9 08                           cmp #BulletBill_FrenzyVar
0C5D0 F0 41                           beq ExHCF                 ;branch to leave if bullet bill (frenzy variant) 
0C5D2 C9 0C                           cmp #Podoboo       
0C5D4 F0 3D                           beq ExHCF                 ;branch to leave if podoboo
0C5D6 C9 15                           cmp #$15       
0C5D8 B0 39                           bcs ExHCF                 ;branch to leave if identifier => $15
0C5DA                           
0C5DA                           ShellOrBlockDefeat:
0C5DA B5 16                            lda Enemy_ID,x            ;check for both kinds of piranha plant
0C5DC C9 04                            cmp #UpsideDownPiranhaP
0C5DE F0 04                            beq DinP
0C5E0 C9 0D                            cmp #PiranhaPlant
0C5E2 D0 0D                            bne StnE                  ;branch if not found
0C5E4 A8                        DinP:  tay
0C5E5 B5 CF                            lda Enemy_Y_Position,x
0C5E7 69 18                            adc #$18                  ;add 24 pixels to enemy object's vertical position
0C5E9 C0 04                            cpy #UpsideDownPiranhaP   ;to put defeated piranha plant back in pipe
0C5EB D0 02                            bne SetDY
0C5ED E9 31                            sbc #$31                  ;subtract 49 pixels to vertical position to put
0C5EF 95 CF                     SetDY: sta Enemy_Y_Position,x    ;defeated upside down piranha plant back in pipe
0C5F1 20 BC CE                  StnE:  jsr ChkToStunEnemies      ;do yet another sub
0C5F4 B5 1E                            lda Enemy_State,x
0C5F6 29 1F                            and #%00011111            ;mask out 2 MSB of enemy object's state
0C5F8 09 20                            ora #%00100000            ;set d5 to defeat enemy and save as new state
0C5FA 95 1E                            sta Enemy_State,x
0C5FC A9 02                            lda #$02                  ;award 200 points by default
0C5FE B4 16                            ldy Enemy_ID,x            ;check for hammer bro
0C600 C0 05                            cpy #HammerBro
0C602 D0 02                            bne GoombaPoints          ;branch if not found
0C604 A9 06                            lda #$06                  ;award 1000 points for hammer bro
0C606                           
0C606                           GoombaPoints:
0C606 C0 06                           cpy #Goomba               ;check for goomba
0C608 D0 02                           bne EnemySmackScore       ;branch if not found
0C60A A9 01                           lda #$01                  ;award 100 points for goomba
0C60C                           
0C60C                           EnemySmackScore:
0C60C 20 7E C8                         jsr SetupFloateyNumber   ;update necessary score variables
0C60F A9 08                            lda #Sfx_EnemySmack      ;play smack enemy sound
0C611 85 FF                            sta Square1SoundQueue
0C613 60                        ExHCF: rts                      ;and now let's leave
0C614                           
0C614                           ;-------------------------------------------------------------------------------------
0C614                           
0C614                           PlayerHammerCollision:
0C614 A5 09                             lda FrameCounter          ;get frame counter
0C616 4A                                lsr                       ;shift d0 into carry
0C617 90 39                             bcc ExPHC                 ;branch to leave if d0 not set to execute every other frame
0C619 AD D0 03                          lda Player_OffscreenBits  ;if player offscreen bits, master timer control
0C61C 0D 47 07                          ora TimerControl          ;or any offscreen bits for hammer are set
0C61F 0D D6 03                          ora Misc_OffscreenBits    ;then branch to leave
0C622 D0 2E                             bne ExPHC
0C624 8A                                txa
0C625 0A                                asl                       ;multiply misc object offset by four
0C626 0A                                asl
0C627 18                                clc
0C628 69 24                             adc #$24                  ;add 36 or $24 bytes to get proper offset
0C62A A8                                tay                       ;for misc object bounding box coordinates
0C62B 20 DC D1                          jsr PlayerCollisionCore   ;do player-to-hammer collision detection
0C62E A6 08                             ldx ObjectOffset          ;get misc object offset
0C630 90 1B                             bcc ClHCol                ;if no collision, then branch
0C632 BD BE 06                          lda Misc_Collision_Flag,x ;otherwise read collision flag
0C635 D0 1B                             bne ExPHC                 ;if collision flag already set, branch to leave
0C637 A9 01                             lda #$01
0C639 9D BE 06                          sta Misc_Collision_Flag,x ;otherwise set collision flag now
0C63C B5 64                             lda Misc_X_Speed,x
0C63E 49 FF                             eor #$ff                  ;get two's compliment of
0C640 18                                clc                       ;hammer's horizontal speed
0C641 69 01                             adc #$01
0C643 95 64                             sta Misc_X_Speed,x        ;set to send hammer flying the opposite direction
0C645 AD 9F 07                          lda StarInvincibleTimer   ;if star mario invincibility timer set,
0C648 D0 08                             bne ExPHC                 ;branch to leave
0C64A 4C 8B C7                          jmp InjurePlayer          ;otherwise jump to hurt player, do not return
0C64D A9 00                     ClHCol: lda #$00                  ;clear collision flag
0C64F 9D BE 06                          sta Misc_Collision_Flag,x
0C652 60                        ExPHC:  rts
0C653                           
0C653                           ;-------------------------------------------------------------------------------------
0C653                           
0C653                           HandlePowerUpCollision:
0C653 20 B1 B7                        jsr EraseEnemyObject    ;erase the power-up object
0C656 A5 39                           lda PowerUpType
0C658 C9 04                           cmp #$04                ;check power-up type
0C65A D0 03                           bne Safe                ;if not a poison shroom, branch
0C65C 4C 8B C7                        jmp InjurePlayer        ;otherwise injure the player properly
0C65F A9 06                     Safe: lda #$06
0C661 20 7E C8                        jsr SetupFloateyNumber  ;award 1000 points to player by default
0C664 A9 20                           lda #Sfx_PowerUpGrab
0C666 85 FE                           sta Square2SoundQueue   ;play the power-up sound
0C668 A5 39                           lda PowerUpType         ;check power-up type
0C66A C9 02                           cmp #$02
0C66C 90 0E                           bcc Shroom_Flower_PUp   ;if mushroom or fire flower, branch
0C66E C9 03                           cmp #$03
0C670 F0 24                           beq SetFor1Up           ;if 1-up mushroom, branch
0C672 A9 23                           lda #$23                ;otherwise set star mario invincibility
0C674 8D 9F 07                        sta StarInvincibleTimer ;timer, and load the star mario music
0C677 A9 40                           lda #StarPowerMusic     ;into the area music queue, then leave
0C679 85 FB                           sta AreaMusicQueue
0C67B 60                              rts
0C67C                           
0C67C                           Shroom_Flower_PUp:
0C67C AD 56 07                        lda PlayerStatus    ;if player status = small, branch
0C67F F0 1B                           beq UpToSuper
0C681 C9 01                           cmp #$01            ;if player status not super, leave
0C683 D0 23                           bne NoPUp
0C685 A6 08                           ldx ObjectOffset    ;get enemy offset, not necessary
0C687 A9 02                           lda #$02            ;set player status to fiery
0C689 8D 56 07                        sta PlayerStatus
0C68C 20 24 85                        jsr GetPlayerColors ;run sub to change colors of player
0C68F A6 08                           ldx ObjectOffset    ;get enemy offset again, and again not necessary
0C691 A9 0C                           lda #$0c            ;set value to be used by subroutine tree (fiery)
0C693 4C A3 C6                        jmp UpToFiery       ;jump to set values accordingly
0C696                           
0C696                           SetFor1Up:
0C696 A9 0B                           lda #$0b                 ;change 1000 points into 1-up instead
0C698 9D 10 01                        sta FloateyNum_Control,x ;and then leave
0C69B 60                              rts
0C69C                           
0C69C                           UpToSuper:
0C69C A9 01                            lda #$01         ;set player status to super
0C69E 8D 56 07                         sta PlayerStatus
0C6A1 A9 09                            lda #$09         ;set value to be used by subroutine tree (super)
0C6A3                           
0C6A3                           UpToFiery:
0C6A3 A0 00                            ldy #$00         ;set value to be used as new player state
0C6A5 20 AA C7                         jsr SetPRout     ;set values to stop certain things in motion
0C6A8 60                        NoPUp: rts
0C6A9                           
0C6A9                           ;--------------------------------
0C6A9                           
0C6A9                           ResidualXSpdData:
0C6A9 18 E8                           .db $18, $e8
0C6AB                           
0C6AB                           KickedShellXSpdData:
0C6AB 30 D0                           .db $30, $d0
0C6AD                           
0C6AD                           DemotedKoopaXSpdData:
0C6AD 08 F8                           .db $08, $f8
0C6AF                           
0C6AF                           PlayerEnemyCollision:
0C6AF A5 09                              lda FrameCounter            ;check counter for d0 set
0C6B1 4A                                 lsr
0C6B2 B0 F4                              bcs NoPUp                   ;if set, branch to leave
0C6B4 20 CA CA                           jsr CheckPlayerVertical     ;if player object is completely offscreen or
0C6B7 B0 23                              bcs NoPECol                 ;if down past 224th pixel row, branch to leave
0C6B9 BD D8 03                           lda EnemyOffscrBitsMasked,x ;if current enemy is offscreen by any amount,
0C6BC D0 1E                              bne NoPECol                 ;go ahead and branch to leave
0C6BE A5 0E                              lda GameEngineSubroutine
0C6C0 C9 08                              cmp #$08                    ;if not set to run player control routine
0C6C2 D0 18                              bne NoPECol                 ;on next frame, branch to leave
0C6C4 B5 1E                              lda Enemy_State,x
0C6C6 29 20                              and #%00100000              ;if enemy state has d5 set, branch to leave
0C6C8 D0 12                              bne NoPECol
0C6CA 20 D4 CA                           jsr GetEnemyBoundBoxOfs     ;get bounding box offset for current enemy object
0C6CD 20 DC D1                           jsr PlayerCollisionCore     ;do collision detection on player vs. enemy
0C6D0 A6 08                              ldx ObjectOffset            ;get enemy object buffer offset
0C6D2 B0 09                              bcs CheckForPUpCollision    ;if collision, branch past this part here
0C6D4 BD 91 04                           lda Enemy_CollisionBits,x
0C6D7 29 FE                              and #%11111110              ;otherwise, clear d0 of current enemy object's
0C6D9 9D 91 04                           sta Enemy_CollisionBits,x   ;collision bit
0C6DC 60                        NoPECol: rts
0C6DD                           
0C6DD                           CheckForPUpCollision:
0C6DD B4 16                            ldy Enemy_ID,x
0C6DF C0 2E                            cpy #PowerUpObject            ;check for power-up object
0C6E1 D0 03                            bne EColl                     ;if not found, branch to next part
0C6E3 4C 53 C6                         jmp HandlePowerUpCollision    ;otherwise, unconditional jump backwards
0C6E6 AD 9F 07                  EColl: lda StarInvincibleTimer       ;if star mario invincibility timer expired,
0C6E9 F0 06                            beq HandlePECollisions        ;perform task here, otherwise kill enemy like
0C6EB 4C DA C5                         jmp ShellOrBlockDefeat        ;hit with a shell, or from beneath
0C6EE                           
0C6EE                           KickedShellPtsData:
0C6EE 0A 06 04                        .db $0a, $06, $04
0C6F1                           
0C6F1                           HandlePECollisions:
0C6F1 BD 91 04                         lda Enemy_CollisionBits,x    ;check enemy collision bits for d0 set
0C6F4 29 01                            and #%00000001               ;or for being offscreen at all
0C6F6 1D D8 03                         ora EnemyOffscrBitsMasked,x
0C6F9 D0 5D                            bne ExPEC                    ;branch to leave if either is true
0C6FB A9 01                            lda #$01
0C6FD 1D 91 04                         ora Enemy_CollisionBits,x    ;otherwise set d0 now
0C700 9D 91 04                         sta Enemy_CollisionBits,x
0C703 C0 12                            cpy #Spiny                   ;branch if spiny
0C705 F0 52                            beq ChkForPlayerInjury
0C707 C0 33                            cpy #BulletBill_CannonVar    ;branch if bullet bill
0C709 F0 4E                            beq ChkForPlayerInjury
0C70B C0 0D                            cpy #PiranhaPlant            ;branch if piranha plant
0C70D F0 7C                            beq InjurePlayer
0C70F C0 04                            cpy #UpsideDownPiranhaP      ;branch if upside-down piranha plant
0C711 F0 78                            beq InjurePlayer
0C713 C0 0C                            cpy #Podoboo                 ;branch if podoboo
0C715 F0 74                            beq InjurePlayer
0C717 C0 15                            cpy #$15                     ;branch if object => $15
0C719 B0 70                            bcs InjurePlayer
0C71B AD 4E 07                         lda AreaType                 ;branch if water type level
0C71E F0 6B                            beq InjurePlayer
0C720 B5 1E                            lda Enemy_State,x            ;branch if d7 of enemy state was set
0C722 0A                               asl
0C723 B0 34                            bcs ChkForPlayerInjury
0C725 B5 1E                            lda Enemy_State,x            ;mask out all but 3 LSB of enemy state
0C727 29 07                            and #%00000111
0C729 C9 02                            cmp #$02                     ;branch if enemy is in normal or falling state
0C72B 90 2C                            bcc ChkForPlayerInjury
0C72D B5 16                            lda Enemy_ID,x               ;branch to leave if goomba in defeated state
0C72F C9 06                            cmp #Goomba
0C731 F0 25                            beq ExPEC
0C733 A9 08                            lda #Sfx_EnemySmack          ;play smack enemy sound
0C735 85 FF                            sta Square1SoundQueue
0C737 B5 1E                            lda Enemy_State,x            ;set d7 in enemy state, thus become moving shell
0C739 09 80                            ora #%10000000
0C73B 95 1E                            sta Enemy_State,x
0C73D 20 72 C8                         jsr EnemyFacePlayer          ;set moving direction and get offset
0C740 B9 AB C6                         lda KickedShellXSpdData,y    ;load and set horizontal speed data with offset
0C743 95 58                            sta Enemy_X_Speed,x
0C745 A9 03                            lda #$03                     ;add three to whatever the stomp counter contains
0C747 18                               clc                          ;to give points for kicking the shell
0C748 6D 84 04                         adc StompChainCounter
0C74B BC 96 07                         ldy EnemyIntervalTimer,x     ;check shell enemy's timer
0C74E C0 03                            cpy #$03                     ;if above a certain point, branch using the points
0C750 B0 03                            bcs KSPts                    ;data obtained from the stomp counter + 3
0C752 B9 EE C6                         lda KickedShellPtsData,y     ;otherwise, set points based on proximity to timer expiration
0C755 20 7E C8                  KSPts: jsr SetupFloateyNumber       ;set values for floatey number now
0C758 60                        ExPEC: rts                          ;leave!!!
0C759                           
0C759                           ChkForPlayerInjury:
0C759 A4 9F                               ldy Player_Y_Speed     ;check player's vertical speed
0C75B 88                                  dey                    ;branch elsewhere if player is not moving downwards
0C75C 10 6D                               bpl EnemyStomped
0C75E B5 16                     ChkInj:   lda Enemy_ID,x         ;branch if enemy object < $07
0C760 C9 07                               cmp #Bloober
0C762 90 09                               bcc ChkETmrs
0C764 A5 CE                               lda Player_Y_Position  ;add 12 pixels to player's vertical position
0C766 18                                  clc
0C767 69 0C                               adc #$0c
0C769 D5 CF                               cmp Enemy_Y_Position,x ;compare modified player's position to enemy's position
0C76B 90 5E                               bcc EnemyStomped       ;branch if this player's position above (less than) enemy's
0C76D AD 91 07                  ChkETmrs: lda StompTimer         ;check stomp timer
0C770 D0 59                               bne EnemyStomped       ;branch if set
0C772 AD 9E 07                            lda InjuryTimer        ;check to see if injured invincibility timer still
0C775 D0 40                               bne ExInjColRoutines   ;counting down, and branch elsewhere to leave if so
0C777 AD AD 03                            lda Player_Rel_XPos
0C77A CD AE 03                            cmp Enemy_Rel_XPos     ;if player's relative position to the left of enemy's
0C77D 90 03                               bcc TInjE              ;relative position, branch here
0C77F 4C 63 C8                            jmp ChkEnemyFaceRight  ;otherwise do a jump here
0C782 B5 46                     TInjE:    lda Enemy_MovingDir,x  ;if enemy moving towards the left,
0C784 C9 01                               cmp #$01               ;branch, otherwise do a jump here
0C786 D0 03                               bne InjurePlayer       ;to turn the enemy around
0C788 4C 6C C8                            jmp LInj
0C78B                           
0C78B                           InjurePlayer:
0C78B AD 9E 07                        lda InjuryTimer          ;check again to see if either of the two
0C78E 0D 9F 07                        ora StarInvincibleTimer  ;invincibility timers have expired, branch if not
0C791 D0 24                           bne ExInjColRoutines
0C793                           
0C793                           ForceInjury:
0C793 AE 56 07                            ldx PlayerStatus          ;check player's status
0C796 F0 22                               beq KillPlayer            ;branch if small
0C798 8D 56 07                            sta PlayerStatus          ;otherwise set player's status to small
0C79B A9 08                               lda #$08
0C79D 8D 9E 07                            sta InjuryTimer           ;set injured invincibility timer
0C7A0 0A                                  asl
0C7A1 85 FF                               sta Square1SoundQueue     ;play pipedown/injury sound
0C7A3 20 24 85                            jsr GetPlayerColors       ;change player's palette if necessary
0C7A6 A9 0A                               lda #$0a                  ;set subroutine to run on next frame
0C7A8 A0 01                     SetKRout: ldy #$01                  ;set new player state
0C7AA 85 0E                     SetPRout: sta GameEngineSubroutine  ;load new value to run subroutine on next frame
0C7AC 84 1D                               sty Player_State          ;store new player state
0C7AE A0 FF                               ldy #$ff
0C7B0 8C 47 07                            sty TimerControl          ;set master timer control flag to halt timers
0C7B3 C8                                  iny
0C7B4 8C 75 07                            sty ScrollAmount          ;initialize scroll speed
0C7B7                           
0C7B7                           ExInjColRoutines:
0C7B7 A6 08                           ldx ObjectOffset              ;get enemy offset and leave
0C7B9 60                              rts
0C7BA                           
0C7BA                           KillPlayer:
0C7BA 86 57                           stx Player_X_Speed   ;halt player's horizontal movement by initializing speed
0C7BC E8                              inx
0C7BD 86 FC                           stx EventMusicQueue  ;set event music queue to death music
0C7BF A9 FC                           lda #$fc
0C7C1 85 9F                           sta Player_Y_Speed   ;set new vertical speed
0C7C3 A9 0B                           lda #$0b             ;set subroutine to run on next frame
0C7C5 D0 E1                           bne SetKRout         ;branch to set player's state and other things
0C7C7                           
0C7C7                           StompedEnemyPtsData:
0C7C7 02 06 05 06                     .db $02, $06, $05, $06
0C7CB                           
0C7CB                           EnemyStomped:
0C7CB B5 16                           lda Enemy_ID,x             ;check for spiny, branch to hurt player
0C7CD C9 12                           cmp #Spiny                 ;if found
0C7CF F0 BA                           beq InjurePlayer
0C7D1 A9 04                           lda #Sfx_EnemyStomp        ;otherwise play stomp/swim sound
0C7D3 85 FF                           sta Square1SoundQueue
0C7D5 B5 16                           lda Enemy_ID,x
0C7D7 A0 00                           ldy #$00                   ;initialize points data offset for stomped enemies
0C7D9 C9 14                           cmp #FlyingCheepCheep      ;branch for cheep-cheep
0C7DB F0 1B                           beq EnemyStompedPts
0C7DD C9 08                           cmp #BulletBill_FrenzyVar  ;branch for either bullet bill object
0C7DF F0 17                           beq EnemyStompedPts
0C7E1 C9 33                           cmp #BulletBill_CannonVar
0C7E3 F0 13                           beq EnemyStompedPts
0C7E5 C9 0C                           cmp #Podoboo               ;branch for podoboo (this branch is logically impossible
0C7E7 F0 0F                           beq EnemyStompedPts        ;for cpu to take due to earlier checking of podoboo)
0C7E9 C8                              iny                        ;increment points data offset
0C7EA C9 05                           cmp #HammerBro             ;branch for hammer bro
0C7EC F0 0A                           beq EnemyStompedPts
0C7EE C8                              iny                        ;increment points data offset
0C7EF C9 11                           cmp #Lakitu                ;branch for lakitu
0C7F1 F0 05                           beq EnemyStompedPts
0C7F3 C8                              iny                        ;increment points data offset
0C7F4 C9 07                           cmp #Bloober               ;branch if NOT bloober
0C7F6 D0 1B                           bne ChkForDemoteKoopa
0C7F8                           
0C7F8                           EnemyStompedPts:
0C7F8 B9 C7 C7                        lda StompedEnemyPtsData,y  ;load points data using offset in Y
0C7FB 20 7E C8                        jsr SetupFloateyNumber     ;run sub to set floatey number controls
0C7FE B5 46                           lda Enemy_MovingDir,x
0C800 48                              pha                        ;save enemy movement direction to stack
0C801 20 DA CE                        jsr NoDemote               ;run sub to kill enemy
0C804 68                              pla
0C805 95 46                           sta Enemy_MovingDir,x      ;return enemy movement direction from stack
0C807 A9 20                           lda #%00100000
0C809 95 1E                           sta Enemy_State,x          ;set d5 in enemy state
0C80B 20 4F B1                        jsr InitVStf               ;nullify vertical speed, physics-related thing,
0C80E 95 58                           sta Enemy_X_Speed,x        ;and horizontal speed
0C810 4C 52 C8                        jmp SetBounce
0C813                           
0C813                           ChkForDemoteKoopa:
0C813 C9 09                           cmp #$09                   ;branch elsewhere if enemy object < $09
0C815 90 1E                           bcc HandleStompedShellE
0C817 20 52 C8                        jsr SetBounce
0C81A 29 01                           and #%00000001             ;demote koopa paratroopas to ordinary troopas
0C81C 95 16                           sta Enemy_ID,x
0C81E A9 00                           lda #$00                   ;return enemy to normal state
0C820 95 1E                           sta Enemy_State,x
0C822 A9 03                           lda #$03                   ;award 400 points to the player
0C824 20 7E C8                        jsr SetupFloateyNumber
0C827 20 4F B1                        jsr InitVStf               ;nullify physics-related thing and vertical speed
0C82A 20 72 C8                        jsr EnemyFacePlayer        ;turn enemy around if necessary
0C82D B9 AD C6                        lda DemotedKoopaXSpdData,y
0C830 95 58                           sta Enemy_X_Speed,x        ;set appropriate moving speed based on direction
0C832 60                              rts
0C833                           
0C833                           RevivalRateData:
0C833 10 0B                           .db $10, $0b
0C835                           
0C835                           HandleStompedShellE:
0C835 A9 04                            lda #$04                   ;set defeated state for enemy
0C837 95 1E                            sta Enemy_State,x
0C839 EE 84 04                         inc StompChainCounter      ;increment the stomp counter
0C83C AD 84 04                         lda StompChainCounter      ;add whatever is in the stomp counter
0C83F 18                               clc                        ;to whatever is in the stomp timer
0C840 6D 91 07                         adc StompTimer
0C843 20 7E C8                         jsr SetupFloateyNumber     ;award points accordingly
0C846 EE 91 07                         inc StompTimer             ;increment stomp timer of some sort
0C849 AC 6A 07                         ldy PrimaryHardMode        ;check primary hard mode flag
0C84C B9 33 C8                         lda RevivalRateData,y      ;load timer setting according to flag
0C84F 9D 96 07                         sta EnemyIntervalTimer,x   ;set as enemy timer to revive stomped enemy
0C852                           SetBounce:
0C852 A0 FA                            ldy #$fa                   ;set a regular bounce rate for all other enemies
0C854 B5 16                            lda Enemy_ID,x
0C856 C9 0F                            cmp #RedParatroopa         ;set a higher bounce rate for red paratroopas
0C858 F0 04                            beq BnceH                  ;and green paratroopas that fly
0C85A C9 10                            cmp #GreenParatroopaFly
0C85C D0 02                            bne BnceL
0C85E A0 F8                     BnceH: ldy #$f8                   ;set player's vertical speed for bounce
0C860 84 9F                     BnceL: sty Player_Y_Speed         ;and then leave!!!
0C862 60                               rts
0C863                           
0C863                           ChkEnemyFaceRight:
0C863 B5 46                            lda Enemy_MovingDir,x ;check to see if enemy is moving to the right
0C865 C9 01                            cmp #$01
0C867 D0 03                            bne LInj              ;if not, branch
0C869 4C 8B C7                         jmp InjurePlayer      ;otherwise go back to hurt player
0C86C 20 91 C9                  LInj:  jsr EnemyTurnAround   ;turn the enemy around, if necessary
0C86F 4C 8B C7                         jmp InjurePlayer      ;go back to hurt player
0C872                           
0C872                           EnemyFacePlayer:
0C872 A0 01                            ldy #$01               ;set to move right by default
0C874 20 F2 CF                         jsr PlayerEnemyDiff    ;get horizontal difference between player and enemy
0C877 10 01                            bpl SFcRt              ;if enemy is to the right of player, do not increment
0C879 C8                               iny                    ;otherwise, increment to set to move to the left
0C87A 94 46                     SFcRt: sty Enemy_MovingDir,x  ;set moving direction here
0C87C 88                               dey                    ;then decrement to use as a proper offset
0C87D 60                               rts
0C87E                           
0C87E                           SetupFloateyNumber:
0C87E 9D 10 01                         sta FloateyNum_Control,x ;set number of points control for floatey numbers
0C881 A9 30                            lda #$30
0C883 9D 2C 01                         sta FloateyNum_Timer,x   ;set timer for floatey numbers
0C886 B5 CF                            lda Enemy_Y_Position,x
0C888 9D 1E 01                         sta FloateyNum_Y_Pos,x   ;set vertical coordinate
0C88B AD AE 03                         lda Enemy_Rel_XPos
0C88E 9D 17 01                         sta FloateyNum_X_Pos,x   ;set horizontal coordinate and leave
0C891 60                        ExSFN: rts
0C892                           
0C892                           ;-------------------------------------------------------------------------------------
0C892                           ;$01 - used to hold enemy offset for second enemy
0C892                           
0C892                           SetBitsMask:
0C892 80 40 20 10 08 04 02            .db %10000000, %01000000, %00100000, %00010000, %00001000, %00000100, %00000010
0C899                           
0C899                           ClearBitsMask:
0C899 7F BF DF EF F7 FB FD            .db %01111111, %10111111, %11011111, %11101111, %11110111, %11111011, %11111101
0C8A0                           
0C8A0                           EnemiesCollision:
0C8A0 A5 09                             lda FrameCounter            ;check counter for d0 set
0C8A2 4A                                lsr
0C8A3 90 EC                             bcc ExSFN                   ;if d0 not set, leave
0C8A5 AD 4E 07                          lda AreaType
0C8A8 F0 E7                             beq ExSFN                   ;if water area type, leave
0C8AA B5 16                             lda Enemy_ID,x
0C8AC C9 15                             cmp #$15                    ;if enemy object => $15, branch to leave
0C8AE B0 76                             bcs ExitECRoutine
0C8B0 C9 11                             cmp #Lakitu                 ;if lakitu, branch to leave
0C8B2 F0 72                             beq ExitECRoutine
0C8B4 C9 0D                             cmp #PiranhaPlant           ;if piranha plant, branch to leave
0C8B6 F0 6E                             beq ExitECRoutine
0C8B8 C9 04                             cmp #UpsideDownPiranhaP     ;if upside-down piranha plant, branch to leave
0C8BA F0 6A                             beq ExitECRoutine
0C8BC BD D8 03                          lda EnemyOffscrBitsMasked,x ;if masked offscreen bits nonzero, branch to leave
0C8BF D0 65                             bne ExitECRoutine
0C8C1 20 D4 CA                          jsr GetEnemyBoundBoxOfs     ;otherwise, do sub, get appropriate bounding box offset for
0C8C4 CA                                dex                         ;first enemy we're going to compare, then decrement for second
0C8C5 30 5F                             bmi ExitECRoutine           ;branch to leave if there are no other enemies
0C8C7 86 01                     ECLoop: stx $01                     ;save enemy object buffer offset for second enemy here
0C8C9 98                                tya                         ;save first enemy's bounding box offset to stack
0C8CA 48                                pha
0C8CB B5 0F                             lda Enemy_Flag,x            ;check enemy object enable flag
0C8CD F0 50                             beq ReadyNextEnemy          ;branch if flag not set
0C8CF B5 16                             lda Enemy_ID,x
0C8D1 C9 15                             cmp #$15                    ;check for enemy object => $15
0C8D3 B0 4A                             bcs ReadyNextEnemy          ;branch if true
0C8D5 C9 11                             cmp #Lakitu
0C8D7 F0 46                             beq ReadyNextEnemy          ;branch if enemy object is lakitu
0C8D9 C9 0D                             cmp #PiranhaPlant
0C8DB F0 42                             beq ReadyNextEnemy          ;branch if enemy object is piranha plant
0C8DD C9 04                             cmp #UpsideDownPiranhaP
0C8DF F0 3E                             beq ReadyNextEnemy          ;branch if enemy object is upside-down piranha plant
0C8E1 BD D8 03                          lda EnemyOffscrBitsMasked,x
0C8E4 D0 39                             bne ReadyNextEnemy          ;branch if masked offscreen bits set
0C8E6 8A                                txa                         ;get second enemy object's bounding box offset
0C8E7 0A                                asl                         ;multiply by four, then add four
0C8E8 0A                                asl
0C8E9 18                                clc
0C8EA 69 04                             adc #$04
0C8EC AA                                tax                         ;use as new contents of X
0C8ED 20 DE D1                          jsr SprObjectCollisionCore  ;do collision detection using the two enemies here
0C8F0 A6 08                             ldx ObjectOffset            ;use first enemy offset for X
0C8F2 A4 01                             ldy $01                     ;use second enemy offset for Y
0C8F4 90 20                             bcc NoEnemyCollision        ;if carry clear, no collision, branch ahead of this
0C8F6 B5 1E                             lda Enemy_State,x
0C8F8 19 1E 00                          ora Enemy_State,y           ;check both enemy states for d7 set
0C8FB 29 80                             and #%10000000
0C8FD D0 11                             bne YesEC                   ;branch if at least one of them is set
0C8FF B9 91 04                          lda Enemy_CollisionBits,y   ;load first enemy's collision-related bits
0C902 3D 92 C8                          and SetBitsMask,x           ;check to see if bit connected to second enemy is
0C905 D0 18                             bne ReadyNextEnemy          ;already set, and move onto next enemy slot if set
0C907 B9 91 04                          lda Enemy_CollisionBits,y
0C90A 1D 92 C8                          ora SetBitsMask,x           ;if the bit is not set, set it now
0C90D 99 91 04                          sta Enemy_CollisionBits,y
0C910 20 29 C9                  YesEC:  jsr ProcEnemyCollisions     ;react according to the nature of collision
0C913 4C 1F C9                          jmp ReadyNextEnemy          ;move onto next enemy slot
0C916                           
0C916                           NoEnemyCollision:
0C916 B9 91 04                        lda Enemy_CollisionBits,y     ;load first enemy's collision-related bits
0C919 3D 99 C8                        and ClearBitsMask,x           ;clear bit connected to second enemy
0C91C 99 91 04                        sta Enemy_CollisionBits,y     ;then move onto next enemy slot
0C91F                           
0C91F                           ReadyNextEnemy:
0C91F 68                              pla              ;get first enemy's bounding box offset from the stack
0C920 A8                              tay              ;use as Y again
0C921 A6 01                           ldx $01          ;get and decrement second enemy's object buffer offset
0C923 CA                              dex
0C924 10 A1                           bpl ECLoop       ;loop until all enemy slots have been checked
0C926                           
0C926                           ExitECRoutine:
0C926 A6 08                           ldx ObjectOffset ;get enemy object buffer offset
0C928 60                              rts              ;leave
0C929                           
0C929                           ProcEnemyCollisions:
0C929 B9 1E 00                        lda Enemy_State,y        ;check both enemy states for d5 set
0C92C 15 1E                           ora Enemy_State,x
0C92E 29 20                           and #%00100000           ;if d5 is set in either state, or both, branch
0C930 D0 33                           bne ExitProcessEColl     ;to leave and do nothing else at this point
0C932 B5 1E                           lda Enemy_State,x
0C934 C9 06                           cmp #$06                 ;if second enemy state < $06, branch elsewhere
0C936 90 2E                           bcc ProcSecondEnemyColl
0C938 B5 16                           lda Enemy_ID,x           ;check second enemy identifier for hammer bro
0C93A C9 05                           cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
0C93C F0 27                           beq ExitProcessEColl
0C93E B9 1E 00                        lda Enemy_State,y        ;check first enemy state for d7 set
0C941 0A                              asl
0C942 90 0A                           bcc ShellCollisions      ;branch if d7 is clear
0C944 A9 06                           lda #$06
0C946 20 7E C8                        jsr SetupFloateyNumber   ;award 1000 points for killing enemy
0C949 20 DA C5                        jsr ShellOrBlockDefeat   ;then kill enemy, then load
0C94C A4 01                           ldy $01                  ;original offset of second enemy
0C94E                           
0C94E                           ShellCollisions:
0C94E 98                              tya                      ;move Y to X
0C94F AA                              tax
0C950 20 DA C5                        jsr ShellOrBlockDefeat   ;kill second enemy
0C953 A6 08                           ldx ObjectOffset
0C955 BD 25 01                        lda ShellChainCounter,x  ;get chain counter for shell
0C958 18                              clc
0C959 69 04                           adc #$04                 ;add four to get appropriate point offset
0C95B A6 01                           ldx $01
0C95D 20 7E C8                        jsr SetupFloateyNumber   ;award appropriate number of points for second enemy
0C960 A6 08                           ldx ObjectOffset         ;load original offset of first enemy
0C962 FE 25 01                        inc ShellChainCounter,x  ;increment chain counter for additional enemies
0C965                           
0C965                           ExitProcessEColl:
0C965 60                              rts                      ;leave!!!
0C966                           
0C966                           ProcSecondEnemyColl:
0C966 B9 1E 00                        lda Enemy_State,y        ;if first enemy state < $06, branch elsewhere
0C969 C9 06                           cmp #$06
0C96B 90 1D                           bcc MoveEOfs
0C96D B9 16 00                        lda Enemy_ID,y           ;check first enemy identifier for hammer bro
0C970 C9 05                           cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
0C972 F0 F1                           beq ExitProcessEColl
0C974 20 DA C5                        jsr ShellOrBlockDefeat   ;otherwise, kill first enemy
0C977 A4 01                           ldy $01
0C979 B9 25 01                        lda ShellChainCounter,y  ;get chain counter for shell
0C97C 18                              clc
0C97D 69 04                           adc #$04                 ;add four to get appropriate point offset
0C97F A6 08                           ldx ObjectOffset
0C981 20 7E C8                        jsr SetupFloateyNumber   ;award appropriate number of points for first enemy
0C984 A6 01                           ldx $01                  ;load original offset of second enemy
0C986 FE 25 01                        inc ShellChainCounter,x  ;increment chain counter for additional enemies
0C989 60                              rts                      ;leave!!!
0C98A                           
0C98A                           MoveEOfs:
0C98A 98                              tya                      ;move Y ($01) to X
0C98B AA                              tax
0C98C 20 91 C9                        jsr EnemyTurnAround      ;do the sub here using value from $01
0C98F A6 08                           ldx ObjectOffset         ;then do it again using value from $08
0C991                           
0C991                           EnemyTurnAround:
0C991 B5 16                            lda Enemy_ID,x           ;check for specific enemies
0C993 C9 0D                            cmp #PiranhaPlant
0C995 F0 26                            beq ExTA                 ;if piranha plant, leave
0C997 C9 04                            cmp #UpsideDownPiranhaP
0C999 F0 22                            beq ExTA                 ;if upside-down piranha plant, leave
0C99B C9 11                            cmp #Lakitu
0C99D F0 1E                            beq ExTA                 ;if lakitu, leave
0C99F C9 05                            cmp #HammerBro
0C9A1 F0 1A                            beq ExTA                 ;if hammer bro, leave
0C9A3 C9 12                            cmp #Spiny
0C9A5 F0 08                            beq RXSpd                ;if spiny, turn it around
0C9A7 C9 0E                            cmp #GreenParatroopaJump
0C9A9 F0 04                            beq RXSpd                ;if green paratroopa, turn it around
0C9AB C9 07                            cmp #$07
0C9AD B0 0E                            bcs ExTA                 ;if any OTHER enemy object => $07, leave
0C9AF B5 58                     RXSpd: lda Enemy_X_Speed,x      ;load horizontal speed
0C9B1 49 FF                            eor #$ff                 ;get two's compliment for horizontal speed
0C9B3 A8                               tay
0C9B4 C8                               iny
0C9B5 94 58                            sty Enemy_X_Speed,x      ;store as new horizontal speed
0C9B7 B5 46                            lda Enemy_MovingDir,x
0C9B9 49 03                            eor #%00000011           ;invert moving direction and store, then leave
0C9BB 95 46                            sta Enemy_MovingDir,x    ;thus effectively turning the enemy around
0C9BD 60                        ExTA:  rts                      ;leave!!!
0C9BE                           
0C9BE                           ;-------------------------------------------------------------------------------------
0C9BE                           ;$00 - vertical position of platform
0C9BE                           
0C9BE                           LargePlatformCollision:
0C9BE A9 FF                            lda #$ff                     ;save value here
0C9C0 9D A2 03                         sta PlatformCollisionFlag,x
0C9C3 AD 47 07                         lda TimerControl             ;check master timer control
0C9C6 D0 29                            bne ExLPC                    ;if set, branch to leave
0C9C8 B5 1E                            lda Enemy_State,x            ;if d7 set in object state,
0C9CA 30 25                            bmi ExLPC                    ;branch to leave
0C9CC B5 16                            lda Enemy_ID,x
0C9CE C9 24                            cmp #$24                     ;check enemy object identifier for
0C9D0 D0 06                            bne ChkForPlayerC_LargeP     ;balance platform, branch if not found
0C9D2 B5 1E                            lda Enemy_State,x
0C9D4 AA                               tax                          ;set state as enemy offset here
0C9D5 20 D8 C9                         jsr ChkForPlayerC_LargeP     ;perform code with state offset, then original offset, in X
0C9D8                           
0C9D8                           ChkForPlayerC_LargeP:
0C9D8 20 CA CA                         jsr CheckPlayerVertical      ;figure out if player is below a certain point
0C9DB B0 14                            bcs ExLPC                    ;or offscreen, branch to leave if true
0C9DD 8A                               txa
0C9DE 20 D6 CA                         jsr GetEnemyBoundBoxOfsArg   ;get bounding box offset in Y
0C9E1 B5 CF                            lda Enemy_Y_Position,x       ;store vertical coordinate in
0C9E3 85 00                            sta $00                      ;temp variable for now
0C9E5 8A                               txa                          ;send offset we're on to the stack
0C9E6 48                               pha
0C9E7 20 DC D1                         jsr PlayerCollisionCore      ;do player-to-platform collision detection
0C9EA 68                               pla                          ;retrieve offset from the stack
0C9EB AA                               tax
0C9EC 90 03                            bcc ExLPC                    ;if no collision, branch to leave
0C9EE 20 35 CA                         jsr ProcLPlatCollisions      ;otherwise collision, perform sub
0C9F1 A6 08                     ExLPC: ldx ObjectOffset             ;get enemy object buffer offset and leave
0C9F3 60                               rts
0C9F4                           
0C9F4                           ;--------------------------------
0C9F4                           ;$00 - counter for bounding boxes
0C9F4                           
0C9F4                           SmallPlatformCollision:
0C9F4 AD 47 07                        lda TimerControl             ;if master timer control set,
0C9F7 D0 37                           bne ExSPC                    ;branch to leave
0C9F9 9D A2 03                        sta PlatformCollisionFlag,x  ;otherwise initialize collision flag
0C9FC 20 CA CA                        jsr CheckPlayerVertical      ;do a sub to see if player is below a certain point
0C9FF B0 2F                           bcs ExSPC                    ;or entirely offscreen, and branch to leave if true
0CA01 A9 02                           lda #$02
0CA03 85 00                           sta $00                      ;load counter here for 2 bounding boxes
0CA05                           
0CA05                           ChkSmallPlatLoop:
0CA05 A6 08                           ldx ObjectOffset           ;get enemy object offset
0CA07 20 D4 CA                        jsr GetEnemyBoundBoxOfs    ;get bounding box offset in Y
0CA0A 29 02                           and #%00000010             ;if d1 of offscreen lower nybble bits was set
0CA0C D0 22                           bne ExSPC                  ;then branch to leave
0CA0E B9 AD 04                        lda BoundingBox_UL_YPos,y  ;check top of platform's bounding box for being
0CA11 C9 20                           cmp #$20                   ;above a specific point
0CA13 90 05                           bcc MoveBoundBox           ;if so, branch, don't do collision detection
0CA15 20 DC D1                        jsr PlayerCollisionCore    ;otherwise, perform player-to-platform collision detection
0CA18 B0 19                           bcs ProcSPlatCollisions    ;skip ahead if collision
0CA1A                           
0CA1A                           MoveBoundBox:
0CA1A B9 AD 04                         lda BoundingBox_UL_YPos,y  ;move bounding box vertical coordinates
0CA1D 18                               clc                        ;128 pixels downwards
0CA1E 69 80                            adc #$80
0CA20 99 AD 04                         sta BoundingBox_UL_YPos,y
0CA23 B9 AF 04                         lda BoundingBox_DR_YPos,y
0CA26 18                               clc
0CA27 69 80                            adc #$80
0CA29 99 AF 04                         sta BoundingBox_DR_YPos,y
0CA2C C6 00                            dec $00                    ;decrement counter we set earlier
0CA2E D0 D5                            bne ChkSmallPlatLoop       ;loop back until both bounding boxes are checked
0CA30 A6 08                     ExSPC: ldx ObjectOffset           ;get enemy object buffer offset, then leave
0CA32 60                               rts
0CA33                           
0CA33                           ;--------------------------------
0CA33                           
0CA33                           ProcSPlatCollisions:
0CA33 A6 08                           ldx ObjectOffset             ;return enemy object buffer offset to X, then continue
0CA35                           
0CA35                           ProcLPlatCollisions:
0CA35 B9 AF 04                        lda BoundingBox_DR_YPos,y    ;get difference by subtracting the top
0CA38 38                              sec                          ;of the player's bounding box from the bottom
0CA39 ED AD 04                        sbc BoundingBox_UL_YPos      ;of the platform's bounding box
0CA3C C9 04                           cmp #$04                     ;if difference too large or negative,
0CA3E B0 08                           bcs ChkForTopCollision       ;branch, do not alter vertical speed of player
0CA40 A5 9F                           lda Player_Y_Speed           ;check to see if player's vertical speed is moving down
0CA42 10 04                           bpl ChkForTopCollision       ;if so, don't mess with it
0CA44 A9 01                           lda #$01                     ;otherwise, set vertical
0CA46 85 9F                           sta Player_Y_Speed           ;speed of player to kill jump
0CA48                           
0CA48                           ChkForTopCollision:
0CA48 AD AF 04                        lda BoundingBox_DR_YPos      ;get difference by subtracting the top
0CA4B 38                              sec                          ;of the platform's bounding box from the bottom
0CA4C F9 AD 04                        sbc BoundingBox_UL_YPos,y    ;of the player's bounding box
0CA4F C9 06                           cmp #$06
0CA51 B0 2B                           bcs PlatformSideCollisions   ;if difference not close enough, skip all of this
0CA53 A5 9F                           lda Player_Y_Speed
0CA55 30 27                           bmi PlatformSideCollisions   ;if player's vertical speed moving upwards, skip this
0CA57 A5 00                           lda $00                      ;get saved bounding box counter from earlier
0CA59 B4 16                           ldy Enemy_ID,x
0CA5B C0 2B                           cpy #$2b                     ;if either of the two small platform objects are found,
0CA5D F0 05                           beq SetCollisionFlag         ;regardless of which one, branch to use bounding box counter
0CA5F C0 2C                           cpy #$2c                     ;as contents of collision flag
0CA61 F0 01                           beq SetCollisionFlag
0CA63 8A                              txa                          ;otherwise use enemy object buffer offset
0CA64                           
0CA64                           SetCollisionFlag:
0CA64 A6 08                           ldx ObjectOffset             ;get enemy object buffer offset
0CA66 48                              pha                          ;ANN bugfix to prevent platform collisons from occuring
0CA67 A5 B5                           lda Player_Y_HighPos         ;below a certain vertical position, which prevents
0CA69 C9 01                           cmp #$01                     ;vertical screenwrapping using moving platforms
0CA6B D0 08                           bne ValidPlatformCollision
0CA6D A5 CE                           lda Player_Y_Position
0CA6F C9 DF                           cmp #$df
0CA71 90 02                           bcc ValidPlatformCollision
0CA73 68                              pla
0CA74 60                              rts
0CA75                           ValidPlatformCollision:
0CA75 68                              pla
0CA76 9D A2 03                        sta PlatformCollisionFlag,x  ;save either bounding box counter or enemy offset here
0CA79 A9 00                           lda #$00
0CA7B 85 1D                           sta Player_State             ;set player state to normal then leave
0CA7D 60                              rts
0CA7E                           
0CA7E                           PlatformSideCollisions:
0CA7E A9 01                              lda #$01                   ;set value here to indicate possible horizontal
0CA80 85 00                              sta $00                    ;collision on left side of platform
0CA82 AD AE 04                           lda BoundingBox_DR_XPos    ;get difference by subtracting platform's left edge
0CA85 38                                 sec                        ;from player's right edge
0CA86 F9 AC 04                           sbc BoundingBox_UL_XPos,y
0CA89 C9 08                              cmp #$08                   ;if difference close enough, skip all of this
0CA8B 90 0D                              bcc SideC
0CA8D E6 00                              inc $00                    ;otherwise increment value set here for right side collision
0CA8F B9 AE 04                           lda BoundingBox_DR_XPos,y  ;get difference by subtracting player's left edge
0CA92 18                                 clc                        ;from platform's right edge
0CA93 ED AC 04                           sbc BoundingBox_UL_XPos
0CA96 C9 09                              cmp #$09                   ;if difference not close enough, skip subroutine
0CA98 B0 03                              bcs NoSideC                ;and instead branch to leave (no collision)
0CA9A 20 ED CD                  SideC:   jsr ImpedePlayerMove       ;deal with horizontal collision
0CA9D A6 08                     NoSideC: ldx ObjectOffset           ;return with enemy object buffer offset
0CA9F 60                                 rts
0CAA0                           
0CAA0                           ;-------------------------------------------------------------------------------------
0CAA0                           
0CAA0                           PlayerPosSPlatData:
0CAA0 80 00                           .db $80, $00
0CAA2                           
0CAA2                           PositionPlayerOnS_Plat:
0CAA2 A8                              tay                        ;use bounding box counter saved in collision flag
0CAA3 B5 CF                           lda Enemy_Y_Position,x     ;for offset
0CAA5 18                              clc                        ;add positioning data using offset to the vertical
0CAA6 79 9F CA                        adc PlayerPosSPlatData-1,y ;coordinate
0CAA9 2C                              .db $2c                    ;BIT instruction opcode
0CAAA                           
0CAAA                           PositionPlayerOnVPlat:
0CAAA B5 CF                              lda Enemy_Y_Position,x    ;get vertical coordinate
0CAAC A4 0E                              ldy GameEngineSubroutine
0CAAE C0 0B                              cpy #$0b                  ;if certain routine being executed on this frame,
0CAB0 F0 17                              beq ExPlPos               ;skip all of this
0CAB2 B4 B6                              ldy Enemy_Y_HighPos,x
0CAB4 C0 01                              cpy #$01                  ;if vertical high byte offscreen, skip this
0CAB6 D0 11                              bne ExPlPos
0CAB8 38                                 sec                       ;subtract 32 pixels from vertical coordinate
0CAB9 E9 20                              sbc #$20                  ;for the player object's height
0CABB 85 CE                              sta Player_Y_Position     ;save as player's new vertical coordinate
0CABD 98                                 tya
0CABE E9 00                              sbc #$00                  ;subtract borrow and store as player's
0CAC0 85 B5                              sta Player_Y_HighPos      ;new vertical high byte
0CAC2 A9 00                              lda #$00
0CAC4 85 9F                              sta Player_Y_Speed        ;initialize vertical speed and low byte of force
0CAC6 8D 33 04                           sta Player_Y_MoveForce    ;and then leave
0CAC9 60                        ExPlPos: rts
0CACA                           
0CACA                           ;-------------------------------------------------------------------------------------
0CACA                           
0CACA                           CheckPlayerVertical:
0CACA AD D0 03                         lda Player_OffscreenBits  ;if player object is not offscreen
0CACD 29 F0                            and #$f0                  ;then branch with clear carry flag
0CACF 18                               clc
0CAD0 F0 01                            beq ExCPV                 ;otherwise fall through and set carry flag
0CAD2 38                               sec                       ;to symbolize that player is offscreen
0CAD3 60                        ExCPV: rts
0CAD4                           
0CAD4                           ;-------------------------------------------------------------------------------------
0CAD4                           
0CAD4                           GetEnemyBoundBoxOfs:
0CAD4 A5 08                           lda ObjectOffset         ;get enemy object buffer offset
0CAD6                           
0CAD6                           GetEnemyBoundBoxOfsArg:
0CAD6 0A                              asl                      ;multiply A by four, then add four
0CAD7 0A                              asl                      ;to skip player's bounding box
0CAD8 18                              clc
0CAD9 69 04                           adc #$04
0CADB A8                              tay                      ;send to Y
0CADC AD D1 03                        lda Enemy_OffscreenBits  ;get offscreen bits for enemy object
0CADF 29 0F                           and #%00001111           ;save low nybble
0CAE1 C9 0F                           cmp #%00001111           ;check for all bits set
0CAE3 60                              rts
0CAE4                           
0CAE4                           ;-------------------------------------------------------------------------------------
0CAE4                           ;$00-$01 - used to hold many values, essentially temp variables
0CAE4                           ;$04 - holds lower nybble of vertical coordinate from block buffer routine
0CAE4                           ;$eb - used to hold block buffer adder
0CAE4                           
0CAE4                           PlayerBGUpperExtent:
0CAE4 20 10                           .db $20, $10
0CAE6                           
0CAE6                           PlayerBGCollision:
0CAE6 AD 16 07                            lda DisableCollisionDet   ;if collision detection disabled flag set,
0CAE9 D0 2E                               bne ExPBGCol              ;branch to leave
0CAEB A5 0E                               lda GameEngineSubroutine
0CAED C9 0B                               cmp #$0b                  ;if running routine #11 or $0b
0CAEF F0 28                               beq ExPBGCol              ;branch to leave
0CAF1 C9 04                               cmp #$04
0CAF3 90 24                               bcc ExPBGCol              ;if running routines $00-$03 branch to leave
0CAF5 A9 01                               lda #$01                  ;load default player state for swimming
0CAF7 AC 04 07                            ldy SwimmingFlag          ;if swimming flag set,
0CAFA D0 0A                               bne SetPSte               ;branch ahead to set default state
0CAFC A5 1D                               lda Player_State          ;if player in normal state,
0CAFE F0 04                               beq SetFallS              ;branch to set default state for falling
0CB00 C9 03                               cmp #$03
0CB02 D0 04                               bne ChkOnScr              ;if in any other state besides climbing, skip to next part
0CB04 A9 02                     SetFallS: lda #$02                  ;load default player state for falling
0CB06 85 1D                     SetPSte:  sta Player_State          ;set whatever player state is appropriate
0CB08 A5 B5                     ChkOnScr: lda Player_Y_HighPos
0CB0A C9 01                               cmp #$01                  ;check player's vertical high byte for still on the screen
0CB0C D0 0B                               bne ExPBGCol              ;branch to leave if not
0CB0E A9 FF                               lda #$ff
0CB10 8D 90 04                            sta Player_CollisionBits  ;initialize player's collision flag
0CB13 A5 CE                               lda Player_Y_Position
0CB15 C9 CF                               cmp #$cf                  ;check player's vertical coordinate
0CB17 90 01                               bcc ChkCollSize           ;if not too close to the bottom of screen, continue
0CB19 60                        ExPBGCol: rts                       ;otherwise leave
0CB1A                           
0CB1A                           ChkCollSize:
0CB1A A0 02                              ldy #$02                    ;load default offset
0CB1C AD 14 07                           lda CrouchingFlag
0CB1F D0 0C                              bne GBBAdr                  ;if player crouching, skip ahead
0CB21 AD 54 07                           lda PlayerSize
0CB24 D0 07                              bne GBBAdr                  ;if player small, skip ahead
0CB26 88                                 dey                         ;otherwise decrement offset for big player not crouching
0CB27 AD 04 07                           lda SwimmingFlag
0CB2A D0 01                              bne GBBAdr                  ;if swimming flag set, skip ahead
0CB2C 88                                 dey                         ;otherwise decrement offset
0CB2D B9 64 D2                  GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
0CB30 85 EB                              sta $eb                     ;store value here
0CB32 A8                                 tay                         ;put value into Y, as offset for block buffer routine
0CB33 AE 54 07                           ldx PlayerSize              ;get player's size as offset
0CB36 AD 14 07                           lda CrouchingFlag
0CB39 F0 01                              beq HeadChk                 ;if player not crouching, branch ahead
0CB3B E8                                 inx                         ;otherwise increment size as offset
0CB3C A5 CE                     HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
0CB3E DD E4 CA                           cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
0CB41 90 39                              bcc DoFootCheck             ;if player is too high, skip this part
0CB43 20 A0 D2                           jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
0CB46 F0 34                              beq DoFootCheck             ;player, and branch if nothing above player's head
0CB48 20 43 CE                           jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
0CB4B B0 53                              bcs AwardTouchedCoin        ;if so, branch to some other part of code
0CB4D A4 9F                              ldy Player_Y_Speed          ;check player's vertical speed
0CB4F 10 2B                              bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
0CB51 A4 04                              ldy $04                     ;check lower nybble of vertical coordinate returned
0CB53 C0 04                              cpy #$04                    ;from collision detection routine
0CB55 90 25                              bcc DoFootCheck             ;if low nybble < 4, branch
0CB57 20 31 CE                           jsr CheckForSolidMTiles     ;check to see what player's head bumped on
0CB5A B0 10                              bcs SolidOrClimb            ;if player collided with solid metatile, branch
0CB5C AC 4E 07                           ldy AreaType                ;otherwise check area type
0CB5F F0 17                              beq NYSpd                   ;if water level, branch ahead
0CB61 AC 84 07                           ldy BlockBounceTimer        ;if block bounce timer not expired,
0CB64 D0 12                              bne NYSpd                   ;branch ahead, do not process collision
0CB66 20 FE A9                           jsr PlayerHeadCollision     ;otherwise do a sub to process collision
0CB69 4C 7C CB                           jmp DoFootCheck             ;jump ahead to skip these other parts here
0CB6C                           
0CB6C                           SolidOrClimb:
0CB6C C9 26                            cmp #$26               ;if climbing metatile,
0CB6E F0 08                            beq NYSpd              ;branch ahead and do not play sound
0CB70 C9 71                            cmp #$71               ;if residual flag balls,
0CB72 F0 04                            beq NYSpd              ;branch ahead and do not play sound
0CB74 A9 02                            lda #Sfx_Bump
0CB76 85 FF                            sta Square1SoundQueue  ;otherwise load bump sound
0CB78 A9 01                     NYSpd: lda #$01               ;set player's vertical speed to nullify
0CB7A 85 9F                            sta Player_Y_Speed     ;jump or swim
0CB7C                           
0CB7C                           DoFootCheck:
0CB7C A4 EB                           ldy $eb                    ;get block buffer adder offset
0CB7E A5 CE                           lda Player_Y_Position
0CB80 C9 CF                           cmp #$cf                   ;check to see how low player is
0CB82 B0 60                           bcs DoPlayerSideCheck      ;if player is too far down on screen, skip all of this
0CB84 20 9F D2                        jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom left of player
0CB87 20 43 CE                        jsr CheckForCoinMTiles     ;check to see if player touched coin with their left foot
0CB8A B0 14                           bcs AwardTouchedCoin       ;if so, branch to some other part of code
0CB8C 48                              pha                        ;save bottom left metatile to stack
0CB8D 20 9F D2                        jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom right of player
0CB90 85 00                           sta $00                    ;save bottom right metatile here
0CB92 68                              pla
0CB93 85 01                           sta $01                    ;pull bottom left metatile and save here
0CB95 D0 0C                           bne ChkFootMTile           ;if anything here, skip this part
0CB97 A5 00                           lda $00                    ;otherwise check for anything in bottom right metatile
0CB99 F0 49                           beq DoPlayerSideCheck      ;and skip ahead if not
0CB9B 20 43 CE                        jsr CheckForCoinMTiles     ;check to see if player touched coin with their right foot
0CB9E 90 03                           bcc ChkFootMTile           ;if not, skip unconditional jump and continue code
0CBA0                           
0CBA0                           AwardTouchedCoin:
0CBA0 4C 8B CC                        jmp HandleCoinMetatile     ;follow the code to erase coin and award to player 1 coin
0CBA3                           
0CBA3                           ChkFootMTile:
0CBA3 20 3C CE                            jsr CheckForClimbMTiles    ;check to see if player landed on climbable metatiles
0CBA6 B0 3C                               bcs DoPlayerSideCheck      ;if so, branch
0CBA8 A4 9F                               ldy Player_Y_Speed         ;check player's vertical speed
0CBAA 30 38                               bmi DoPlayerSideCheck      ;if player moving upwards, branch
0CBAC C9 C6                               cmp #$c6
0CBAE D0 03                               bne ContChk                ;if player did not touch axe, skip ahead
0CBB0 4C 94 CC                            jmp HandleAxeMetatile      ;otherwise jump to set modes of operation
0CBB3 20 56 CD                  ContChk:  jsr ChkInvisibleMTiles     ;do sub to check for hidden coin or 1-up blocks
0CBB6 F0 2C                               beq DoPlayerSideCheck      ;if either found, branch
0CBB8 AC 0E 07                            ldy JumpspringAnimCtrl     ;if jumpspring animating right now,
0CBBB D0 23                               bne InitSteP               ;branch ahead
0CBBD A4 04                               ldy $04                    ;check lower nybble of vertical coordinate returned
0CBBF C0 05                               cpy #$05                   ;from collision detection routine
0CBC1 90 07                               bcc LandPlyr               ;if lower nybble < 5, branch
0CBC3 A5 45                               lda Player_MovingDir
0CBC5 85 00                               sta $00                    ;use player's moving direction as temp variable
0CBC7 4C ED CD                            jmp ImpedePlayerMove       ;jump to impede player's movement in that direction
0CBCA 20 65 CD                  LandPlyr: jsr ChkForLandJumpSpring   ;do sub to check for jumpspring metatiles and deal with it
0CBCD A9 F0                               lda #$f0
0CBCF 25 CE                               and Player_Y_Position      ;mask out lower nybble of player's vertical position
0CBD1 85 CE                               sta Player_Y_Position      ;and store as new vertical position to land player properly
0CBD3 20 8C CD                            jsr HandlePipeEntry        ;do sub to process potential pipe entry
0CBD6 A9 00                               lda #$00
0CBD8 85 9F                               sta Player_Y_Speed         ;initialize vertical speed and fractional
0CBDA 8D 33 04                            sta Player_Y_MoveForce     ;movement force to stop player's vertical movement
0CBDD 8D 84 04                            sta StompChainCounter      ;initialize enemy stomp counter
0CBE0 A9 00                     InitSteP: lda #$00
0CBE2 85 1D                               sta Player_State           ;set player's state to normal
0CBE4                           
0CBE4                           DoPlayerSideCheck:
0CBE4 A4 EB                           ldy $eb       ;get block buffer adder offset
0CBE6 C8                              iny
0CBE7 C8                              iny           ;increment offset 2 bytes to use adders for side collisions
0CBE8 A9 02                           lda #$02      ;set value here to be used as counter
0CBEA 85 00                           sta $00
0CBEC                           
0CBEC                           SideCheckLoop:
0CBEC C8                               iny                       ;move onto the next one
0CBED 84 EB                            sty $eb                   ;store it
0CBEF A5 CE                            lda Player_Y_Position
0CBF1 C9 20                            cmp #$20                  ;check player's vertical position
0CBF3 90 16                            bcc BHalf                 ;if player is in status bar area, branch ahead to skip this part
0CBF5 C9 E4                            cmp #$e4
0CBF7 B0 28                            bcs ExSCH                 ;branch to leave if player is too far down
0CBF9 20 A3 D2                         jsr BlockBufferColli_Side ;do player-to-bg collision detection on one half of player
0CBFC F0 0D                            beq BHalf                 ;branch ahead if nothing found
0CBFE C9 1C                            cmp #$1c                  ;otherwise check for pipe metatiles
0CC00 F0 09                            beq BHalf                 ;if collided with sideways pipe (top), branch ahead
0CC02 C9 6F                            cmp #$6f
0CC04 F0 05                            beq BHalf                 ;if collided with water pipe (top), branch ahead
0CC06 20 3C CE                         jsr CheckForClimbMTiles   ;do sub to see if player bumped into anything climbable
0CC09 90 17                            bcc CheckSideMTiles       ;if not, branch to alternate section of code
0CC0B A4 EB                     BHalf: ldy $eb                   ;load block adder offset
0CC0D C8                               iny                       ;increment it
0CC0E A5 CE                            lda Player_Y_Position     ;get player's vertical position
0CC10 C9 08                            cmp #$08
0CC12 90 0D                            bcc ExSCH                 ;if too high, branch to leave
0CC14 C9 D0                            cmp #$d0
0CC16 B0 09                            bcs ExSCH                 ;if too low, branch to leave
0CC18 20 A3 D2                         jsr BlockBufferColli_Side ;do player-to-bg collision detection on other half of player
0CC1B D0 05                            bne CheckSideMTiles       ;if something found, branch
0CC1D C6 00                            dec $00                   ;otherwise decrement counter
0CC1F D0 CB                            bne SideCheckLoop         ;run code until both sides of player are checked
0CC21 60                        ExSCH: rts                       ;leave
0CC22                           
0CC22                           CheckSideMTiles:
0CC22 20 56 CD                            jsr ChkInvisibleMTiles     ;check for hidden or coin 1-up blocks
0CC25 F0 61                               beq ExCSM                  ;branch to leave if either found
0CC27 20 3C CE                            jsr CheckForClimbMTiles    ;check for climbable metatiles
0CC2A 90 03                               bcc ContSChk               ;if not found, skip and continue with code
0CC2C 4C B5 CC                            jmp HandleClimbing         ;otherwise jump to handle climbing
0CC2F 20 43 CE                  ContSChk: jsr CheckForCoinMTiles     ;check to see if player touched coin
0CC32 B0 57                               bcs HandleCoinMetatile     ;if so, execute code to erase coin and award to player 1 coin
0CC34 20 81 CD                            jsr ChkJumpspringMetatiles ;check for jumpspring metatiles
0CC37 90 08                               bcc ChkPBtm                ;if not found, branch ahead to continue cude
0CC39 AD 0E 07                            lda JumpspringAnimCtrl     ;otherwise check jumpspring animation control
0CC3C D0 4A                               bne ExCSM                  ;branch to leave if set
0CC3E 4C 85 CC                            jmp StopPlayerMove         ;otherwise jump to impede player's movement
0CC41 A4 1D                     ChkPBtm:  ldy Player_State           ;get player's state
0CC43 C0 00                               cpy #$00                   ;check for player's state set to normal
0CC45 D0 3E                               bne StopPlayerMove         ;if not, branch to impede player's movement
0CC47 A4 33                               ldy PlayerFacingDir        ;get player's facing direction
0CC49 88                                  dey
0CC4A D0 39                               bne StopPlayerMove         ;if facing left, branch to impede movement
0CC4C C9 70                               cmp #$70                   ;otherwise check for pipe metatiles
0CC4E F0 04                               beq PipeDwnS               ;if collided with sideways pipe (bottom), branch
0CC50 C9 1F                               cmp #$1f                   ;if collided with water pipe (bottom), continue
0CC52 D0 31                               bne StopPlayerMove         ;otherwise branch to impede player's movement
0CC54 AD C4 03                  PipeDwnS: lda Player_SprAttrib       ;check player's attributes
0CC57 D0 04                               bne PlyrPipe               ;if already set, branch, do not play sound again
0CC59 A0 10                               ldy #Sfx_PipeDown_Injury
0CC5B 84 FF                               sty Square1SoundQueue      ;otherwise load pipedown/injury sound
0CC5D 09 20                     PlyrPipe: ora #%00100000
0CC5F 8D C4 03                            sta Player_SprAttrib       ;set background priority bit in player attributes
0CC62 A5 86                               lda Player_X_Position
0CC64 29 0F                               and #%00001111             ;get lower nybble of player's horizontal coordinate
0CC66 F0 0E                               beq ChkGERtn               ;if at zero, branch ahead to skip this part
0CC68 A0 00                               ldy #$00                   ;set default offset for timer setting data
0CC6A AD 1A 07                            lda ScreenLeft_PageLoc     ;load page location for left side of screen
0CC6D F0 01                               beq SetCATmr               ;if at page zero, use default offset
0CC6F C8                                  iny                        ;otherwise increment offset
0CC70 B9 89 CC                  SetCATmr: lda AreaChangeTimerData,y  ;set timer for change of area as appropriate
0CC73 8D DE 06                            sta ChangeAreaTimer
0CC76 A5 0E                     ChkGERtn: lda GameEngineSubroutine   ;get number of game engine routine running
0CC78 C9 07                               cmp #$07
0CC7A F0 0C                               beq ExCSM                  ;if running player entrance routine or
0CC7C C9 08                               cmp #$08                   ;player control routine, go ahead and branch to leave
0CC7E D0 08                               bne ExCSM
0CC80 A9 02                               lda #$02
0CC82 85 0E                               sta GameEngineSubroutine   ;otherwise set sideways pipe entry routine to run
0CC84 60                                  rts                        ;and leave
0CC85                           
0CC85                           ;--------------------------------
0CC85                           ;$02 - high nybble of vertical coordinate from block buffer
0CC85                           ;$04 - low nybble of horizontal coordinate from block buffer
0CC85                           ;$06-$07 - block buffer address
0CC85                           
0CC85                           StopPlayerMove:
0CC85 20 ED CD                         jsr ImpedePlayerMove      ;stop player's movement
0CC88 60                        ExCSM: rts                       ;leave
0CC89                                 
0CC89                           AreaChangeTimerData:
0CC89 A0 34                           .db $a0, $34
0CC8B                           
0CC8B                           HandleCoinMetatile:
0CC8B 20 A2 CC                        jsr ErACM             ;do sub to erase coin metatile from block buffer
0CC8E EE 48 07                        inc CoinTallyFor1Ups  ;increment coin tally used for 1-up blocks
0CC91 4C 17 A9                        jmp GiveOneCoin       ;update coin amount and tally on the screen
0CC94                           
0CC94                           HandleAxeMetatile:
0CC94 A9 00                            lda #$00
0CC96 8D 72 07                         sta OperMode_Task   ;reset secondary mode
0CC99 A9 02                            lda #$02
0CC9B 8D 70 07                         sta OperMode        ;set primary mode to victory mode
0CC9E A9 18                            lda #$18
0CCA0 85 57                            sta Player_X_Speed  ;set horizontal speed and continue to erase axe metatile
0CCA2 A4 02                     ErACM: ldy $02             ;load vertical high nybble offset for block buffer
0CCA4 A9 00                            lda #$00            ;load blank metatile
0CCA6 91 06                            sta ($06),y         ;store to remove old contents from block buffer
0CCA8 4C 7D 89                         jmp RemoveCoin_Axe  ;update the screen accordingly
0CCAB                           
0CCAB                           ;--------------------------------
0CCAB                           ;$02 - high nybble of vertical coordinate from block buffer
0CCAB                           ;$04 - low nybble of horizontal coordinate from block buffer
0CCAB                           ;$06-$07 - block buffer address
0CCAB                           
0CCAB 69                        	  .db $69 ; Fix L+R vine wrapping (shoutouts to threecreepio)
0CCAC                           ClimbXPosAdder:
0CCAC F9 07                           .db $f9, $07
0CCAE                           
0CCAE                           ClimbPLocAdder:
0CCAE FF 00                           .db $ff, $00
0CCB0                           
0CCB0                           FlagpoleYPosData:
0CCB0 18 22 50 68 90                  .db $18, $22, $50, $68, $90
0CCB5                           
0CCB5                           HandleClimbing:
0CCB5 A4 04                           ldy $04            ;check low nybble of horizontal coordinate returned from
0CCB7 C0 06                           cpy #$06           ;collision detection routine against certain values, this
0CCB9 90 04                           bcc ExHC           ;makes actual physical part of vine or flagpole thinner
0CCBB C0 0A                           cpy #$0a           ;than 16 pixels
0CCBD 90 01                           bcc ChkForFlagpole
0CCBF 60                        ExHC: rts                ;leave if too far left or too far right
0CCC0                           
0CCC0                           ChkForFlagpole:
0CCC0 C9 24                           cmp #$24               ;check climbing metatiles
0CCC2 F0 04                           beq FlagpoleCollision  ;branch if flagpole ball found
0CCC4 C9 25                           cmp #$25
0CCC6 D0 4B                           bne VineCollision      ;branch to alternate code if flagpole shaft not found
0CCC8                           
0CCC8                           FlagpoleCollision:
0CCC8 A5 0E                           lda GameEngineSubroutine
0CCCA C9 05                           cmp #$05                  ;check for end-of-level routine running
0CCCC F0 53                           beq PutPlayerOnVine       ;if running, branch to end of climbing code
0CCCE A9 01                           lda #$01
0CCD0 85 33                           sta PlayerFacingDir       ;set player's facing direction to right
0CCD2 EE 23 07                        inc ScrollLock            ;set scroll lock flag
0CCD5 A5 0E                           lda GameEngineSubroutine
0CCD7 C9 04                           cmp #$04                  ;check for flagpole slide routine running
0CCD9 F0 31                           beq RunFR                 ;if running, branch to end of flagpole code here
0CCDB A9 33                           lda #BulletBill_CannonVar ;load identifier for bullet bills (cannon variant)
0CCDD 20 30 96                        jsr KillEnemies           ;get rid of them
0CCE0 A9 80                           lda #Silence
0CCE2 85 FC                           sta EventMusicQueue       ;silence music
0CCE4 4A                              lsr
0CCE5 8D 13 07                        sta FlagpoleSoundQueue    ;load flagpole sound into flagpole sound queue
0CCE8 A2 04                           ldx #$04                  ;start at end of vertical coordinate data
0CCEA A5 CE                           lda Player_Y_Position
0CCEC 8D 0F 07                        sta FlagpoleCollisionYPos ;store player's vertical coordinate here to be used later
0CCEF                           
0CCEF                           ChkFlagpoleYPosLoop:
0CCEF DD B0 CC                         cmp FlagpoleYPosData,x    ;compare with current vertical coordinate data
0CCF2 B0 03                            bcs MtchF                 ;if player's => current, branch to use current offset
0CCF4 CA                               dex                       ;otherwise decrement offset to use 
0CCF5 D0 F8                            bne ChkFlagpoleYPosLoop   ;do this until all data is checked (use last one if all checked)
0CCF7 8E 0F 01                  MtchF: stx FlagpoleScore         ;store offset here to be used later
0CCFA AD E7 07                         lda CoinDisplay
0CCFD CD E8 07                         cmp CoinDisplay+1         ;check to see if coin tally digits are the same
0CD00 D0 0A                            bne RunFR                 ;if not, branch to use flagpole score data as-is
0CD02 CD EE 07                         cmp GameTimerDisplay+2    ;check to see if the last digit of game timer matches
0CD05 D0 05                            bne RunFR                 ;the two digits, if not, branch to use data as-is
0CD07 A9 05                            lda #$05
0CD09 8D 0F 01                         sta FlagpoleScore         ;otherwise, set to give player an extra life
0CD0C A9 04                     RunFR: lda #$04
0CD0E 85 0E                            sta GameEngineSubroutine  ;set value to run flagpole slide routine
0CD10 4C 21 CD                         jmp PutPlayerOnVine       ;jump to end of climbing code
0CD13                           
0CD13                           VineCollision:
0CD13 C9 26                           cmp #$26                  ;check for climbing metatile used on vines
0CD15 D0 0A                           bne PutPlayerOnVine
0CD17 A5 CE                           lda Player_Y_Position     ;check player's vertical coordinate
0CD19 C9 20                           cmp #$20                  ;for being in status bar area
0CD1B B0 04                           bcs PutPlayerOnVine       ;branch if not that far up
0CD1D A9 01                           lda #$01
0CD1F 85 0E                           sta GameEngineSubroutine  ;otherwise set to run autoclimb routine next frame
0CD21                           
0CD21                           PutPlayerOnVine:
0CD21 A9 03                              lda #$03                ;set player state to climbing
0CD23 85 1D                              sta Player_State
0CD25 A9 00                              lda #$00                ;nullify player's horizontal speed
0CD27 85 57                              sta Player_X_Speed      ;and fractional horizontal movement force
0CD29 8D 05 07                           sta Player_X_MoveForce
0CD2C A5 86                              lda Player_X_Position   ;get player's horizontal coordinate
0CD2E 38                                 sec
0CD2F ED 1C 07                           sbc ScreenLeft_X_Pos    ;subtract from left side horizontal coordinate
0CD32 C9 10                              cmp #$10
0CD34 B0 04                              bcs SetVXPl             ;if 16 or more pixels difference, do not alter facing direction
0CD36 A9 02                              lda #$02
0CD38 85 33                              sta PlayerFacingDir     ;otherwise force player to face left
0CD3A A4 33                     SetVXPl: ldy PlayerFacingDir     ;get current facing direction, use as offset
0CD3C A5 06                              lda $06                 ;get low byte of block buffer address
0CD3E 0A                                 asl
0CD3F 0A                                 asl                     ;move low nybble to high
0CD40 0A                                 asl
0CD41 0A                                 asl
0CD42 18                                 clc
0CD43 79 AB CC                           adc ClimbXPosAdder-1,y  ;add pixels depending on facing direction
0CD46 85 86                              sta Player_X_Position   ;store as player's horizontal coordinate
0CD48 A5 06                              lda $06                 ;get low byte of block buffer address again
0CD4A D0 09                              bne ExPVne              ;if not zero, branch
0CD4C AD 1B 07                           lda ScreenRight_PageLoc ;load page location of right side of screen
0CD4F 18                                 clc
0CD50 79 AD CC                           adc ClimbPLocAdder-1,y  ;add depending on facing location
0CD53 85 6D                              sta Player_PageLoc      ;store as player's page location
0CD55 60                        ExPVne:  rts                     ;finally, we're done!
0CD56                           
0CD56                           ;--------------------------------
0CD56                           
0CD56                           ChkInvisibleMTiles:
0CD56 C9 60                              cmp #$60       ;check for hidden coin block
0CD58 F0 0A                              beq ExCInvT
0CD5A C9 61                              cmp #$61       ;check for hidden 1-up block
0CD5C F0 06                              beq ExCInvT
0CD5E C9 62                              cmp #$62       ;check for hidden poison shroom block
0CD60 F0 02                              beq ExCInvT
0CD62 C9 63                              cmp #$63       ;check for hidden power-up block
0CD64 60                        ExCInvT: rts            ;leave with zero flag set if any of these found
0CD65                           
0CD65                           ;--------------------------------
0CD65                           ;$00-$01 - used to hold bottom right and bottom left metatiles (in that order)
0CD65                           ;$00 - used as flag by ImpedePlayerMove to restrict specific movement
0CD65                           
0CD65                           ChkForLandJumpSpring:
0CD65 20 81 CD                          jsr ChkJumpspringMetatiles  ;do sub to check if player landed on jumpspring
0CD68 90 16                             bcc ExCJSp                  ;if carry not set, jumpspring not found, therefore leave
0CD6A A9 70                             lda #$70
0CD6C 8D 09 07                          sta VerticalForce           ;otherwise set vertical movement force for player
0CD6F 8D 0A 07                          sta VerticalForceDown
0CD72 A9 F9                             lda #$f9
0CD74 8D DB 06                          sta JumpspringForce         ;set default jumpspring force
0CD77 A9 03                             lda #$03
0CD79 8D 86 07                          sta JumpspringTimer         ;set jumpspring timer to be used later
0CD7C 4A                                lsr
0CD7D 8D 0E 07                          sta JumpspringAnimCtrl      ;set jumpspring animation control to start animating
0CD80 60                        ExCJSp: rts                         ;and leave
0CD81                           
0CD81                           ChkJumpspringMetatiles:
0CD81 C9 6A                              cmp #$6a      ;check for top jumpspring metatile
0CD83 F0 05                              beq JSFnd     ;branch to set carry if found
0CD85 C9 6B                              cmp #$6b      ;check for bottom jumpspring metatile
0CD87 18                                 clc           ;clear carry flag
0CD88 D0 01                              bne NoJSFnd   ;branch to use cleared carry if not found
0CD8A 38                        JSFnd:   sec           ;set carry if found
0CD8B 60                        NoJSFnd: rts           ;leave
0CD8C                           
0CD8C                           HandlePipeEntry:
0CD8C A5 0B                               lda Up_Down_Buttons       ;check saved controller bits from earlier
0CD8E 29 04                               and #%00000100            ;for pressing down
0CD90 F0 5A                               beq ExPipeE               ;if not pressing down, branch to leave
0CD92 A5 00                               lda $00
0CD94 C9 11                               cmp #$11                  ;check right foot metatile for warp pipe right metatile
0CD96 D0 54                               bne ExPipeE               ;branch to leave if not found
0CD98 A5 01                               lda $01
0CD9A C9 10                               cmp #$10                  ;check left foot metatile for warp pipe left metatile
0CD9C D0 4E                               bne ExPipeE               ;branch to leave if not found
0CD9E A9 30                               lda #$30
0CDA0 8D DE 06                            sta ChangeAreaTimer       ;set timer for change of area
0CDA3 A9 03                               lda #$03
0CDA5 85 0E                               sta GameEngineSubroutine  ;set to run vertical pipe entry routine on next frame
0CDA7 A9 10                               lda #Sfx_PipeDown_Injury
0CDA9 85 FF                               sta Square1SoundQueue     ;load pipedown/injury sound
0CDAB A9 20                               lda #%00100000
0CDAD 8D C4 03                            sta Player_SprAttrib      ;set background priority bit in player's attributes
0CDB0 AD D6 06                            lda WarpZoneControl       ;check warp zone control
0CDB3 F0 37                               beq ExPipeE               ;branch to leave if none found
0CDB5 29 0F                               and #%00001111            ;mask bits
0CDB7 0A                                  asl
0CDB8 0A                                  asl                       ;multiply by four
0CDB9 AA                                  tax                       ;save as offset to warp zone numbers (starts at left pipe)
0CDBA A5 86                               lda Player_X_Position     ;get player's horizontal position
0CDBC C9 60                               cmp #$60      
0CDBE 90 06                               bcc GetWNum               ;if player at left, not near middle, use offset and skip ahead
0CDC0 E8                                  inx                       ;otherwise increment for middle pipe
0CDC1 C9 A0                               cmp #$a0      
0CDC3 90 01                               bcc GetWNum               ;if player at middle, but not too far right, use offset and skip
0CDC5 E8                                  inx                       ;otherwise increment for last pipe
0CDC6 BD EF 86                  GetWNum:  lda WarpZoneNumbers,x
0CDC9 A8                                  tay
0CDCA 88                                  dey                       ;decrement for use as world number
0CDCB 8C 5F 07                            sty WorldNumber           ;store as world number and offset
0CDCE 20 CF FE                            jsr RunGetAreaPointer
0CDD1 8C 50 07                            sty AreaPointer           ;store area offset here to be used to change areas
0CDD4 A9 80                               lda #Silence
0CDD6 85 FC                               sta EventMusicQueue       ;silence music
0CDD8 A9 00                               lda #$00
0CDDA 8D 51 07                            sta EntrancePage          ;initialize starting page number
0CDDD 8D 60 07                            sta AreaNumber            ;initialize area number used for area address offset
0CDE0 8D 5C 07                            sta LevelNumber           ;initialize level number used for world display
0CDE3 8D 52 07                            sta AltEntranceControl    ;initialize mode of entry
0CDE6 EE 5D 07                            inc Hidden1UpFlag         ;set flag for hidden 1-up blocks
0CDE9 EE 57 07                            inc FetchNewGameTimerFlag ;set flag to load new game timer
0CDEC 60                        ExPipeE:  rts                       ;leave!!!
0CDED                           
0CDED                           ImpedePlayerMove:
0CDED A9 00                            lda #$00                  ;initialize value here
0CDEF A4 57                            ldy Player_X_Speed        ;get player's horizontal speed
0CDF1 A6 00                            ldx $00                   ;check value set earlier for
0CDF3 CA                               dex                       ;left side collision
0CDF4 D0 0A                            bne RImpd                 ;if right side collision, skip this part
0CDF6 E8                               inx                       ;return value to X
0CDF7 C0 00                            cpy #$00                  ;if player moving to the left,
0CDF9 30 28                            bmi ExIPM                 ;branch to invert bit and leave
0CDFB A9 FF                            lda #$ff                  ;otherwise load A with value to be used later
0CDFD 4C 08 CE                         jmp NXSpd                 ;and jump to affect movement
0CE00 A2 02                     RImpd: ldx #$02                  ;return $02 to X
0CE02 C0 01                            cpy #$01                  ;if player moving to the right,
0CE04 10 1D                            bpl ExIPM                 ;branch to invert bit and leave
0CE06 A9 01                            lda #$01                  ;otherwise load A with value to be used here
0CE08 A0 10                     NXSpd: ldy #$10
0CE0A 8C 85 07                         sty SideCollisionTimer    ;set timer of some sort
0CE0D A0 00                            ldy #$00
0CE0F 84 57                            sty Player_X_Speed        ;nullify player's horizontal speed
0CE11 C9 00                            cmp #$00                  ;if value set in A not set to $ff,
0CE13 10 01                            bpl PlatF                 ;branch ahead, do not decrement Y
0CE15 88                               dey                       ;otherwise decrement Y now
0CE16 84 00                     PlatF: sty $00                   ;store Y as high bits of horizontal adder
0CE18 18                               clc
0CE19 65 86                            adc Player_X_Position     ;add contents of A to player's horizontal
0CE1B 85 86                            sta Player_X_Position     ;position to move player left or right
0CE1D A5 6D                            lda Player_PageLoc
0CE1F 65 00                            adc $00                   ;add high bits and carry to
0CE21 85 6D                            sta Player_PageLoc        ;page location if necessary
0CE23 8A                        ExIPM: txa                       ;invert contents of X
0CE24 49 FF                            eor #$ff
0CE26 2D 90 04                         and Player_CollisionBits  ;mask out bit that was set here
0CE29 8D 90 04                         sta Player_CollisionBits  ;store to clear bit
0CE2C 60                               rts
0CE2D                           
0CE2D                           ;--------------------------------
0CE2D                           
0CE2D                           SolidMTileUpperExt:
0CE2D 10 64 88 C5                     .db $10, $64, $88, $c5
0CE31                           
0CE31                           CheckForSolidMTiles:
0CE31 20 52 CE                        jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
0CE34 DD 2D CE                        cmp SolidMTileUpperExt,x  ;compare current metatile with solid metatiles
0CE37 60                              rts
0CE38                           
0CE38                           ClimbMTileUpperExt:
0CE38 24 71 8D C7                     .db $24, $71, $8d, $c7
0CE3C                           
0CE3C                           CheckForClimbMTiles:
0CE3C 20 52 CE                        jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
0CE3F DD 38 CE                        cmp ClimbMTileUpperExt,x  ;compare current metatile with climbable metatiles
0CE42 60                              rts
0CE43                           
0CE43                           CheckForCoinMTiles:
0CE43 C9 C3                              cmp #$c3              ;check for regular coin
0CE45 F0 06                              beq CoinSd            ;branch if found
0CE47 C9 C4                              cmp #$c4              ;check for underwater coin
0CE49 F0 02                              beq CoinSd            ;branch if found
0CE4B 18                                 clc                   ;otherwise clear carry and leave
0CE4C 60                                 rts
0CE4D A9 01                     CoinSd:  lda #Sfx_CoinGrab
0CE4F 85 FE                              sta Square2SoundQueue ;load coin grab sound and leave
0CE51 60                                 rts
0CE52                           
0CE52                           GetMTileAttrib:
0CE52 A8                               tay            ;save metatile value into Y
0CE53 29 C0                            and #%11000000 ;mask out all but 2 MSB
0CE55 0A                               asl
0CE56 2A                               rol            ;shift and rotate d7-d6 to d1-d0
0CE57 2A                               rol
0CE58 AA                               tax            ;use as offset for metatile data
0CE59 98                               tya            ;get original metatile value back
0CE5A 60                        ExEBG: rts            ;leave
0CE5B                           
0CE5B                           ;-------------------------------------------------------------------------------------
0CE5B                           ;$06-$07 - address from block buffer routine
0CE5B                           
0CE5B                           EnemyBGCStateData:
0CE5B 01 01 02 02 02 05               .db $01, $01, $02, $02, $02, $05
0CE61                           
0CE61                           EnemyBGCXSpdData:
0CE61 10 F0                           .db $10, $f0
0CE63                           
0CE63                           EnemyToBGCollisionDet:
0CE63 B5 1E                           lda Enemy_State,x        ;check enemy state for d6 set
0CE65 29 20                           and #%00100000
0CE67 D0 F1                           bne ExEBG                ;if set, branch to leave
0CE69 20 0A D0                        jsr SubtEnemyYPos        ;otherwise, do a subroutine here
0CE6C 90 EC                           bcc ExEBG                ;if enemy vertical coord + 62 < 68, branch to leave
0CE6E B4 16                           ldy Enemy_ID,x
0CE70 C0 12                           cpy #Spiny               ;if enemy object is not spiny, branch elsewhere
0CE72 D0 06                           bne DoIDCheckBGColl
0CE74 B5 CF                           lda Enemy_Y_Position,x
0CE76 C9 25                           cmp #$25                 ;if enemy vertical coordinate < 36 branch to leave
0CE78 90 E0                           bcc ExEBG
0CE7A                           
0CE7A                           DoIDCheckBGColl:
0CE7A C0 0E                               cpy #GreenParatroopaJump ;check for some other enemy object
0CE7C D0 03                               bne HBChk                ;branch if not found
0CE7E 4C 12 D0                            jmp EnemyJump            ;otherwise jump elsewhere
0CE81 C0 05                     HBChk:    cpy #HammerBro           ;check for hammer bro
0CE83 D0 04                               bne CInvu                ;branch if not found
0CE85 4C 34 D0                            jmp HammerBroBGColl      ;otherwise jump elsewhere
0CE88 60                        ExIDBChk: rts
0CE89 C0 12                     CInvu:    cpy #Spiny               ;if enemy object is spiny, branch
0CE8B F0 0C                               beq YesIn
0CE8D C0 2E                               cpy #PowerUpObject       ;if special power-up object, branch
0CE8F F0 08                               beq YesIn
0CE91 C0 04                               cpy #UpsideDownPiranhaP  ;if enemy object is upside-down piranha plant
0CE93 F0 F3                               beq ExIDBChk             ;then branch to leave
0CE95 C0 07                               cpy #$07                 ;if enemy object =>$07, branch to leave
0CE97 B0 EF                               bcs ExIDBChk
0CE99 20 5D D0                  YesIn:    jsr ChkUnderEnemy        ;if enemy object < $07, or = $12 or $2e, do this sub
0CE9C D0 03                               bne HandleEToBGCollision ;if block underneath enemy, branch
0CE9E                           
0CE9E                           NoEToBGCollision:
0CE9E 4C 91 CF                         jmp ChkForRedKoopa       ;otherwise skip and do something else
0CEA1                           
0CEA1                           ;--------------------------------
0CEA1                           ;$02 - vertical coordinate from block buffer routine
0CEA1                           
0CEA1                           HandleEToBGCollision:
0CEA1 20 64 D0                        jsr ChkForNonSolids       ;if something is underneath enemy, find out what
0CEA4 F0 F8                           beq NoEToBGCollision      ;if blank $26, coins, or hidden blocks, jump, enemy falls through
0CEA6 C9 23                           cmp #$23
0CEA8 D0 6C                           bne LandEnemyProperly     ;check for blank metatile $23 and branch if not found
0CEAA B5 16                           lda Enemy_ID,x
0CEAC C9 15                           cmp #$15                  ;if enemy object => $15, branch ahead
0CEAE B0 0C                           bcs ChkToStunEnemies
0CEB0 C9 06                           cmp #Goomba               ;if enemy object not goomba, branch ahead of this routine
0CEB2 D0 03                           bne GiveOEPoints
0CEB4 20 3D D0                        jsr KillEnemyAboveBlock   ;if enemy object IS goomba, do this sub
0CEB7                           
0CEB7                           GiveOEPoints:
0CEB7 A9 01                           lda #$01                  ;award 100 points for hitting block beneath enemy
0CEB9 20 7E C8                        jsr SetupFloateyNumber
0CEBC                           
0CEBC                           ChkToStunEnemies:
0CEBC B5 16                                lda Enemy_ID,x
0CEBE C9 09                                cmp #$09                   ;perform many comparisons on enemy object identifier
0CEC0 90 18                                bcc NoDemote               ;if the enemy object identifier is equal to the values
0CEC2 C9 11                                cmp #$11                   ;$0e-$10 it will be demoted, in practice $0e and $10
0CEC4 B0 14                                bcs NoDemote               ;are values used by green paratroopas
0CEC6 C9 0D                                cmp #PiranhaPlant          
0CEC8 F0 10                                beq NoDemote               ;enemy objects $0a-$0d will not be demoted
0CECA C9 04                                cmp #UpsideDownPiranhaP
0CECC F0 0C                                beq NoDemote
0CECE C9 0A                                cmp #$0a                   ;demote enemy object $09 even though it is not used
0CED0 90 04                                bcc Demote                 
0CED2 C9 0D                                cmp #PiranhaPlant
0CED4 90 04                                bcc NoDemote
0CED6 29 01                     Demote:    and #%00000001             ;erase all but LSB, essentially turning enemy object
0CED8 95 16                                sta Enemy_ID,x             ;into green or red koopa troopa to demote them
0CEDA C9 2E                     NoDemote:  cmp #PowerUpObject
0CEDC F0 08                                beq BounceOff              ;if power-up object, branch to bounce it
0CEDE C9 06                                cmp #Goomba
0CEE0 F0 04                                beq BounceOff              ;redundant, already checked for goomba
0CEE2 A9 02                                lda #$02                   
0CEE4 95 1E                                sta Enemy_State,x          ;set enemy state to 2 (stunned)
0CEE6 D6 CF                     BounceOff: dec Enemy_Y_Position,x
0CEE8 D6 CF                                dec Enemy_Y_Position,x     ;subtract two pixels from enemy's vertical position
0CEEA B5 16                                lda Enemy_ID,x
0CEEC C9 07                                cmp #Bloober               ;check for bloober object
0CEEE F0 07                                beq SetWYSpd
0CEF0 A9 FD                                lda #$fd                   ;set default vertical speed
0CEF2 AC 4E 07                             ldy AreaType
0CEF5 D0 02                                bne SetNotW                ;if area type not water, set as speed, otherwise
0CEF7 A9 FF                     SetWYSpd:  lda #$ff                   ;change the vertical speed
0CEF9 95 A0                     SetNotW:   sta Enemy_Y_Speed,x        ;set vertical speed now
0CEFB A0 01                                ldy #$01
0CEFD 20 F2 CF                             jsr PlayerEnemyDiff        ;get horizontal difference between player and enemy object
0CF00 10 01                                bpl ChkBBill               ;branch if enemy is to the right of player
0CF02 C8                                   iny                        ;increment Y if not
0CF03 B5 16                     ChkBBill:  lda Enemy_ID,x      
0CF05 C9 33                                cmp #BulletBill_CannonVar  ;check for bullet bill (cannon variant)
0CF07 F0 06                                beq NoCDirF
0CF09 C9 08                                cmp #BulletBill_FrenzyVar  ;check for bullet bill (frenzy variant)
0CF0B F0 02                                beq NoCDirF                ;branch if either found, direction does not change
0CF0D 94 46                                sty Enemy_MovingDir,x      ;store as moving direction
0CF0F 88                        NoCDirF:   dey                        ;decrement and use as offset
0CF10 B9 61 CE                             lda EnemyBGCXSpdData,y     ;get proper horizontal speed
0CF13 95 58                                sta Enemy_X_Speed,x        ;and store, then leave
0CF15 60                        ExEBGChk:  rts
0CF16                           
0CF16                           ;--------------------------------
0CF16                           ;$04 - low nybble of vertical coordinate from block buffer routine
0CF16                           
0CF16                           LandEnemyProperly:
0CF16 A5 04                            lda $04                 ;check lower nybble of vertical coordinate saved earlier
0CF18 38                               sec
0CF19 E9 08                            sbc #$08                ;subtract eight pixels
0CF1B C9 05                            cmp #$05                ;used to determine whether enemy landed from falling
0CF1D B0 72                            bcs ChkForRedKoopa      ;branch if lower nybble in range of $0d-$0f before subtract
0CF1F B5 1E                            lda Enemy_State,x      
0CF21 29 40                            and #%01000000          ;branch if d6 in enemy state is set
0CF23 D0 57                            bne LandEnemyInitState
0CF25 B5 1E                            lda Enemy_State,x
0CF27 0A                               asl                     ;branch if d7 in enemy state is not set
0CF28 90 03                            bcc ChkLandedEnemyState
0CF2A 4C AD CF                  SChkA: jmp DoEnemySideCheck    ;if lower nybble < $0d, d7 set but d6 not set, jump here
0CF2D                           
0CF2D                           ChkLandedEnemyState:
0CF2D B5 1E                                lda Enemy_State,x         ;if enemy in normal state, branch back to jump here
0CF2F F0 F9                                beq SChkA
0CF31 C9 05                                cmp #$05                  ;if in state used by spiny's egg
0CF33 F0 1F                                beq ProcEnemyDirection    ;then branch elsewhere
0CF35 C9 03                                cmp #$03                  ;if already in state used by koopas and buzzy beetles
0CF37 B0 1A                                bcs ExSteChk              ;or in higher numbered state, branch to leave
0CF39 B5 1E                                lda Enemy_State,x         ;load enemy state again (why?)
0CF3B C9 02                                cmp #$02                  ;if not in $02 state (used by koopas and buzzy beetles)
0CF3D D0 15                                bne ProcEnemyDirection    ;then branch elsewhere
0CF3F A9 10                                lda #$10                  ;load default timer here
0CF41 B4 16                                ldy Enemy_ID,x            ;check enemy identifier for spiny
0CF43 C0 12                                cpy #Spiny
0CF45 D0 02                                bne SetForStn             ;branch if not found
0CF47 A9 00                                lda #$00                  ;set timer for $00 if spiny
0CF49 9D 96 07                  SetForStn: sta EnemyIntervalTimer,x  ;set timer here
0CF4C A9 03                                lda #$03                  ;set state here, apparently used to render
0CF4E 95 1E                                sta Enemy_State,x         ;upside-down koopas and buzzy beetles
0CF50 20 FE CF                             jsr EnemyLanding          ;then land it properly
0CF53 60                        ExSteChk:  rts                       ;then leave
0CF54                           
0CF54                           ProcEnemyDirection:
0CF54 B5 16                              lda Enemy_ID,x            ;check enemy identifier for goomba
0CF56 C9 06                              cmp #Goomba               ;branch if found
0CF58 F0 22                              beq LandEnemyInitState
0CF5A C9 12                              cmp #Spiny                ;check for spiny
0CF5C D0 0E                              bne InvtD                 ;branch if not found
0CF5E A9 01                              lda #$01
0CF60 95 46                              sta Enemy_MovingDir,x     ;send enemy moving to the right by default
0CF62 A9 08                              lda #$08
0CF64 95 58                              sta Enemy_X_Speed,x       ;set horizontal speed accordingly
0CF66 A5 09                              lda FrameCounter
0CF68 29 07                              and #%00000111            ;if timed appropriately, spiny will skip over
0CF6A F0 10                              beq LandEnemyInitState    ;trying to face the player
0CF6C A0 01                     InvtD:   ldy #$01                  ;load 1 for enemy to face the left (inverted here)
0CF6E 20 F2 CF                           jsr PlayerEnemyDiff       ;get horizontal difference between player and enemy
0CF71 10 01                              bpl CNwCDir               ;if enemy to the right of player, branch
0CF73 C8                                 iny                       ;if to the left, increment by one for enemy to face right (inverted)
0CF74 98                        CNwCDir: tya
0CF75 D5 46                              cmp Enemy_MovingDir,x     ;compare direction in A with current direction in memory
0CF77 D0 03                              bne LandEnemyInitState
0CF79 20 D3 CF                           jsr ChkForBump_HammerBroJ ;if equal, not facing in correct dir, do sub to turn around
0CF7C                           
0CF7C                           LandEnemyInitState:
0CF7C 20 FE CF                        jsr EnemyLanding       ;land enemy properly
0CF7F B5 1E                           lda Enemy_State,x
0CF81 29 80                           and #%10000000         ;if d7 of enemy state is set, branch
0CF83 D0 05                           bne NMovShellFallBit
0CF85 A9 00                           lda #$00               ;otherwise initialize enemy state and leave
0CF87 95 1E                           sta Enemy_State,x      ;note this will also turn spiny's egg into spiny
0CF89 60                              rts
0CF8A                           
0CF8A                           NMovShellFallBit:
0CF8A B5 1E                           lda Enemy_State,x   ;nullify d6 of enemy state, save other bits
0CF8C 29 BF                           and #%10111111      ;and store, then leave
0CF8E 95 1E                           sta Enemy_State,x
0CF90 60                              rts
0CF91                           
0CF91                           ;--------------------------------
0CF91                           
0CF91                           ChkForRedKoopa:
0CF91 B5 16                                  lda Enemy_ID,x            ;check for red koopa troopa $03
0CF93 C9 03                                  cmp #RedKoopa
0CF95 D0 04                                  bne Chk2MSBSt             ;branch if not found
0CF97 B5 1E                                  lda Enemy_State,x
0CF99 F0 38                                  beq ChkForBump_HammerBroJ ;if enemy found and in normal state, branch
0CF9B B5 1E                     Chk2MSBSt:   lda Enemy_State,x         ;save enemy state into Y
0CF9D A8                                     tay
0CF9E 0A                                     asl                       ;check for d7 set
0CF9F 90 07                                  bcc GetSteFromD           ;branch if not set
0CFA1 B5 1E                                  lda Enemy_State,x
0CFA3 09 40                                  ora #%01000000            ;set d6
0CFA5 4C AB CF                               jmp SetD6Ste              ;jump ahead of this part
0CFA8 B9 5B CE                  GetSteFromD: lda EnemyBGCStateData,y   ;load new enemy state with old as offset
0CFAB 95 1E                     SetD6Ste:    sta Enemy_State,x         ;set as new state
0CFAD                           
0CFAD                           ;--------------------------------
0CFAD                           ;$00 - used to store bitmask (not used but initialized here)
0CFAD                           ;$eb - used in DoEnemySideCheck as counter and to compare moving directions
0CFAD                           
0CFAD                           DoEnemySideCheck:
0CFAD B5 CF                               lda Enemy_Y_Position,x     ;if enemy within status bar, branch to leave
0CFAF C9 20                               cmp #$20                   ;because there's nothing there that impedes movement
0CFB1 90 1F                               bcc ExESdeC
0CFB3 A0 16                               ldy #$16                   ;start by finding block to the left of enemy ($00,$14)
0CFB5 A9 02                               lda #$02                   ;set value here in what is also used as
0CFB7 85 EB                               sta $eb                    ;OAM data offset
0CFB9 A5 EB                     SdeCLoop: lda $eb                    ;check value
0CFBB D5 46                               cmp Enemy_MovingDir,x      ;compare value against moving direction
0CFBD D0 0C                               bne NextSdeC               ;branch if different and do not seek block there
0CFBF A9 01                               lda #$01                   ;set flag in A for save horizontal coordinate 
0CFC1 20 3F D2                            jsr BlockBufferChk_Enemy   ;find block to left or right of enemy object
0CFC4 F0 05                               beq NextSdeC               ;if nothing found, branch
0CFC6 20 64 D0                            jsr ChkForNonSolids        ;check for non-solid blocks
0CFC9 D0 08                               bne ChkForBump_HammerBroJ  ;branch if not found
0CFCB C6 EB                     NextSdeC: dec $eb                    ;move to the next direction
0CFCD C8                                  iny
0CFCE C0 18                               cpy #$18                   ;increment Y, loop only if Y < $18, thus we check
0CFD0 90 E7                               bcc SdeCLoop               ;enemy ($00, $14) and ($10, $14) pixel coordinates
0CFD2 60                        ExESdeC:  rts
0CFD3                           
0CFD3                           ChkForBump_HammerBroJ: 
0CFD3 E0 05                             cpx #$05               ;check if we're on the special use slot
0CFD5 F0 09                             beq NoBump             ;and if so, branch ahead and do not play sound
0CFD7 B5 1E                             lda Enemy_State,x      ;if enemy state d7 not set, branch
0CFD9 0A                                asl                    ;ahead and do not play sound
0CFDA 90 04                             bcc NoBump
0CFDC A9 02                             lda #Sfx_Bump          ;otherwise, play bump sound
0CFDE 85 FF                             sta Square1SoundQueue  ;sound will never be played if branching from ChkForRedKoopa
0CFE0 B5 16                     NoBump: lda Enemy_ID,x         ;check for hammer bro
0CFE2 C9 05                             cmp #$05
0CFE4 D0 09                             bne InvEnemyDir        ;branch if not found
0CFE6 A9 00                             lda #$00
0CFE8 85 00                             sta $00                ;initialize value here for bitmask  
0CFEA A0 FA                             ldy #$fa               ;load default vertical speed for jumping
0CFEC 4C 50 B8                          jmp SetHJ              ;jump to code that makes hammer bro jump
0CFEF                           
0CFEF                           InvEnemyDir:
0CFEF 4C AF C9                        jmp RXSpd     ;jump to turn the enemy around
0CFF2                           
0CFF2                           ;--------------------------------
0CFF2                           ;$00 - used to hold horizontal difference between player and enemy
0CFF2                           
0CFF2                           PlayerEnemyDiff:
0CFF2 B5 87                           lda Enemy_X_Position,x  ;get distance between enemy object's
0CFF4 38                              sec                     ;horizontal coordinate and the player's
0CFF5 E5 86                           sbc Player_X_Position   ;horizontal coordinate
0CFF7 85 00                           sta $00                 ;and store here
0CFF9 B5 6E                           lda Enemy_PageLoc,x
0CFFB E5 6D                           sbc Player_PageLoc      ;subtract borrow, then leave
0CFFD 60                              rts
0CFFE                           
0CFFE                           ;--------------------------------
0CFFE                           
0CFFE                           EnemyLanding:
0CFFE 20 4F B1                        jsr InitVStf            ;do something here to vertical speed and something else
0D001 B5 CF                           lda Enemy_Y_Position,x
0D003 29 F0                           and #%11110000          ;save high nybble of vertical coordinate, and
0D005 09 08                           ora #%00001000          ;set d3, then store, probably used to set enemy object
0D007 95 CF                           sta Enemy_Y_Position,x  ;neatly on whatever it's landing on
0D009 60                              rts
0D00A                           
0D00A                           SubtEnemyYPos:
0D00A B5 CF                           lda Enemy_Y_Position,x  ;add 62 pixels to enemy object's
0D00C 18                              clc                     ;vertical coordinate
0D00D 69 3E                           adc #$3e
0D00F C9 44                           cmp #$44                ;compare against a certain range
0D011 60                              rts                     ;and leave with flags set for conditional branch
0D012                           
0D012                           EnemyJump:
0D012 20 0A D0                          jsr SubtEnemyYPos     ;do a sub here
0D015 90 1A                             bcc DoSide            ;if enemy vertical coord + 62 < 68, branch to leave
0D017 B5 A0                             lda Enemy_Y_Speed,x
0D019 18                                clc                   ;add two to vertical speed
0D01A 69 02                             adc #$02
0D01C C9 03                             cmp #$03              ;if green paratroopa not falling, branch ahead
0D01E 90 11                             bcc DoSide
0D020 20 5D D0                          jsr ChkUnderEnemy     ;otherwise, check to see if green paratroopa is 
0D023 F0 0C                             beq DoSide            ;standing on anything, then branch to same place if not
0D025 20 64 D0                          jsr ChkForNonSolids   ;check for non-solid blocks
0D028 F0 07                             beq DoSide            ;branch if found
0D02A 20 FE CF                          jsr EnemyLanding      ;change vertical coordinate and speed
0D02D A9 FD                             lda #$fd
0D02F 95 A0                             sta Enemy_Y_Speed,x   ;make the paratroopa jump again
0D031 4C AD CF                  DoSide: jmp DoEnemySideCheck  ;check for horizontal blockage, then leave
0D034                           
0D034                           ;--------------------------------
0D034                           
0D034                           HammerBroBGColl:
0D034 20 5D D0                        jsr ChkUnderEnemy    ;check to see if hammer bro is standing on anything
0D037 F0 1D                           beq NoUnderHammerBro      
0D039 C9 23                           cmp #$23             ;check for blank metatile $23 and branch if not found
0D03B D0 08                           bne UnderHammerBro
0D03D                           
0D03D                           KillEnemyAboveBlock:
0D03D 20 DA C5                        jsr ShellOrBlockDefeat  ;do this sub to kill enemy
0D040 A9 FC                           lda #$fc                ;alter vertical speed of enemy and leave
0D042 95 A0                           sta Enemy_Y_Speed,x
0D044 60                              rts
0D045                           
0D045                           UnderHammerBro:
0D045 BD 8A 07                        lda EnemyFrameTimer,x ;check timer used by hammer bro
0D048 D0 0C                           bne NoUnderHammerBro  ;branch if not expired
0D04A B5 1E                           lda Enemy_State,x
0D04C 29 88                           and #%10001000        ;save d7 and d3 from enemy state, nullify other bits
0D04E 95 1E                           sta Enemy_State,x     ;and store
0D050 20 FE CF                        jsr EnemyLanding      ;modify vertical coordinate, speed and something else
0D053 4C AD CF                        jmp DoEnemySideCheck  ;then check for horizontal blockage and leave
0D056                           
0D056                           NoUnderHammerBro:
0D056 B5 1E                           lda Enemy_State,x  ;if hammer bro is not standing on anything, set d0
0D058 09 01                           ora #$01           ;in the enemy state to indicate jumping or falling, then leave
0D05A 95 1E                           sta Enemy_State,x
0D05C 60                              rts
0D05D                           
0D05D                           ChkUnderEnemy:
0D05D A9 00                           lda #$00                  ;set flag in A for save vertical coordinate
0D05F A0 15                           ldy #$15                  ;set Y to check the bottom middle (8,18) of enemy object
0D061 4C 3F D2                        jmp BlockBufferChk_Enemy  ;hop to it!
0D064                           
0D064                           ChkForNonSolids:
0D064 C9 26                            cmp #$26       ;blank metatile used for vines?
0D066 F0 16                            beq NSFnd
0D068 C9 C3                            cmp #$c3       ;regular coin?
0D06A F0 12                            beq NSFnd
0D06C C9 C4                            cmp #$c4       ;underwater coin?
0D06E F0 0E                            beq NSFnd
0D070 C9 60                            cmp #$60       ;hidden coin block?
0D072 F0 0A                            beq NSFnd
0D074 C9 61                            cmp #$61       ;hidden 1-up block?
0D076 F0 06                            beq NSFnd
0D078 C9 62                            cmp #$62       ;hidden poison shroom block?
0D07A F0 02                            beq NSFnd
0D07C C9 63                            cmp #$63       ;hidden power-up block?
0D07E 60                        NSFnd: rts
0D07F                           
0D07F                           ;-------------------------------------------------------------------------------------
0D07F                           
0D07F                           FireballBGCollision:
0D07F B5 D5                           lda Fireball_Y_Position,x   ;check fireball's vertical coordinate
0D081 C9 18                           cmp #$18
0D083 90 21                           bcc ClearBounceFlag         ;if within the status bar area of the screen, branch ahead
0D085 20 53 D2                        jsr BlockBufferChk_FBall    ;do fireball to background collision detection on bottom of it
0D088 F0 1C                           beq ClearBounceFlag         ;if nothing underneath fireball, branch
0D08A 20 64 D0                        jsr ChkForNonSolids         ;check for non-solid metatiles
0D08D F0 17                           beq ClearBounceFlag         ;branch if any found
0D08F B5 A6                           lda Fireball_Y_Speed,x      ;if fireball's vertical speed set to move upwards,
0D091 30 18                           bmi InitFireballExplode     ;branch to set exploding bit in fireball's state
0D093 B5 3A                           lda FireballBouncingFlag,x  ;if bouncing flag already set,
0D095 D0 14                           bne InitFireballExplode     ;branch to set exploding bit in fireball's state
0D097 A9 FD                           lda #$fd
0D099 95 A6                           sta Fireball_Y_Speed,x      ;otherwise set vertical speed to move upwards (give it bounce)
0D09B A9 01                           lda #$01
0D09D 95 3A                           sta FireballBouncingFlag,x  ;set bouncing flag
0D09F B5 D5                           lda Fireball_Y_Position,x
0D0A1 29 F8                           and #$f8                    ;modify vertical coordinate to land it properly
0D0A3 95 D5                           sta Fireball_Y_Position,x   ;store as new vertical coordinate
0D0A5 60                              rts                         ;leave
0D0A6                           
0D0A6                           ClearBounceFlag:
0D0A6 A9 00                           lda #$00
0D0A8 95 3A                           sta FireballBouncingFlag,x  ;clear bouncing flag by default
0D0AA 60                              rts                         ;leave
0D0AB                           
0D0AB                           InitFireballExplode:
0D0AB A9 80                           lda #$80
0D0AD 95 24                           sta Fireball_State,x        ;set exploding flag in fireball's state
0D0AF A9 02                           lda #Sfx_Bump
0D0B1 85 FF                           sta Square1SoundQueue       ;load bump sound
0D0B3 60                              rts                         ;leave
0D0B4                           
0D0B4                           ;-------------------------------------------------------------------------------------
0D0B4                           ;$00 - used to hold one of bitmasks, or offset
0D0B4                           ;$01 - used for relative X coordinate, also used to store middle screen page location
0D0B4                           ;$02 - used for relative Y coordinate, also used to store middle screen coordinate
0D0B4                           
0D0B4                           ;this data added to relative coordinates of sprite objects
0D0B4                           ;stored in order: left edge, top edge, right edge, bottom edge
0D0B4                           BoundBoxCtrlData:
0D0B4 02 08 0E 20                     .db $02, $08, $0e, $20 
0D0B8 03 14 0D 20                     .db $03, $14, $0d, $20
0D0BC 02 14 0E 20                     .db $02, $14, $0e, $20
0D0C0 02 09 0E 15                     .db $02, $09, $0e, $15
0D0C4 00 00 18 06                     .db $00, $00, $18, $06
0D0C8 00 00 20 0D                     .db $00, $00, $20, $0d
0D0CC 00 00 30 0D                     .db $00, $00, $30, $0d
0D0D0 00 00 08 08                     .db $00, $00, $08, $08
0D0D4 06 04 0A 08                     .db $06, $04, $0a, $08
0D0D8 03 0E 0D 16                     .db $03, $0e, $0d, $16
0D0DC 00 02 10 15                     .db $00, $02, $10, $15
0D0E0 04 04 0C 1C                     .db $04, $04, $0c, $1c
0D0E4                           
0D0E4                           GetFireballBoundBox:
0D0E4 8A                              txa         ;add seven bytes to offset
0D0E5 18                              clc         ;to use in routines as offset for fireball
0D0E6 69 07                           adc #$07
0D0E8 AA                              tax
0D0E9 A0 02                           ldy #$02    ;set offset for relative coordinates
0D0EB D0 07                           bne FBallB  ;unconditional branch
0D0ED                           
0D0ED                           GetMiscBoundBox:
0D0ED 8A                                txa                       ;add nine bytes to offset
0D0EE 18                                clc                       ;to use in routines as offset for misc object
0D0EF 69 09                             adc #$09
0D0F1 AA                                tax
0D0F2 A0 06                             ldy #$06                  ;set offset for relative coordinates
0D0F4 20 53 D1                  FBallB: jsr BoundingBoxCore       ;get bounding box coordinates
0D0F7 4C 95 D1                          jmp CheckRightScreenBBox  ;jump to handle any offscreen coordinates
0D0FA                           
0D0FA                           GetEnemyBoundBox:
0D0FA A0 48                           ldy #$48                 ;store bitmask here for now
0D0FC 84 00                           sty $00
0D0FE A0 44                           ldy #$44                 ;store another bitmask here for now and jump
0D100 4C 09 D1                        jmp GetMaskedOffScrBits
0D103                           
0D103                           SmallPlatformBoundBox:
0D103 A0 08                           ldy #$08                 ;store bitmask here for now
0D105 84 00                           sty $00
0D107 A0 04                           ldy #$04                 ;store another bitmask here for now
0D109                           
0D109                           GetMaskedOffScrBits:
0D109 B5 87                             lda Enemy_X_Position,x      ;get enemy object position relative
0D10B 38                                sec                         ;to the left side of the screen
0D10C ED 1C 07                          sbc ScreenLeft_X_Pos
0D10F 85 01                             sta $01                     ;store here
0D111 B5 6E                             lda Enemy_PageLoc,x         ;subtract borrow from current page location
0D113 ED 1A 07                          sbc ScreenLeft_PageLoc      ;of left side
0D116 30 06                             bmi CMBits                  ;if enemy object is beyond left edge, branch
0D118 05 01                             ora $01
0D11A F0 02                             beq CMBits                  ;if precisely at the left edge, branch
0D11C A4 00                             ldy $00                     ;if to the right of left edge, use value in $00 for A
0D11E 98                        CMBits: tya                         ;otherwise use contents of Y
0D11F 2D D1 03                          and Enemy_OffscreenBits     ;preserve bitwise whatever's in here
0D122 9D D8 03                          sta EnemyOffscrBitsMasked,x ;save masked offscreen bits here
0D125 D0 19                             bne MoveBoundBoxOffscreen   ;if anything set here, branch
0D127 4C 33 D1                          jmp SetupEOffsetFBBox       ;otherwise, do something else
0D12A                           
0D12A                           LargePlatformBoundBox:
0D12A E8                              inx                        ;increment X to get the proper offset
0D12B 20 03 E1                        jsr GetXOffscreenBits      ;then jump directly to the sub for horizontal offscreen bits
0D12E CA                              dex                        ;decrement to return to original offset
0D12F C9 FE                           cmp #$fe                   ;if completely offscreen, branch to put entire bounding
0D131 B0 0D                           bcs MoveBoundBoxOffscreen  ;box offscreen, otherwise start getting coordinates
0D133                           
0D133                           SetupEOffsetFBBox:
0D133 8A                              txa                        ;add 1 to offset to properly address
0D134 18                              clc                        ;the enemy object memory locations
0D135 69 01                           adc #$01
0D137 AA                              tax
0D138 A0 01                           ldy #$01                   ;load 1 as offset here, same reason
0D13A 20 53 D1                        jsr BoundingBoxCore        ;do a sub to get the coordinates of the bounding box
0D13D 4C 95 D1                        jmp CheckRightScreenBBox   ;jump to handle offscreen coordinates of bounding box
0D140                           
0D140                           MoveBoundBoxOffscreen:
0D140 8A                              txa                            ;multiply offset by 4
0D141 0A                              asl
0D142 0A                              asl
0D143 A8                              tay                            ;use as offset here
0D144 A9 FF                           lda #$ff
0D146 99 B0 04                        sta EnemyBoundingBoxCoord,y    ;load value into four locations here and leave
0D149 99 B1 04                        sta EnemyBoundingBoxCoord+1,y
0D14C 99 B2 04                        sta EnemyBoundingBoxCoord+2,y
0D14F 99 B3 04                        sta EnemyBoundingBoxCoord+3,y
0D152 60                              rts
0D153                           
0D153                           BoundingBoxCore:
0D153 86 00                           stx $00                     ;save offset here
0D155 B9 B8 03                        lda SprObject_Rel_YPos,y    ;store object coordinates relative to screen
0D158 85 02                           sta $02                     ;vertically and horizontally, respectively
0D15A B9 AD 03                        lda SprObject_Rel_XPos,y
0D15D 85 01                           sta $01
0D15F 8A                              txa                         ;multiply offset by four and save to stack
0D160 0A                              asl
0D161 0A                              asl
0D162 48                              pha
0D163 A8                              tay                         ;use as offset for Y, X is left alone
0D164 BD 99 04                        lda SprObj_BoundBoxCtrl,x   ;load value here to be used as offset for X
0D167 0A                              asl                         ;multiply that by four and use as X
0D168 0A                              asl
0D169 AA                              tax
0D16A A5 01                           lda $01                     ;add the first number in the bounding box data to the
0D16C 18                              clc                         ;relative horizontal coordinate using enemy object offset
0D16D 7D B4 D0                        adc BoundBoxCtrlData,x      ;and store somewhere using same offset * 4
0D170 99 AC 04                        sta BoundingBox_UL_Corner,y ;store here
0D173 A5 01                           lda $01
0D175 18                              clc
0D176 7D B6 D0                        adc BoundBoxCtrlData+2,x    ;add the third number in the bounding box data to the
0D179 99 AE 04                        sta BoundingBox_LR_Corner,y ;relative horizontal coordinate and store
0D17C E8                              inx                         ;increment both offsets
0D17D C8                              iny
0D17E A5 02                           lda $02                     ;add the second number to the relative vertical coordinate
0D180 18                              clc                         ;using incremented offset and store using the other
0D181 7D B4 D0                        adc BoundBoxCtrlData,x      ;incremented offset
0D184 99 AC 04                        sta BoundingBox_UL_Corner,y
0D187 A5 02                           lda $02
0D189 18                              clc
0D18A 7D B6 D0                        adc BoundBoxCtrlData+2,x    ;add the fourth number to the relative vertical coordinate
0D18D 99 AE 04                        sta BoundingBox_LR_Corner,y ;and store
0D190 68                              pla                         ;get original offset loaded into $00 * y from stack
0D191 A8                              tay                         ;use as Y
0D192 A6 00                           ldx $00                     ;get original offset and use as X again
0D194 60                              rts
0D195                           
0D195                           CheckRightScreenBBox:
0D195 AD 1C 07                         lda ScreenLeft_X_Pos       ;add 128 pixels to left side of screen
0D198 18                               clc                        ;and store as horizontal coordinate of middle
0D199 69 80                            adc #$80
0D19B 85 02                            sta $02
0D19D AD 1A 07                         lda ScreenLeft_PageLoc     ;add carry to page location of left side of screen
0D1A0 69 00                            adc #$00                   ;and store as page location of middle
0D1A2 85 01                            sta $01
0D1A4 B5 86                            lda SprObject_X_Position,x ;get horizontal coordinate
0D1A6 C5 02                            cmp $02                    ;compare against middle horizontal coordinate
0D1A8 B5 6D                            lda SprObject_PageLoc,x    ;get page location
0D1AA E5 01                            sbc $01                    ;subtract from middle page location
0D1AC 90 15                            bcc CheckLeftScreenBBox    ;if object is on the left side of the screen, branch
0D1AE B9 AE 04                         lda BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
0D1B1 30 0D                            bmi NoOfs                  ;coordinates, branch if still on the screen
0D1B3 A9 FF                            lda #$ff                   ;load offscreen value here to use on one or both horizontal sides
0D1B5 BE AC 04                         ldx BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
0D1B8 30 03                            bmi SORte                  ;coordinates, and branch if still on the screen
0D1BA 99 AC 04                         sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
0D1BD 99 AE 04                  SORte: sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
0D1C0 A6 08                     NoOfs: ldx ObjectOffset           ;get object offset and leave
0D1C2 60                               rts
0D1C3                           
0D1C3                           CheckLeftScreenBBox:
0D1C3 B9 AC 04                          lda BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
0D1C6 10 11                             bpl NoOfs2                 ;coordinates, and branch if still on the screen
0D1C8 C9 A0                             cmp #$a0                   ;check to see if left-side edge is in the middle of the
0D1CA 90 0D                             bcc NoOfs2                 ;screen or really offscreen, and branch if still on
0D1CC A9 00                             lda #$00
0D1CE BE AE 04                          ldx BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
0D1D1 10 03                             bpl SOLft                  ;coordinates, branch if still onscreen
0D1D3 99 AE 04                          sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
0D1D6 99 AC 04                  SOLft:  sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
0D1D9 A6 08                     NoOfs2: ldx ObjectOffset           ;get object offset and leave
0D1DB 60                                rts
0D1DC                           
0D1DC                           ;-------------------------------------------------------------------------------------
0D1DC                           ;$06 - second object's offset
0D1DC                           ;$07 - counter
0D1DC                           
0D1DC                           PlayerCollisionCore:
0D1DC A2 00                           ldx #$00     ;initialize X to use player's bounding box for comparison
0D1DE                           
0D1DE                           SprObjectCollisionCore:
0D1DE 84 06                           sty $06      ;save contents of Y here
0D1E0 A9 01                           lda #$01
0D1E2 85 07                           sta $07      ;save value 1 here as counter, compare horizontal coordinates first
0D1E4                           
0D1E4                           CollisionCoreLoop:
0D1E4 B9 AC 04                        lda BoundingBox_UL_Corner,y  ;compare left/top coordinates
0D1E7 DD AC 04                        cmp BoundingBox_UL_Corner,x  ;of first and second objects' bounding boxes
0D1EA B0 2A                           bcs FirstBoxGreater          ;if first left/top => second, branch
0D1EC DD AE 04                        cmp BoundingBox_LR_Corner,x  ;otherwise compare to right/bottom of second
0D1EF 90 12                           bcc SecondBoxVerticalChk     ;if first left/top < second right/bottom, branch elsewhere
0D1F1 F0 42                           beq CollisionFound           ;if somehow equal, collision, thus branch
0D1F3 B9 AE 04                        lda BoundingBox_LR_Corner,y  ;if somehow greater, check to see if bottom of
0D1F6 D9 AC 04                        cmp BoundingBox_UL_Corner,y  ;first object's bounding box is greater than its top
0D1F9 90 3A                           bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
0D1FB DD AC 04                        cmp BoundingBox_UL_Corner,x  ;otherwise compare bottom of first bounding box to the top
0D1FE B0 35                           bcs CollisionFound           ;of second box, and if equal or greater, collision, thus branch
0D200 A4 06                           ldy $06                      ;otherwise return with carry clear and Y = $0006
0D202 60                              rts                          ;note horizontal wrapping never occurs
0D203                           
0D203                           SecondBoxVerticalChk:
0D203 BD AE 04                        lda BoundingBox_LR_Corner,x  ;check to see if the vertical bottom of the box
0D206 DD AC 04                        cmp BoundingBox_UL_Corner,x  ;is greater than the vertical top
0D209 90 2A                           bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
0D20B B9 AE 04                        lda BoundingBox_LR_Corner,y  ;otherwise compare horizontal right or vertical bottom
0D20E DD AC 04                        cmp BoundingBox_UL_Corner,x  ;of first box with horizontal left or vertical top of second box
0D211 B0 22                           bcs CollisionFound           ;if equal or greater, collision, thus branch
0D213 A4 06                           ldy $06                      ;otherwise return with carry clear and Y = $0006
0D215 60                              rts
0D216                           
0D216                           FirstBoxGreater:
0D216 DD AC 04                        cmp BoundingBox_UL_Corner,x  ;compare first and second box horizontal left/vertical top again
0D219 F0 1A                           beq CollisionFound           ;if first coordinate = second, collision, thus branch
0D21B DD AE 04                        cmp BoundingBox_LR_Corner,x  ;if not, compare with second object right or bottom edge
0D21E 90 15                           bcc CollisionFound           ;if left/top of first less than or equal to right/bottom of second
0D220 F0 13                           beq CollisionFound           ;then collision, thus branch
0D222 D9 AE 04                        cmp BoundingBox_LR_Corner,y  ;otherwise check to see if top of first box is greater than bottom
0D225 90 0A                           bcc NoCollisionFound         ;if less than or equal, no collision, branch to end
0D227 F0 08                           beq NoCollisionFound
0D229 B9 AE 04                        lda BoundingBox_LR_Corner,y  ;otherwise compare bottom of first to top of second
0D22C DD AC 04                        cmp BoundingBox_UL_Corner,x  ;if bottom of first is greater than top of second, vertical wrap
0D22F B0 04                           bcs CollisionFound           ;collision, and branch, otherwise, proceed onwards here
0D231                           
0D231                           NoCollisionFound:
0D231 18                              clc          ;clear carry, then load value set earlier, then leave
0D232 A4 06                           ldy $06      ;like previous ones, if horizontal coordinates do not collide, we do
0D234 60                              rts          ;not bother checking vertical ones, because what's the point?
0D235                           
0D235                           CollisionFound:
0D235 E8                              inx                    ;increment offsets on both objects to check
0D236 C8                              iny                    ;the vertical coordinates
0D237 C6 07                           dec $07                ;decrement counter to reflect this
0D239 10 A9                           bpl CollisionCoreLoop  ;if counter not expired, branch to loop
0D23B 38                              sec                    ;otherwise we already did both sets, therefore collision, so set carry
0D23C A4 06                           ldy $06                ;load original value set here earlier, then leave
0D23E 60                              rts
0D23F                           
0D23F                           ;-------------------------------------------------------------------------------------
0D23F                           ;$02 - modified y coordinate
0D23F                           ;$03 - stores metatile involved in block buffer collisions
0D23F                           ;$04 - comes in with offset to block buffer adder data, goes out with low nybble x/y coordinate
0D23F                           ;$05 - modified x coordinate
0D23F                           ;$06-$07 - block buffer address
0D23F                           
0D23F                           BlockBufferChk_Enemy:
0D23F 48                              pha        ;save contents of A to stack
0D240 8A                              txa
0D241 18                              clc        ;add 1 to X to run sub with enemy offset in mind
0D242 69 01                           adc #$01
0D244 AA                              tax
0D245 68                              pla        ;pull A from stack and jump elsewhere
0D246 4C 5C D2                        jmp BBChk_E
0D249                           
0D249                           ResidualMiscObjectCode:
0D249 8A                              txa
0D24A 18                              clc           ;supposedly used once to set offset for
0D24B 69 0D                           adc #$0d      ;miscellaneous objects
0D24D AA                              tax
0D24E A0 1B                           ldy #$1b      ;supposedly used once to set offset for block buffer data
0D250 4C 5A D2                        jmp ResJmpM   ;probably used in early stages to do misc to bg collision detection
0D253                           
0D253                           BlockBufferChk_FBall:
0D253 A0 1A                              ldy #$1a                  ;set offset for block buffer adder data
0D255 8A                                 txa
0D256 18                                 clc
0D257 69 07                              adc #$07                  ;add seven bytes to use
0D259 AA                                 tax
0D25A A9 00                     ResJmpM: lda #$00                  ;set A to return vertical coordinate
0D25C 20 A7 D2                  BBChk_E: jsr BlockBufferCollision  ;do collision detection subroutine for sprite object
0D25F A6 08                              ldx ObjectOffset          ;get object offset
0D261 C9 00                              cmp #$00                  ;check to see if object bumped into anything
0D263 60                                 rts
0D264                           
0D264                           BlockBufferAdderData:
0D264 00 07 0E                        .db $00, $07, $0e
0D267                           
0D267                           BlockBuffer_X_Adder:
0D267 08 03 0C 02 02 0D 0D 08         .db $08, $03, $0c, $02, $02, $0d, $0d, $08
0D26F 03 0C 02 02 0D 0D 08 03         .db $03, $0c, $02, $02, $0d, $0d, $08, $03
0D277 0C 02 02 0D 0D 08 00 10         .db $0c, $02, $02, $0d, $0d, $08, $00, $10
0D27F 04 14 04 04                     .db $04, $14, $04, $04
0D283                           
0D283                           BlockBuffer_Y_Adder:
0D283 04 20 20 08 18 08 18 02         .db $04, $20, $20, $08, $18, $08, $18, $02
0D28B 20 20 08 18 08 18 12 20         .db $20, $20, $08, $18, $08, $18, $12, $20
0D293 20 18 18 18 18 18 14 14         .db $20, $18, $18, $18, $18, $18, $14, $14
0D29B 06 06 08 10                     .db $06, $06, $08, $10
0D29F                           
0D29F                           BlockBufferColli_Feet:
0D29F C8                               iny            ;if branched here, increment to next set of adders
0D2A0                           
0D2A0                           BlockBufferColli_Head:
0D2A0 A9 00                            lda #$00       ;set flag to return vertical coordinate
0D2A2 2C                               .db $2c        ;BIT instruction opcode
0D2A3                           
0D2A3                           BlockBufferColli_Side:
0D2A3 A9 01                            lda #$01       ;set flag to return horizontal coordinate
0D2A5 A2 00                            ldx #$00       ;set offset for player object
0D2A7                           
0D2A7                           BlockBufferCollision:
0D2A7 48                               pha                         ;save contents of A to stack
0D2A8 84 04                            sty $04                     ;save contents of Y here
0D2AA B9 67 D2                         lda BlockBuffer_X_Adder,y   ;add horizontal coordinate
0D2AD 18                               clc                         ;of object to value obtained using Y as offset
0D2AE 75 86                            adc SprObject_X_Position,x
0D2B0 85 05                            sta $05                     ;store here
0D2B2 B5 6D                            lda SprObject_PageLoc,x
0D2B4 69 00                            adc #$00                    ;add carry to page location
0D2B6 29 01                            and #$01                    ;get LSB, mask out all other bits
0D2B8 4A                               lsr                         ;move to carry
0D2B9 05 05                            ora $05                     ;get stored value
0D2BB 6A                               ror                         ;rotate carry to MSB of A
0D2BC 4A                               lsr                         ;and effectively move high nybble to
0D2BD 4A                               lsr                         ;lower, LSB which became MSB will be
0D2BE 4A                               lsr                         ;d4 at this point
0D2BF 20 35 9B                         jsr GetBlockBufferAddr      ;get address of block buffer into $06, $07
0D2C2 A4 04                            ldy $04                     ;get old contents of Y
0D2C4 B5 CE                            lda SprObject_Y_Position,x  ;get vertical coordinate of object
0D2C6 18                               clc
0D2C7 79 83 D2                         adc BlockBuffer_Y_Adder,y   ;add it to value obtained using Y as offset
0D2CA 29 F0                            and #%11110000              ;mask out low nybble
0D2CC 38                               sec
0D2CD E9 20                            sbc #$20                    ;subtract 32 pixels for the status bar
0D2CF 85 02                            sta $02                     ;store result here
0D2D1 A8                               tay                         ;use as offset for block buffer
0D2D2 B1 06                            lda ($06),y                 ;check current content of block buffer
0D2D4 85 03                            sta $03                     ;and store here
0D2D6 A4 04                            ldy $04                     ;get old contents of Y again
0D2D8 68                               pla                         ;pull A from stack
0D2D9 D0 05                            bne RetXC                   ;if A = 1, branch
0D2DB B5 CE                            lda SprObject_Y_Position,x  ;if A = 0, load vertical coordinate
0D2DD 4C E2 D2                         jmp RetYC                   ;and jump
0D2E0 B5 86                     RetXC: lda SprObject_X_Position,x  ;otherwise load horizontal coordinate
0D2E2 29 0F                     RetYC: and #%00001111              ;and mask out high nybble
0D2E4 85 04                            sta $04                     ;store masked out result here
0D2E6 A5 03                            lda $03                     ;get saved content of block buffer
0D2E8 60                               rts                         ;and leave
0D2E9                           
0D2E9                           ;-------------------------------------------------------------------------------------
0D2E9                           
0D2E9                           ;$00 - offset to vine Y coordinate adder
0D2E9                           ;$02 - offset to sprite data
0D2E9                           
0D2E9                           VineYPosAdder:
0D2E9 00 30                           .db $00, $30
0D2EB                           
0D2EB                           DrawVine:
0D2EB 84 00                              sty $00                    ;save offset here
0D2ED AD B9 03                           lda Enemy_Rel_YPos         ;get relative vertical coordinate
0D2F0 18                                 clc
0D2F1 79 E9 D2                           adc VineYPosAdder,y        ;add value using offset in Y to get value
0D2F4 BE 9A 03                           ldx VineObjOffset,y        ;get offset to vine
0D2F7 BC E5 06                           ldy Enemy_SprDataOffset,x  ;get sprite data offset
0D2FA 84 02                              sty $02                    ;store sprite data offset here
0D2FC 20 64 D3                           jsr SixSpriteStacker       ;stack six sprites on top of each other vertically
0D2FF AD AE 03                           lda Enemy_Rel_XPos         ;get relative horizontal coordinate
0D302 99 03 02                           sta Sprite_X_Position,y    ;store in first, third and fifth sprites
0D305 99 0B 02                           sta Sprite_X_Position+8,y
0D308 99 13 02                           sta Sprite_X_Position+16,y
0D30B 18                                 clc
0D30C 69 06                              adc #$06                   ;add six pixels to second, fourth and sixth sprites
0D30E 99 07 02                           sta Sprite_X_Position+4,y  ;to give characteristic staggered vine shape to
0D311 99 0F 02                           sta Sprite_X_Position+12,y ;our vertical stack of sprites
0D314 99 17 02                           sta Sprite_X_Position+20,y
0D317 A9 21                              lda #%00100001             ;set bg priority and palette attribute bits
0D319 99 02 02                           sta Sprite_Attributes,y    ;set in first, third and fifth sprites
0D31C 99 0A 02                           sta Sprite_Attributes+8,y
0D31F 99 12 02                           sta Sprite_Attributes+16,y
0D322 09 40                              ora #%01000000             ;additionally, set horizontal flip bit
0D324 99 06 02                           sta Sprite_Attributes+4,y  ;for second, fourth and sixth sprites
0D327 99 0E 02                           sta Sprite_Attributes+12,y
0D32A 99 16 02                           sta Sprite_Attributes+20,y
0D32D A2 05                              ldx #$05                   ;set tiles for six sprites
0D32F A9 E1                     VineTL:  lda #$e1                   ;set tile number for sprite
0D331 99 01 02                           sta Sprite_Tilenumber,y
0D334 C8                                 iny                        ;move offset to next sprite data
0D335 C8                                 iny
0D336 C8                                 iny
0D337 C8                                 iny
0D338 CA                                 dex                        ;move onto next sprite
0D339 10 F4                              bpl VineTL                 ;loop until all sprites are done
0D33B A4 02                              ldy $02                    ;get original offset
0D33D A5 00                              lda $00                    ;get offset to vine adding data
0D33F D0 05                              bne SkpVTop                ;if offset not zero, skip this part
0D341 A9 E0                              lda #$e0
0D343 99 01 02                           sta Sprite_Tilenumber,y    ;set other tile number for top of vine
0D346 A2 00                     SkpVTop: ldx #$00                   ;start with the first sprite again
0D348 AD 9D 03                  ChkFTop: lda VineStart_Y_Position   ;get original starting vertical coordinate
0D34B 38                                 sec
0D34C F9 00 02                           sbc Sprite_Y_Position,y    ;subtract top-most sprite's Y coordinate
0D34F C9 64                              cmp #$64                   ;if two coordinates are less than 100/$64 pixels
0D351 90 05                              bcc NextVSp                ;apart, skip this to leave sprite alone
0D353 A9 F8                              lda #$f8
0D355 99 00 02                           sta Sprite_Y_Position,y    ;otherwise move sprite offscreen
0D358 C8                        NextVSp: iny                        ;move offset to next OAM data
0D359 C8                                 iny
0D35A C8                                 iny
0D35B C8                                 iny
0D35C E8                                 inx                        ;move onto next sprite
0D35D E0 06                              cpx #$06                   ;do this until all sprites are checked
0D35F D0 E7                              bne ChkFTop
0D361 A4 00                              ldy $00                    ;return offset set earlier
0D363 60                                 rts
0D364                           
0D364                           SixSpriteStacker:
0D364 A2 06                            ldx #$06           ;do six sprites
0D366 99 00 02                  StkLp: sta Sprite_Data,y  ;store X or Y coordinate into OAM data
0D369 18                               clc
0D36A 69 08                            adc #$08           ;add eight pixels
0D36C C8                               iny
0D36D C8                               iny                ;move offset four bytes forward
0D36E C8                               iny
0D36F C8                               iny
0D370 CA                               dex                ;do another sprite
0D371 D0 F3                            bne StkLp          ;do this until all sprites are done
0D373 A4 02                            ldy $02            ;get saved OAM data offset and leave
0D375 60                               rts
0D376                           
0D376                           ;-------------------------------------------------------------------------------------
0D376                           
0D376                           FirstSprXPos:
0D376 04 00 04 00                     .db $04, $00, $04, $00
0D37A                           
0D37A                           FirstSprYPos:
0D37A 00 04 00 04                     .db $00, $04, $00, $04
0D37E                           
0D37E                           SecondSprXPos:
0D37E 00 08 00 08                     .db $00, $08, $00, $08
0D382                           
0D382                           SecondSprYPos:
0D382 08 00 08 00                     .db $08, $00, $08, $00
0D386                           
0D386                           FirstSprTilenum:
0D386 80 82 81 83                     .db $80, $82, $81, $83
0D38A                           
0D38A                           SecondSprTilenum:
0D38A 81 83 80 82                     .db $81, $83, $80, $82
0D38E                           
0D38E                           HammerSprAttrib:
0D38E 03 03 C3 C3                     .db $03, $03, $c3, $c3
0D392                           
0D392                           DrawHammer:
0D392 BC F3 06                              ldy Misc_SprDataOffset,x    ;get misc object OAM data offset
0D395 AD 47 07                              lda TimerControl
0D398 D0 08                                 bne ForceHPose              ;if master timer control set, skip this part
0D39A B5 2A                                 lda Misc_State,x            ;otherwise get hammer's state
0D39C 29 7F                                 and #%01111111              ;mask out d7
0D39E C9 01                                 cmp #$01                    ;check to see if set to 1 yet
0D3A0 F0 04                                 beq GetHPose                ;if so, branch
0D3A2 A2 00                     ForceHPose: ldx #$00                    ;reset offset here
0D3A4 F0 07                                 beq RenderH                 ;do unconditional branch to rendering part
0D3A6 A5 09                     GetHPose:   lda FrameCounter            ;get frame counter
0D3A8 4A                                    lsr                         ;move d3-d2 to d1-d0
0D3A9 4A                                    lsr
0D3AA 29 03                                 and #%00000011              ;mask out all but d1-d0 (changes every four frames)
0D3AC AA                                    tax                         ;use as timing offset
0D3AD AD BE 03                  RenderH:    lda Misc_Rel_YPos           ;get relative vertical coordinate
0D3B0 18                                    clc
0D3B1 7D 7A D3                              adc FirstSprYPos,x          ;add first sprite vertical adder based on offset
0D3B4 99 00 02                              sta Sprite_Y_Position,y     ;store as sprite Y coordinate for first sprite
0D3B7 18                                    clc
0D3B8 7D 82 D3                              adc SecondSprYPos,x         ;add second sprite vertical adder based on offset
0D3BB 99 04 02                              sta Sprite_Y_Position+4,y   ;store as sprite Y coordinate for second sprite
0D3BE AD B3 03                              lda Misc_Rel_XPos           ;get relative horizontal coordinate
0D3C1 18                                    clc
0D3C2 7D 76 D3                              adc FirstSprXPos,x          ;add first sprite horizontal adder based on offset
0D3C5 99 03 02                              sta Sprite_X_Position,y     ;store as sprite X coordinate for first sprite
0D3C8 18                                    clc
0D3C9 7D 7E D3                              adc SecondSprXPos,x         ;add second sprite horizontal adder based on offset
0D3CC 99 07 02                              sta Sprite_X_Position+4,y   ;store as sprite X coordinate for second sprite
0D3CF BD 86 D3                              lda FirstSprTilenum,x
0D3D2 99 01 02                              sta Sprite_Tilenumber,y     ;get and store tile number of first sprite
0D3D5 BD 8A D3                              lda SecondSprTilenum,x
0D3D8 99 05 02                              sta Sprite_Tilenumber+4,y   ;get and store tile number of second sprite
0D3DB BD 8E D3                              lda HammerSprAttrib,x
0D3DE 99 02 02                              sta Sprite_Attributes,y     ;get and store attribute bytes for both
0D3E1 99 06 02                              sta Sprite_Attributes+4,y   ;note in this case they use the same data
0D3E4 A6 08                                 ldx ObjectOffset            ;get misc object offset
0D3E6 AD D6 03                              lda Misc_OffscreenBits
0D3E9 29 FC                                 and #%11111100              ;check offscreen bits
0D3EB F0 09                                 beq NoHOffscr               ;if all bits clear, leave object alone
0D3ED A9 00                                 lda #$00
0D3EF 95 2A                                 sta Misc_State,x            ;otherwise nullify misc object state
0D3F1 A9 F8                                 lda #$f8
0D3F3 20 79 D4                              jsr DumpTwoSpr              ;do sub to move hammer sprites offscreen
0D3F6 60                        NoHOffscr:  rts                         ;leave
0D3F7                           
0D3F7                           ;-------------------------------------------------------------------------------------
0D3F7                           ;$00-$01 - used to hold tile numbers ($01 addressed in draw floatey number part)
0D3F7                           ;$02 - used to hold Y coordinate for floatey number
0D3F7                           ;$03 - residual byte used for flip (but value set here affects nothing)
0D3F7                           ;$04 - attribute byte for floatey number
0D3F7                           ;$05 - used as X coordinate for floatey number
0D3F7                           
0D3F7                           FlagpoleScoreNumTiles:
0D3F7 F9 50                           .db $f9, $50
0D3F9 F7 50                           .db $f7, $50
0D3FB FA FB                           .db $fa, $fb
0D3FD F8 FB                           .db $f8, $fb
0D3FF F6 FB                           .db $f6, $fb
0D401 FD FE                           .db $fd, $fe
0D403                           
0D403                           FlagpoleGfxHandler:
0D403 BC E5 06                        ldy Enemy_SprDataOffset,x      ;get sprite data offset for flagpole flag
0D406 AD AE 03                        lda Enemy_Rel_XPos             ;get relative horizontal coordinate
0D409 99 03 02                        sta Sprite_X_Position,y        ;store as X coordinate for first sprite
0D40C 18                              clc
0D40D 69 08                           adc #$08                       ;add eight pixels and store
0D40F 99 07 02                        sta Sprite_X_Position+4,y      ;as X coordinate for second and third sprites
0D412 99 0B 02                        sta Sprite_X_Position+8,y
0D415 18                              clc
0D416 69 0C                           adc #$0c                       ;add twelve more pixels and
0D418 85 05                           sta $05                        ;store here to be used later by floatey number
0D41A B5 CF                           lda Enemy_Y_Position,x         ;get vertical coordinate
0D41C 20 79 D4                        jsr DumpTwoSpr                 ;and do sub to dump into first and second sprites
0D41F 69 08                           adc #$08                       ;add eight pixels
0D421 99 08 02                        sta Sprite_Y_Position+8,y      ;and store into third sprite
0D424 AD 0D 01                        lda FlagpoleFNum_Y_Pos         ;get vertical coordinate for floatey number
0D427 85 02                           sta $02                        ;store it here
0D429 A9 01                           lda #$01
0D42B 85 03                           sta $03                        ;set value for flip which will not be used, and
0D42D 85 04                           sta $04                        ;attribute byte for floatey number
0D42F 99 02 02                        sta Sprite_Attributes,y        ;set attribute bytes for all three sprites
0D432 99 06 02                        sta Sprite_Attributes+4,y
0D435 99 0A 02                        sta Sprite_Attributes+8,y
0D438 A9 7E                           lda #$7e
0D43A 99 01 02                        sta Sprite_Tilenumber,y        ;put triangle shaped tile
0D43D 99 09 02                        sta Sprite_Tilenumber+8,y      ;into first and third sprites
0D440 A9 7F                           lda #$7f
0D442 99 05 02                        sta Sprite_Tilenumber+4,y      ;put skull tile into second sprite
0D445 AD 0F 07                        lda FlagpoleCollisionYPos      ;get vertical coordinate at time of collision
0D448 F0 15                           beq ChkFlagOffscreen           ;if zero, branch ahead
0D44A 98                              tya
0D44B 18                              clc                            ;add 12 bytes to sprite data offset
0D44C 69 0C                           adc #$0c
0D44E A8                              tay                            ;put back in Y
0D44F AD 0F 01                        lda FlagpoleScore              ;get offset used to award points for touching flagpole
0D452 0A                              asl                            ;multiply by 2 to get proper offset here
0D453 AA                              tax
0D454 BD F7 D3                        lda FlagpoleScoreNumTiles,x    ;get appropriate tile data
0D457 85 00                           sta $00
0D459 BD F8 D3                        lda FlagpoleScoreNumTiles+1,x
0D45C 20 B5 DA                        jsr DrawOneSpriteRow           ;use it to render floatey number
0D45F                           
0D45F                           ChkFlagOffscreen:
0D45F A6 08                           ldx ObjectOffset               ;get object offset for flag
0D461 BC E5 06                        ldy Enemy_SprDataOffset,x      ;get OAM data offset
0D464 AD D1 03                        lda Enemy_OffscreenBits        ;get offscreen bits
0D467 29 0E                           and #%00001110                 ;mask out all but d3-d1
0D469 F0 14                           beq ExitDumpSpr                ;if none of these bits set, branch to leave
0D46B                           
0D46B                           ;-------------------------------------------------------------------------------------
0D46B                           
0D46B                           MoveSixSpritesOffscreen:
0D46B A9 F8                           lda #$f8                  ;set offscreen coordinate if jumping here
0D46D                           
0D46D                           DumpSixSpr:
0D46D 99 14 02                        sta Sprite_Data+20,y      ;dump A contents
0D470 99 10 02                        sta Sprite_Data+16,y      ;into third row sprites
0D473                           
0D473                           DumpFourSpr:
0D473 99 0C 02                        sta Sprite_Data+12,y      ;into second row sprites
0D476                           
0D476                           DumpThreeSpr:
0D476 99 08 02                        sta Sprite_Data+8,y
0D479                           
0D479                           DumpTwoSpr:
0D479 99 04 02                        sta Sprite_Data+4,y       ;and into first row sprites
0D47C 99 00 02                        sta Sprite_Data,y
0D47F                           
0D47F                           ExitDumpSpr:
0D47F 60                              rts
0D480                           
0D480                           ;-------------------------------------------------------------------------------------
0D480                           
0D480                           DrawLargePlatform:
0D480 BC E5 06                        ldy Enemy_SprDataOffset,x   ;get OAM data offset
0D483 84 02                           sty $02                     ;store here
0D485 C8                              iny                         ;add 3 to it for offset
0D486 C8                              iny                         ;to X coordinate
0D487 C8                              iny
0D488 AD AE 03                        lda Enemy_Rel_XPos          ;get horizontal relative coordinate
0D48B 20 64 D3                        jsr SixSpriteStacker        ;store X coordinates using A as base, stack horizontally
0D48E A6 08                           ldx ObjectOffset
0D490 B5 CF                           lda Enemy_Y_Position,x      ;get vertical coordinate
0D492 20 73 D4                        jsr DumpFourSpr             ;dump into first four sprites as Y coordinate
0D495 AC 4E 07                        ldy AreaType
0D498 C0 03                           cpy #$03                    ;check for castle-type level
0D49A F0 05                           beq ShrinkPlatform
0D49C AC CC 06                        ldy SecondaryHardMode       ;check for secondary hard mode flag set
0D49F F0 02                           beq SetLast2Platform        ;branch if not set elsewhere
0D4A1                           
0D4A1                           ShrinkPlatform:
0D4A1 A9 F8                           lda #$f8                    ;load offscreen coordinate if flag set or castle-type level
0D4A3                           
0D4A3                           SetLast2Platform:
0D4A3 BC E5 06                        ldy Enemy_SprDataOffset,x   ;get OAM data offset
0D4A6 99 10 02                        sta Sprite_Y_Position+16,y  ;store vertical coordinate or offscreen
0D4A9 99 14 02                        sta Sprite_Y_Position+20,y  ;coordinate into last two sprites as Y coordinate
0D4AC A9 5B                           lda #$5b                    ;load default tile for platform (mushroom)
0D4AE AE 43 07                        ldx CloudTypeOverride
0D4B1 F0 02                           beq SetPlatformTilenum      ;if cloud level override flag not set, use
0D4B3 A9 75                           lda #$75                    ;otherwise load other tile for platform (puff)
0D4B5                           
0D4B5                           SetPlatformTilenum:
0D4B5 A6 08                             ldx ObjectOffset            ;get enemy object buffer offset
0D4B7 C8                                iny                         ;increment Y for tile offset
0D4B8 20 6D D4                          jsr DumpSixSpr              ;dump tile number into all six sprites
0D4BB A9 02                             lda #$02                    ;set palette controls
0D4BD C8                                iny                         ;increment Y for sprite attributes
0D4BE 20 6D D4                          jsr DumpSixSpr              ;dump attributes into all six sprites
0D4C1 E8                                inx                         ;increment X for enemy objects
0D4C2 20 03 E1                          jsr GetXOffscreenBits       ;get offscreen bits again
0D4C5 CA                                dex
0D4C6 BC E5 06                          ldy Enemy_SprDataOffset,x   ;get OAM data offset
0D4C9 0A                                asl                         ;rotate d7 into carry, save remaining
0D4CA 48                                pha                         ;bits to the stack
0D4CB 90 05                             bcc SChk2
0D4CD A9 F8                             lda #$f8                    ;if d7 was set, move first sprite offscreen
0D4CF 99 00 02                          sta Sprite_Y_Position,y
0D4D2 68                        SChk2:  pla                         ;get bits from stack
0D4D3 0A                                asl                         ;rotate d6 into carry
0D4D4 48                                pha                         ;save to stack
0D4D5 90 05                             bcc SChk3
0D4D7 A9 F8                             lda #$f8                    ;if d6 was set, move second sprite offscreen
0D4D9 99 04 02                          sta Sprite_Y_Position+4,y
0D4DC 68                        SChk3:  pla                         ;get bits from stack
0D4DD 0A                                asl                         ;rotate d5 into carry
0D4DE 48                                pha                         ;save to stack
0D4DF 90 05                             bcc SChk4
0D4E1 A9 F8                             lda #$f8                    ;if d5 was set, move third sprite offscreen
0D4E3 99 08 02                          sta Sprite_Y_Position+8,y
0D4E6 68                        SChk4:  pla                         ;get bits from stack
0D4E7 0A                                asl                         ;rotate d4 into carry
0D4E8 48                                pha                         ;save to stack
0D4E9 90 05                             bcc SChk5
0D4EB A9 F8                             lda #$f8                    ;if d4 was set, move fourth sprite offscreen
0D4ED 99 0C 02                          sta Sprite_Y_Position+12,y
0D4F0 68                        SChk5:  pla                         ;get bits from stack
0D4F1 0A                                asl                         ;rotate d3 into carry
0D4F2 48                                pha                         ;save to stack
0D4F3 90 05                             bcc SChk6
0D4F5 A9 F8                             lda #$f8                    ;if d3 was set, move fifth sprite offscreen
0D4F7 99 10 02                          sta Sprite_Y_Position+16,y
0D4FA 68                        SChk6:  pla                         ;get bits from stack
0D4FB 0A                                asl                         ;rotate d2 into carry
0D4FC 90 05                             bcc SLChk                   ;save to stack
0D4FE A9 F8                             lda #$f8
0D500 99 14 02                          sta Sprite_Y_Position+20,y  ;if d2 was set, move sixth sprite offscreen
0D503 AD D1 03                  SLChk:  lda Enemy_OffscreenBits     ;check d7 of offscreen bits
0D506 0A                                asl                         ;and if d7 is not set, skip sub
0D507 90 03                             bcc ExDLPl
0D509 20 6B D4                          jsr MoveSixSpritesOffscreen ;otherwise branch to move all sprites offscreen
0D50C 60                        ExDLPl: rts
0D50D                           
0D50D                           ;-------------------------------------------------------------------------------------
0D50D                           
0D50D                           DrawFloateyNumber_Coin:
0D50D A5 09                               lda FrameCounter          ;get frame counter
0D50F 4A                                  lsr                       ;divide by 2
0D510 B0 02                               bcs NotRsNum              ;branch if d0 not set to raise number every other frame
0D512 D6 DB                               dec Misc_Y_Position,x     ;otherwise, decrement vertical coordinate
0D514 B5 DB                     NotRsNum: lda Misc_Y_Position,x     ;get vertical coordinate
0D516 20 79 D4                            jsr DumpTwoSpr            ;dump into both sprites
0D519 AD B3 03                            lda Misc_Rel_XPos         ;get relative horizontal coordinate
0D51C 99 03 02                            sta Sprite_X_Position,y   ;store as X coordinate for first sprite
0D51F 18                                  clc
0D520 69 08                               adc #$08                  ;add eight pixels
0D522 99 07 02                            sta Sprite_X_Position+4,y ;store as X coordinate for second sprite
0D525 A9 02                               lda #$02
0D527 99 02 02                            sta Sprite_Attributes,y   ;store attribute byte in both sprites
0D52A 99 06 02                            sta Sprite_Attributes+4,y
0D52D A9 F7                               lda #$f7
0D52F 99 01 02                            sta Sprite_Tilenumber,y   ;put tile numbers into both sprites
0D532 A9 FB                               lda #$fb                  ;that resemble "200"
0D534 99 05 02                            sta Sprite_Tilenumber+4,y
0D537 4C 75 D5                            jmp ExJCGfx               ;then jump to leave (why not an rts here instead?)
0D53A                           
0D53A                           JumpingCoinTiles:
0D53A 60 61 62 63                     .db $60, $61, $62, $63
0D53E                           
0D53E                           JCoinGfxHandler:
0D53E BC F3 06                           ldy Misc_SprDataOffset,x    ;get coin/floatey number's OAM data offset
0D541 B5 2A                              lda Misc_State,x            ;get state of misc object
0D543 C9 02                              cmp #$02                    ;if 2 or greater, 
0D545 B0 C6                              bcs DrawFloateyNumber_Coin  ;branch to draw floatey number
0D547 B5 DB                              lda Misc_Y_Position,x       ;store vertical coordinate as
0D549 99 00 02                           sta Sprite_Y_Position,y     ;Y coordinate for first sprite
0D54C 18                                 clc
0D54D 69 08                              adc #$08                    ;add eight pixels
0D54F 99 04 02                           sta Sprite_Y_Position+4,y   ;store as Y coordinate for second sprite
0D552 AD B3 03                           lda Misc_Rel_XPos           ;get relative horizontal coordinate
0D555 99 03 02                           sta Sprite_X_Position,y
0D558 99 07 02                           sta Sprite_X_Position+4,y   ;store as X coordinate for first and second sprites
0D55B A5 09                              lda FrameCounter            ;get frame counter
0D55D 4A                                 lsr                         ;divide by 2 to alter every other frame
0D55E 29 03                              and #%00000011              ;mask out d2-d1
0D560 AA                                 tax                         ;use as graphical offset
0D561 BD 3A D5                           lda JumpingCoinTiles,x      ;load tile number
0D564 C8                                 iny                         ;increment OAM data offset to write tile numbers
0D565 20 79 D4                           jsr DumpTwoSpr              ;do sub to dump tile number into both sprites
0D568 88                                 dey                         ;decrement to get old offset
0D569 A9 02                              lda #$02
0D56B 99 02 02                           sta Sprite_Attributes,y     ;set attribute byte in first sprite
0D56E A9 82                              lda #$82
0D570 99 06 02                           sta Sprite_Attributes+4,y   ;set attribute byte with vertical flip in second sprite
0D573 A6 08                              ldx ObjectOffset            ;get misc object offset
0D575 60                        ExJCGfx: rts                         ;leave
0D576                           
0D576                           ;-------------------------------------------------------------------------------------
0D576                           ;$00-$01 - used to hold tiles for drawing the power-up, $00 also used to hold power-up type
0D576                           ;$02 - used to hold bottom row Y position
0D576                           ;$03 - used to hold flip control (not used here)
0D576                           ;$04 - used to hold sprite attributes
0D576                           ;$05 - used to hold X position
0D576                           ;$07 - counter
0D576                           
0D576                           ;tiles arranged in top left, right, bottom left, right order
0D576                           PowerUpGfxTable:
0D576 D8 DA DB FF                     .db $d8, $da, $db, $ff ;regular mushroom
0D57A D6 D6 D9 D9                     .db $d6, $d6, $d9, $d9 ;fire flower
0D57E 8D 8D E4 E4                     .db $8d, $8d, $e4, $e4 ;star
0D582 D8 DA DB FF                     .db $d8, $da, $db, $ff ;1-up mushroom
0D586 D8 DA DB FF                     .db $d8, $da, $db, $ff ;poison mushroom
0D58A                           
0D58A                           PowerUpAttributes:
0D58A 02 01 02 01 03                  .db $02, $01, $02, $01, $03
0D58F                           
0D58F                           DrawPowerUp:
0D58F AC EA 06                        ldy Enemy_SprDataOffset+5  ;get power-up's sprite data offset
0D592 AD B9 03                        lda Enemy_Rel_YPos         ;get relative vertical coordinate
0D595 18                              clc
0D596 69 08                           adc #$08                   ;add eight pixels
0D598 85 02                           sta $02                    ;store result here
0D59A AD AE 03                        lda Enemy_Rel_XPos         ;get relative horizontal coordinate
0D59D 85 05                           sta $05                    ;store here
0D59F A6 39                           ldx PowerUpType            ;get power-up type
0D5A1 BD 8A D5                        lda PowerUpAttributes,x    ;get attribute data for power-up type
0D5A4 0D CA 03                        ora Enemy_SprAttrib+5      ;add background priority bit if set
0D5A7 85 04                           sta $04                    ;store attributes here
0D5A9 8A                              txa
0D5AA 48                              pha                        ;save power-up type to the stack
0D5AB 0A                              asl
0D5AC 0A                              asl                        ;multiply by four to get proper offset
0D5AD AA                              tax                        ;use as X
0D5AE A9 01                           lda #$01
0D5B0 85 07                           sta $07                    ;set counter here to draw two rows of sprite object
0D5B2 85 03                           sta $03                    ;init d1 of flip control
0D5B4                           
0D5B4                           PUpDrawLoop:
0D5B4 BD 76 D5                          lda PowerUpGfxTable,x      ;load left tile of power-up object
0D5B7 85 00                             sta $00
0D5B9 BD 77 D5                          lda PowerUpGfxTable+1,x    ;load right tile
0D5BC 20 B5 DA                          jsr DrawOneSpriteRow       ;branch to draw one row of our power-up object
0D5BF C6 07                             dec $07                    ;decrement counter
0D5C1 10 F1                             bpl PUpDrawLoop            ;branch until two rows are drawn
0D5C3 AC EA 06                          ldy Enemy_SprDataOffset+5  ;get sprite data offset again
0D5C6 68                                pla                        ;pull saved power-up type from the stack
0D5C7 F0 33                             beq PUpOfs                 ;if regular mushroom, 1-up mushroom
0D5C9 C9 03                             cmp #$03                   ;or poison mushroom, branch
0D5CB F0 2F                             beq PUpOfs                 ;do not change colors or flip them
0D5CD C9 04                             cmp #$04
0D5CF F0 2B                             beq PUpOfs
0D5D1 85 00                             sta $00                    ;store power-up type here now
0D5D3 A5 09                             lda FrameCounter           ;get frame counter
0D5D5 4A                                lsr                        ;divide by 2 to change colors every two frames
0D5D6 29 03                             and #%00000011             ;mask out all but d1 and d0 (previously d2 and d1)
0D5D8 0D CA 03                          ora Enemy_SprAttrib+5      ;add background priority bit if any set
0D5DB 99 02 02                          sta Sprite_Attributes,y    ;set as new palette bits for top left and
0D5DE 99 06 02                          sta Sprite_Attributes+4,y  ;top right sprites for fire flower and star
0D5E1 A6 00                             ldx $00
0D5E3 CA                                dex                        ;check power-up type for fire flower
0D5E4 F0 06                             beq FlipPUpRightSide       ;if found, skip this part
0D5E6 99 0A 02                          sta Sprite_Attributes+8,y  ;otherwise set new palette bits for bottom left
0D5E9 99 0E 02                          sta Sprite_Attributes+12,y ;and bottom right sprites as well for star only
0D5EC                           
0D5EC                           FlipPUpRightSide:
0D5EC B9 06 02                          lda Sprite_Attributes+4,y
0D5EF 09 40                             ora #%01000000             ;set horizontal flip bit for top right sprite
0D5F1 99 06 02                          sta Sprite_Attributes+4,y
0D5F4 B9 0E 02                          lda Sprite_Attributes+12,y
0D5F7 09 40                             ora #%01000000             ;set horizontal flip bit for bottom right sprite
0D5F9 99 0E 02                          sta Sprite_Attributes+12,y ;note these are only done for fire flower and star power-ups
0D5FC 4C 67 DA                  PUpOfs: jmp SprObjectOffscrChk     ;jump to check to see if power-up is offscreen at all, then leave
0D5FF                           
0D5FF                           
0D5FF                           ;-------------------------------------------------------------------------------------
0D5FF                           ;$00-$01 - used in DrawEnemyObjRow to hold sprite tile numbers
0D5FF                           ;$02 - used to store Y position
0D5FF                           ;$03 - used to store moving direction, used to flip enemies horizontally
0D5FF                           ;$04 - used to store enemy's sprite attributes
0D5FF                           ;$05 - used to store X position
0D5FF                           ;$eb - used to hold sprite data offset
0D5FF                           ;$ec - used to hold either altered enemy state or special value used in gfx handler as condition
0D5FF                           ;$ed - used to hold enemy state from buffer 
0D5FF                           ;$ef - used to hold enemy code used in gfx handler (may or may not resemble Enemy_ID values)
0D5FF                           
0D5FF                           ;tiles arranged in top left, right, middle left, right, bottom left, right order
0D5FF                           ;most enemies use more than one frame, thus have more than 6 tiles
0D5FF                           EnemyGraphicsTable:
0D5FF FC FC AA AB AC AD               .db $fc, $fc, $aa, $ab, $ac, $ad ;buzzy beetle
0D605 FC FC AE AF B0 B1               .db $fc, $fc, $ae, $af, $b0, $b1
0D60B FC A5 A6 A7 A8 A9               .db $fc, $a5, $a6, $a7, $a8, $a9 ;koopa troopa
0D611 FC A0 A1 A2 A3 A4               .db $fc, $a0, $a1, $a2, $a3, $a4
0D617 69 A5 6A A7 A8 A9               .db $69, $a5, $6a, $a7, $a8, $a9 ;koopa paratroopa
0D61D 6B A0 6C A2 A3 A4               .db $6b, $a0, $6c, $a2, $a3, $a4
0D623 FC FC 96 97 98 99               .db $fc, $fc, $96, $97, $98, $99 ;spiny
0D629 FC FC 9A 9B 9C 9D               .db $fc, $fc, $9a, $9b, $9c, $9d
0D62F FC FC 8F 8E 8E 8F               .db $fc, $fc, $8f, $8e, $8e, $8f ;spiny egg
0D635 FC FC 95 94 94 95               .db $fc, $fc, $95, $94, $94, $95
0D63B FC FC DC DC DF DF               .db $fc, $fc, $dc, $dc, $df, $df ;bloober
0D641 DC DC DD DD DE DE               .db $dc, $dc, $dd, $dd, $de, $de
0D647 FC FC B2 B3 B4 B5               .db $fc, $fc, $b2, $b3, $b4, $b5 ;cheep-cheep
0D64D FC FC B6 B3 B7 B5               .db $fc, $fc, $b6, $b3, $b7, $b5
0D653 FC FC 70 71 72 73               .db $fc, $fc, $70, $71, $72, $73 ;goomba
0D659 FC FC 6E 6E 6F 6F               .db $fc, $fc, $6e, $6e, $6f, $6f ;koopa shell (upside-down)
0D65F FC FC 6D 6D 6F 6F               .db $fc, $fc, $6d, $6d, $6f, $6f
0D665 FC FC 6F 6F 6E 6E               .db $fc, $fc, $6f, $6f, $6e, $6e ;koopa shell
0D66B FC FC 6F 6F 6D 6D               .db $fc, $fc, $6f, $6f, $6d, $6d
0D671 FC FC F4 F4 F5 F5               .db $fc, $fc, $f4, $f4, $f5, $f5 ;buzzy beetle shell (upside-down)
0D677 FC FC F4 F4 F5 F5               .db $fc, $fc, $f4, $f4, $f5, $f5
0D67D FC FC F5 F5 F4 F4               .db $fc, $fc, $f5, $f5, $f4, $f4 ;buzzy beetle
0D683 FC FC F5 F5 F4 F4               .db $fc, $fc, $f5, $f5, $f4, $f4
0D689 FC FC FC FC EF EF               .db $fc, $fc, $fc, $fc, $ef, $ef ;defeated goomba
0D68F B9 B8 BB BA BC BC               .db $b9, $b8, $bb, $ba, $bc, $bc ;lakitu
0D695 FC FC BD BD BC BC               .db $fc, $fc, $bd, $bd, $bc, $bc
0D69B 76 79 77 77 78 78               .db $76, $79, $77, $77, $78, $78 ;princess/door to princess's room
0D6A1 CD CD CE CE CF CF               .db $cd, $cd, $ce, $ce, $cf, $cf ;mushroom retainer
0D6A7 7D 7C D1 8C D3 D2               .db $7d, $7c, $d1, $8c, $d3, $d2 ;hammer bro
0D6AD 7D 7C 89 88 8B 8A               .db $7d, $7c, $89, $88, $8b, $8a
0D6B3 D5 D4 E3 E2 D3 D2               .db $d5, $d4, $e3, $e2, $d3, $d2
0D6B9 D5 D4 E3 E2 8B 8A               .db $d5, $d4, $e3, $e2, $8b, $8a
0D6BF E5 E5 E6 E6 EB EB               .db $e5, $e5, $e6, $e6, $eb, $eb ;piranha plant
0D6C5 EC EC ED ED EB EB               .db $ec, $ec, $ed, $ed, $eb, $eb
0D6CB FC FC D0 D0 D7 D7               .db $fc, $fc, $d0, $d0, $d7, $d7 ;podoboo
0D6D1 BF BE C1 C0 C2 FC               .db $bf, $be, $c1, $c0, $c2, $fc ;bowser front
0D6D7 C4 C3 C6 C5 C8 C7               .db $c4, $c3, $c6, $c5, $c8, $c7 ;bowser rear
0D6DD BF BE CA C9 C2 FC               .db $bf, $be, $ca, $c9, $c2, $fc ;front frame 2
0D6E3 C4 C3 C6 C5 CC CB               .db $c4, $c3, $c6, $c5, $cc, $cb ;rear frame 2
0D6E9 FC FC E8 E7 EA E9               .db $fc, $fc, $e8, $e7, $ea, $e9 ;bullet bill
0D6EF F2 F2 F3 F3 F2 F2               .db $f2, $f2, $f3, $f3, $f2, $f2 ;jumpspring
0D6F5 F1 F1 F1 F1 FC FC               .db $f1, $f1, $f1, $f1, $fc, $fc
0D6FB F0 F0 FC FC FC FC               .db $f0, $f0, $fc, $fc, $fc, $fc
0D701                           
0D701                           EnemyGfxTableOffsets:
0D701 0C 0C 00 0C C0 A8 54 3C         .db $0c, $0c, $00, $0c, $c0, $a8, $54, $3c
0D709 EA 18 48 48 CC C0 18 18         .db $ea, $18, $48, $48, $cc, $c0, $18, $18
0D711 18 90 24 FF 48 9C D2 D8         .db $18, $90, $24, $ff, $48, $9c, $d2, $d8
0D719 F0 F6 FC                        .db $f0, $f6, $fc
0D71C                           
0D71C                           EnemyAttributeData:
0D71C 01 02 03 02 22 01 03 03         .db $01, $02, $03, $02, $22, $01, $03, $03
0D724 03 01 01 02 02 20 01 02         .db $03, $01, $01, $02, $02, $20, $01, $02
0D72C 01 01 02 FF 02 02 01 01         .db $01, $01, $02, $ff, $02, $02, $01, $01
0D734 00 00 00                        .db $00, $00, $00
0D737                           
0D737                           EnemyAnimTimingBMask:
0D737 08 18                           .db $08, $18
0D739                           
0D739                           JumpspringFrameOffsets:
0D739 18 19 1A 19 18                  .db $18, $19, $1a, $19, $18
0D73E                           
0D73E                           EnemyGfxHandler:
0D73E B5 CF                            lda Enemy_Y_Position,x      ;get enemy object vertical position
0D740 85 02                            sta $02
0D742 AD AE 03                         lda Enemy_Rel_XPos          ;get enemy object horizontal position
0D745 85 05                            sta $05                     ;relative to screen
0D747 BC E5 06                         ldy Enemy_SprDataOffset,x
0D74A 84 EB                            sty $eb                     ;get sprite data offset
0D74C A9 00                            lda #$00
0D74E 8D 09 01                         sta VerticalFlipFlag        ;initialize vertical flip flag by default
0D751 B5 46                            lda Enemy_MovingDir,x
0D753 85 03                            sta $03                     ;get enemy object moving direction
0D755 BD C5 03                         lda Enemy_SprAttrib,x
0D758 85 04                            sta $04                     ;get enemy object sprite attributes
0D75A B5 16                            lda Enemy_ID,x
0D75C C9 0D                            cmp #PiranhaPlant           ;is enemy object piranha plant?
0D75E D0 1B                            bne CheckForRetainerObj     ;if not, branch
0D760 A0 02                            ldy #$02                    ;default data makes red piranha plants
0D762 AD FB 07                         lda HardWorldFlag
0D765 F0 07                            beq GPlnt                   ;make green piranha plants if playing SMB1 levels
0D767 AD 5F 07                         lda WorldNumber
0D76A C9 03                            cmp #$03
0D76C B0 01                            bcs RPlnt                   ;use default data if in world 4+ of SMB2J
0D76E 88                        GPlnt: dey                         ;otherwise make green piranha plant
0D76F 84 04                     RPlnt: sty $04
0D771 B4 58                            ldy PiranhaPlant_Y_Speed,x
0D773 30 06                            bmi CheckForRetainerObj     ;if piranha plant moving upwards, branch
0D775 BC 8A 07                         ldy EnemyFrameTimer,x
0D778 F0 01                            beq CheckForRetainerObj     ;if timer for movement expired, branch
0D77A 60                               rts                         ;if all conditions fail, leave
0D77B                           
0D77B                           CheckForRetainerObj:
0D77B B5 1E                           lda Enemy_State,x           ;store enemy state
0D77D 85 ED                           sta $ed
0D77F 29 1F                           and #%00011111              ;nullify all but 5 LSB and use as Y
0D781 A8                              tay
0D782 B5 16                           lda Enemy_ID,x              ;check for mushroom retainer/princess object
0D784 C9 35                           cmp #RetainerObject
0D786 D0 08                           bne CheckForBulletBillCV    ;if not found, branch
0D788 A0 00                           ldy #$00                    ;if found, nullify saved state in Y
0D78A A9 01                           lda #$01                    ;set value that will not be used
0D78C 85 03                           sta $03
0D78E A9 15                           lda #$15                    ;set value $15 as code for mushroom retainer/princess object
0D790                           
0D790                           CheckForBulletBillCV:
0D790 C9 33                            cmp #BulletBill_CannonVar   ;otherwise check for bullet bill object
0D792 D0 13                            bne CheckForJumpspring      ;if not found, branch again
0D794 C6 02                            dec $02                     ;decrement saved vertical position
0D796 A9 03                            lda #$03
0D798 BC 8A 07                         ldy EnemyFrameTimer,x       ;get timer for enemy object
0D79B F0 02                            beq SBBAt                   ;if expired, do not set priority bit
0D79D 09 20                            ora #%00100000              ;otherwise do so
0D79F 85 04                     SBBAt: sta $04                     ;set new sprite attributes
0D7A1 A0 00                            ldy #$00                    ;nullify saved enemy state both in Y and in
0D7A3 84 ED                            sty $ed                     ;memory location here
0D7A5 A9 08                            lda #$08                    ;set specific value to unconditionally branch once
0D7A7                           
0D7A7                           CheckForJumpspring:
0D7A7 C9 32                            cmp #JumpspringObject        ;check for jumpspring object
0D7A9 D0 25                            bne CheckForPodoboo
0D7AB A9 02                            lda #$02
0D7AD AC FB 07                         ldy HardWorldFlag            ;check if we're playing SMB1 levels
0D7B0 F0 14                            beq RedJS                    ;if so, paint jumpsprings red
0D7B2 AC 5F 07                         ldy WorldNumber              ;if the world number is not 2, 3, 7 or C
0D7B5 C0 01                            cpy #World2                  ;then use regular attributes for jumpsprings
0D7B7 F0 0C                            beq GrnJS                    ;which will paint them red
0D7B9 C0 02                            cpy #World3
0D7BB F0 08                            beq GrnJS
0D7BD C0 06                            cpy #World7
0D7BF F0 04                            beq GrnJS                    ;otherwise use alternate attributes
0D7C1 C0 0B                            cpy #WorldC                  ;to get the green superhigh jumpsprings
0D7C3 D0 01                            bne RedJS
0D7C5 4A                        GrnJS: lsr
0D7C6 85 04                     RedJS: sta $04
0D7C8 A0 03                            ldy #$03                     ;set enemy state -2 MSB here for jumpspring object
0D7CA AE 0E 07                         ldx JumpspringAnimCtrl       ;get current frame number for jumpspring object
0D7CD BD 39 D7                         lda JumpspringFrameOffsets,x ;load data using frame number as offset
0D7D0                           
0D7D0                           CheckForPodoboo:
0D7D0 85 EF                           sta $ef                 ;store saved enemy object value here
0D7D2 84 EC                           sty $ec                 ;and Y here (enemy state -2 MSB if not changed)
0D7D4 A6 08                           ldx ObjectOffset        ;get enemy object offset
0D7D6 C9 0C                           cmp #$0c                ;check for podoboo object
0D7D8 D0 07                           bne CheckBowserGfxFlag  ;branch if not found
0D7DA B5 A0                           lda Enemy_Y_Speed,x     ;if moving upwards, branch
0D7DC 30 03                           bmi CheckBowserGfxFlag
0D7DE EE 09 01                        inc VerticalFlipFlag    ;otherwise, set flag for vertical flip
0D7E1                           
0D7E1                           CheckBowserGfxFlag:
0D7E1 AD 6A 03                               lda BowserGfxFlag   ;if not drawing bowser at all, skip to something else
0D7E4 F0 09                                  beq CheckForGoomba
0D7E6 A0 16                                  ldy #$16            ;if set to 1, draw bowser's front
0D7E8 C9 01                                  cmp #$01
0D7EA F0 01                                  beq SBwsrGfxOfs
0D7EC C8                                     iny                 ;otherwise draw bowser's rear
0D7ED 84 EF                     SBwsrGfxOfs: sty $ef
0D7EF                           
0D7EF                           CheckForGoomba:
0D7EF A4 EF                               ldy $ef               ;check value for goomba object
0D7F1 C0 06                               cpy #Goomba
0D7F3 D0 1D                               bne CheckBowserFront  ;branch if not found
0D7F5 B5 1E                               lda Enemy_State,x
0D7F7 C9 02                               cmp #$02              ;check for defeated state
0D7F9 90 04                               bcc GmbaAnim          ;if not defeated, go ahead and animate
0D7FB A2 04                               ldx #$04              ;if defeated, write new value here
0D7FD 86 EC                               stx $ec
0D7FF 29 20                     GmbaAnim: and #%00100000        ;check for d5 set in enemy object state 
0D801 0D 47 07                            ora TimerControl      ;or timer disable flag set
0D804 D0 0C                               bne CheckBowserFront  ;if either condition true, do not animate goomba
0D806 A5 09                               lda FrameCounter
0D808 29 08                               and #%00001000        ;check for every eighth frame
0D80A D0 06                               bne CheckBowserFront
0D80C A5 03                               lda $03
0D80E 49 03                               eor #%00000011        ;invert bits to flip horizontally every eight frames
0D810 85 03                               sta $03               ;leave alone otherwise
0D812                           
0D812                           CheckBowserFront:
0D812 B9 1C D7                               lda EnemyAttributeData,y    ;load sprite attribute using enemy object
0D815 05 04                                  ora $04                     ;as offset, and add to bits already loaded
0D817 85 04                                  sta $04
0D819 B9 01 D7                               lda EnemyGfxTableOffsets,y  ;load value based on enemy object as offset
0D81C AA                                     tax                         ;save as X
0D81D A4 EC                                  ldy $ec                     ;get previously saved value
0D81F AD 6A 03                               lda BowserGfxFlag
0D822 F0 30                                  beq CheckForSpiny           ;if not drawing bowser object at all, skip all of this
0D824 C9 01                                  cmp #$01
0D826 D0 13                                  bne CheckBowserRear         ;if not drawing front part, branch to draw the rear part
0D828 AD 63 03                               lda BowserBodyControls      ;check bowser's body control bits
0D82B 10 02                                  bpl ChkFrontSte             ;branch if d7 not set (control's bowser's mouth)      
0D82D A2 DE                                  ldx #$de                    ;otherwise load offset for second frame
0D82F A5 ED                     ChkFrontSte: lda $ed                     ;check saved enemy state
0D831 29 20                                  and #%00100000              ;if bowser not defeated, do not set flag
0D833 F0 03                                  beq DrawBowser
0D835                           
0D835                           FlipBowserOver:
0D835 8E 09 01                        stx VerticalFlipFlag  ;set vertical flip flag to nonzero
0D838                           
0D838                           DrawBowser:
0D838 4C 44 D9                        jmp DrawEnemyObject   ;draw bowser's graphics now
0D83B                           
0D83B                           
0D83B                           CheckBowserRear:
0D83B AD 63 03                              lda BowserBodyControls  ;check bowser's body control bits
0D83E 29 01                                 and #$01
0D840 F0 02                                 beq ChkRearSte          ;branch if d0 not set (control's bowser's feet)
0D842 A2 E4                                 ldx #$e4                ;otherwise load offset for second frame
0D844 A5 ED                     ChkRearSte: lda $ed                 ;check saved enemy state
0D846 29 20                                 and #%00100000          ;if bowser not defeated, do not set flag
0D848 F0 EE                                 beq DrawBowser
0D84A A5 02                                 lda $02                 ;subtract 16 pixels from
0D84C 38                                    sec                     ;saved vertical coordinate
0D84D E9 10                                 sbc #$10
0D84F 85 02                                 sta $02
0D851 4C 35 D8                              jmp FlipBowserOver      ;jump to set vertical flip flag
0D854                           
0D854                           CheckForSpiny:
0D854 E0 24                             cpx #$24               ;check if value loaded is for spiny
0D856 D0 11                             bne CheckForLakitu     ;if not found, branch
0D858 C0 05                             cpy #$05               ;if enemy state set to $05, do this,
0D85A D0 0A                             bne NotEgg             ;otherwise branch
0D85C A2 30                             ldx #$30               ;set to spiny egg offset
0D85E A9 02                             lda #$02
0D860 85 03                             sta $03                ;set enemy direction to reverse sprites horizontally
0D862 A9 05                             lda #$05
0D864 85 EC                             sta $ec                ;set enemy state
0D866 4C B9 D8                  NotEgg: jmp CheckForHammerBro  ;skip a big chunk of this if we found spiny but not in egg
0D869                           
0D869                           CheckForLakitu:
0D869 E0 90                             cpx #$90                  ;check value for lakitu's offset loaded
0D86B D0 12                             bne CheckUpsideDownShell  ;branch if not loaded
0D86D A5 ED                             lda $ed
0D86F 29 20                             and #%00100000            ;check for d5 set in enemy state
0D871 D0 09                             bne NoLAFr                ;branch if set
0D873 AD 8F 07                          lda FrenzyEnemyTimer
0D876 C9 10                             cmp #$10                  ;check timer to see if we've reached a certain range
0D878 B0 02                             bcs NoLAFr                ;branch if not
0D87A A2 96                             ldx #$96                  ;if d6 not set and timer in range, load alt frame for lakitu
0D87C 4C 2A D9                  NoLAFr: jmp CheckDefeatedState    ;skip this next part if we found lakitu but alt frame not needed
0D87F                           
0D87F                           CheckUpsideDownShell:
0D87F A5 EF                           lda $ef                    ;check for enemy object => $04
0D881 C9 04                           cmp #$04
0D883 B0 10                           bcs CheckRightSideUpShell  ;branch if true
0D885 C0 02                           cpy #$02
0D887 90 0C                           bcc CheckRightSideUpShell  ;branch if enemy state < $02
0D889 A2 5A                           ldx #$5a                   ;set for upside-down koopa shell by default
0D88B A4 EF                           ldy $ef
0D88D C0 02                           cpy #BuzzyBeetle           ;check for buzzy beetle object
0D88F D0 04                           bne CheckRightSideUpShell
0D891 A2 7E                           ldx #$7e                   ;set for upside-down buzzy beetle shell if found
0D893 E6 02                           inc $02                    ;increment vertical position by one pixel
0D895                           
0D895                           CheckRightSideUpShell:
0D895 A5 EC                           lda $ec                ;check for value set here
0D897 C9 04                           cmp #$04               ;if enemy state < $02, do not change to shell, if
0D899 D0 1E                           bne CheckForHammerBro  ;enemy state => $02 but not = $04, leave shell upside-down
0D89B A2 72                           ldx #$72               ;set right-side up buzzy beetle shell by default
0D89D E6 02                           inc $02                ;increment saved vertical position by one pixel
0D89F A4 EF                           ldy $ef
0D8A1 C0 02                           cpy #BuzzyBeetle       ;check for buzzy beetle object
0D8A3 F0 04                           beq CheckForDefdGoomba ;branch if found
0D8A5 A2 66                           ldx #$66               ;change to right-side up koopa shell if not found
0D8A7 E6 02                           inc $02                ;and increment saved vertical position again
0D8A9                           
0D8A9                           CheckForDefdGoomba:
0D8A9 C0 06                           cpy #Goomba            ;check for goomba object (necessary if previously
0D8AB D0 0C                           bne CheckForHammerBro  ;failed buzzy beetle object test)
0D8AD A2 54                           ldx #$54               ;load for regular goomba
0D8AF A5 ED                           lda $ed                ;note that this only gets performed if enemy state => $02
0D8B1 29 20                           and #%00100000         ;check saved enemy state for d5 set
0D8B3 D0 04                           bne CheckForHammerBro  ;branch if set
0D8B5 A2 8A                           ldx #$8a               ;load offset for defeated goomba
0D8B7 C6 02                           dec $02                ;set different value and decrement saved vertical position
0D8B9                           
0D8B9                           CheckForHammerBro:
0D8B9 A4 08                           ldy ObjectOffset
0D8BB A5 EF                           lda $ef                  ;check for hammer bro object
0D8BD C9 05                           cmp #HammerBro
0D8BF D0 0C                           bne CheckForBloober      ;branch if not found
0D8C1 A5 ED                           lda $ed
0D8C3 F0 24                           beq CheckToAnimateEnemy  ;branch if not in normal enemy state
0D8C5 29 08                           and #%00001000
0D8C7 F0 61                           beq CheckDefeatedState   ;if d3 not set, branch further away
0D8C9 A2 B4                           ldx #$b4                 ;otherwise load offset for different frame
0D8CB D0 1C                           bne CheckToAnimateEnemy  ;unconditional branch
0D8CD                           
0D8CD                           CheckForBloober:
0D8CD E0 48                           cpx #$48                 ;check for cheep-cheep offset loaded
0D8CF F0 18                           beq CheckToAnimateEnemy  ;branch if found
0D8D1 B9 96 07                        lda EnemyIntervalTimer,y
0D8D4 C9 05                           cmp #$05
0D8D6 B0 52                           bcs CheckDefeatedState   ;branch if some timer is above a certain point
0D8D8 E0 3C                           cpx #$3c                 ;check for bloober offset loaded
0D8DA D0 0D                           bne CheckToAnimateEnemy  ;branch if not found this time
0D8DC C9 01                           cmp #$01
0D8DE F0 4A                           beq CheckDefeatedState   ;branch if timer is set to certain point
0D8E0 E6 02                           inc $02                  ;increment saved vertical coordinate three pixels
0D8E2 E6 02                           inc $02
0D8E4 E6 02                           inc $02
0D8E6 4C 1C D9                        jmp CheckAnimationStop   ;and do something else
0D8E9                           
0D8E9                           CheckToAnimateEnemy:
0D8E9 A5 EF                           lda $ef                  ;check for specific enemy objects
0D8EB C9 06                           cmp #Goomba
0D8ED F0 3B                           beq CheckDefeatedState   ;branch if goomba
0D8EF C9 08                           cmp #$08
0D8F1 F0 37                           beq CheckDefeatedState   ;branch if bullet bill (note both variants use $08 here)
0D8F3 C9 0C                           cmp #Podoboo
0D8F5 F0 33                           beq CheckDefeatedState   ;branch if podoboo
0D8F7 C9 18                           cmp #$18                 ;branch if => $18
0D8F9 B0 2F                           bcs CheckDefeatedState
0D8FB A0 00                           ldy #$00    
0D8FD C9 15                           cmp #$15                 ;check for mushroom retainer/princess object
0D8FF D0 14                           bne CheckForSecondFrame  ;which uses different code here, branch if not found
0D901 C8                              iny                      ;residual instruction
0D902 A9 03                           lda #$03                 ;set state for mushroom retainer/princess object
0D904 85 EC                           sta $ec
0D906 AD 5F 07                        lda WorldNumber          ;are we on world 8?
0D909 C9 07                           cmp #World8
0D90B F0 1D                           beq CheckDefeatedState   ;if so, leave the offset alone (use princess)
0D90D C9 0C                           cmp #WorldD              ;are we on world D?
0D90F F0 19                           beq CheckDefeatedState   ;if so, leave the offset alone (use princess)
0D911 A2 A2                           ldx #$a2                 ;otherwise, set for mushroom retainer object instead
0D913 D0 15                           bne CheckDefeatedState   ;unconditional branch
0D915                           
0D915                           CheckForSecondFrame:
0D915 A5 09                           lda FrameCounter            ;load frame counter
0D917 39 37 D7                        and EnemyAnimTimingBMask,y  ;mask it (partly residual, one byte not ever used)
0D91A D0 0E                           bne CheckDefeatedState      ;branch if timing is off
0D91C                           
0D91C                           CheckAnimationStop:
0D91C A5 ED                           lda $ed                 ;check saved enemy state
0D91E 29 A0                           and #%10100000          ;for d7 or d5, or check for timers stopped
0D920 0D 47 07                        ora TimerControl
0D923 D0 05                           bne CheckDefeatedState  ;if either condition true, branch
0D925 8A                              txa
0D926 18                              clc
0D927 69 06                           adc #$06                ;add $06 to current enemy offset
0D929 AA                              tax                     ;to animate various enemy objects
0D92A                           
0D92A                           CheckDefeatedState:
0D92A A5 EF                            lda $ef               ;check for upside-down piranha plant
0D92C C9 04                            cmp #$04              ;if found, branch to draw it upside-down
0D92E F0 0C                            beq FlipV
0D930 A5 ED                            lda $ed               ;check saved enemy state
0D932 29 20                            and #%00100000        ;for d5 set
0D934 F0 0E                            beq DrawEnemyObject   ;branch if not set
0D936 A5 EF                            lda $ef
0D938 C9 04                            cmp #$04              ;check for saved enemy object => $04
0D93A 90 08                            bcc DrawEnemyObject   ;branch if less
0D93C A0 01                     FlipV: ldy #$01
0D93E 8C 09 01                         sty VerticalFlipFlag  ;set vertical flip flag
0D941 88                               dey
0D942 84 EC                            sty $ec               ;init saved value here
0D944                           
0D944                           DrawEnemyObject:
0D944 A4 EB                           ldy $eb                    ;load sprite data offset
0D946 20 AD DA                        jsr DrawEnemyObjRow        ;draw six tiles of data
0D949 20 AD DA                        jsr DrawEnemyObjRow        ;into sprite data
0D94C 20 AD DA                        jsr DrawEnemyObjRow
0D94F A6 08                           ldx ObjectOffset           ;get enemy object offset
0D951 BC E5 06                        ldy Enemy_SprDataOffset,x  ;get sprite data offset
0D954 A5 EF                           lda $ef
0D956 C9 08                           cmp #$08                   ;get saved enemy object and check
0D958 D0 03                           bne CheckForVerticalFlip   ;for bullet bill, branch if not found
0D95A                           
0D95A                           SkipToOffScrChk:
0D95A 4C 67 DA                        jmp SprObjectOffscrChk     ;jump if found
0D95D                           
0D95D                           CheckForVerticalFlip:
0D95D AD 09 01                        lda VerticalFlipFlag       ;check if vertical flip flag is set here
0D960 F0 41                           beq CheckForESymmetry      ;branch if not
0D962 B9 02 02                        lda Sprite_Attributes,y    ;get attributes of first sprite we dealt with
0D965 09 80                           ora #%10000000             ;set bit for vertical flip
0D967 C8                              iny
0D968 C8                              iny                        ;increment two bytes so that we store the vertical flip
0D969 20 6D D4                        jsr DumpSixSpr             ;in attribute bytes of enemy obj sprite data
0D96C 88                              dey
0D96D 88                              dey                        ;now go back to the Y coordinate offset
0D96E 98                              tya
0D96F AA                              tax                        ;give offset to X
0D970 A5 EF                           lda $ef
0D972 C9 05                           cmp #HammerBro             ;check saved enemy object for hammer bro
0D974 F0 11                           beq FlipEnemyVertically
0D976 C9 04                           cmp #UpsideDownPiranhaP    ;check saved enemy object for upside-down piranha plant
0D978 F0 0D                           beq FlipEnemyVertically
0D97A C9 11                           cmp #Lakitu                ;check saved enemy object for lakitu
0D97C F0 09                           beq FlipEnemyVertically    ;branch for any of these objects
0D97E C9 15                           cmp #$15
0D980 B0 05                           bcs FlipEnemyVertically    ;also branch if enemy object => $15
0D982 8A                              txa
0D983 18                              clc
0D984 69 08                           adc #$08                   ;if not selected objects or => $15, set
0D986 AA                              tax                        ;offset in X for next row
0D987                           
0D987                           FlipEnemyVertically:
0D987 BD 01 02                        lda Sprite_Tilenumber,x     ;load first or second row tiles
0D98A 48                              pha                         ;and save tiles to the stack
0D98B BD 05 02                        lda Sprite_Tilenumber+4,x
0D98E 48                              pha
0D98F B9 11 02                        lda Sprite_Tilenumber+16,y  ;exchange third row tiles
0D992 9D 01 02                        sta Sprite_Tilenumber,x     ;with first or second row tiles
0D995 B9 15 02                        lda Sprite_Tilenumber+20,y
0D998 9D 05 02                        sta Sprite_Tilenumber+4,x
0D99B 68                              pla                         ;pull first or second row tiles from stack
0D99C 99 15 02                        sta Sprite_Tilenumber+20,y  ;and save in third row
0D99F 68                              pla
0D9A0 99 11 02                        sta Sprite_Tilenumber+16,y
0D9A3                           
0D9A3                           CheckForESymmetry:
0D9A3 AD 6A 03                          lda BowserGfxFlag           ;are we drawing bowser at all?
0D9A6 D0 B2                             bne SkipToOffScrChk         ;branch if so
0D9A8 A5 EF                             lda $ef       
0D9AA A6 EC                             ldx $ec                     ;get alternate enemy state
0D9AC C9 05                             cmp #$05                    ;check for hammer bro object
0D9AE D0 03                             bne ContES
0D9B0 4C 67 DA                          jmp SprObjectOffscrChk      ;jump if found
0D9B3 C9 07                     ContES: cmp #Bloober                ;check for bloober object
0D9B5 F0 21                             beq MirrorEnemyGfx
0D9B7 C9 0D                             cmp #PiranhaPlant           ;check for piranha plant object
0D9B9 F0 1D                             beq MirrorEnemyGfx
0D9BB C9 04                             cmp #UpsideDownPiranhaP     ;check for upside-down piranha plant object
0D9BD F0 19                             beq MirrorEnemyGfx
0D9BF C9 0C                             cmp #Podoboo                ;check for podoboo object
0D9C1 F0 15                             beq MirrorEnemyGfx          ;branch if either of three are found
0D9C3 C9 12                             cmp #Spiny                  ;check for spiny object
0D9C5 D0 04                             bne ESRtnr                  ;branch closer if not found
0D9C7 E0 05                             cpx #$05                    ;check spiny's state
0D9C9 D0 48                             bne CheckToMirrorLakitu     ;branch if not an egg, otherwise
0D9CB C9 15                     ESRtnr: cmp #$15                    ;check for princess/mushroom retainer object
0D9CD D0 05                             bne SpnySC
0D9CF A9 42                             lda #$42                    ;set horizontal flip on bottom right sprite
0D9D1 99 16 02                          sta Sprite_Attributes+20,y  ;note that palette bits were already set earlier
0D9D4 E0 02                     SpnySC: cpx #$02                    ;if alternate enemy state set to 1 or 0, branch
0D9D6 90 3B                             bcc CheckToMirrorLakitu
0D9D8                           
0D9D8                           MirrorEnemyGfx:
0D9D8 AD 6A 03                          lda BowserGfxFlag           ;if enemy object is bowser, skip all of this
0D9DB D0 36                             bne CheckToMirrorLakitu
0D9DD B9 02 02                          lda Sprite_Attributes,y     ;load attribute bits of first sprite
0D9E0 29 A3                             and #%10100011
0D9E2 99 02 02                          sta Sprite_Attributes,y     ;save vertical flip, priority, and palette bits
0D9E5 99 0A 02                          sta Sprite_Attributes+8,y   ;in left sprite column of enemy object OAM data
0D9E8 99 12 02                          sta Sprite_Attributes+16,y
0D9EB 09 40                             ora #%01000000              ;set horizontal flip
0D9ED E0 05                             cpx #$05                    ;check for state used by spiny's egg
0D9EF D0 02                             bne EggExc                  ;if alternate state not set to $05, branch
0D9F1 09 80                             ora #%10000000              ;otherwise set vertical flip
0D9F3 99 06 02                  EggExc: sta Sprite_Attributes+4,y   ;set bits of right sprite column
0D9F6 99 0E 02                          sta Sprite_Attributes+12,y  ;of enemy object sprite data
0D9F9 99 16 02                          sta Sprite_Attributes+20,y
0D9FC E0 04                             cpx #$04                    ;check alternate enemy state
0D9FE D0 13                             bne CheckToMirrorLakitu     ;branch if not $04
0DA00 B9 0A 02                          lda Sprite_Attributes+8,y   ;get second row left sprite attributes
0DA03 09 80                             ora #%10000000
0DA05 99 0A 02                          sta Sprite_Attributes+8,y   ;store bits with vertical flip in
0DA08 99 12 02                          sta Sprite_Attributes+16,y  ;second and third row left sprites
0DA0B 09 40                             ora #%01000000
0DA0D 99 0E 02                          sta Sprite_Attributes+12,y  ;store with horizontal and vertical flip in
0DA10 99 16 02                          sta Sprite_Attributes+20,y  ;second and third row right sprites
0DA13                           
0DA13                           CheckToMirrorLakitu:
0DA13 A5 EF                             lda $ef                     ;check for lakitu enemy object
0DA15 C9 11                             cmp #Lakitu
0DA17 D0 36                             bne CheckToMirrorJSpring    ;branch if not found
0DA19 AD 09 01                          lda VerticalFlipFlag
0DA1C D0 21                             bne NVFLak                  ;branch if vertical flip flag set
0DA1E B9 12 02                          lda Sprite_Attributes+16,y  ;save vertical flip and palette bits
0DA21 29 81                             and #%10000001              ;in third row left sprite
0DA23 99 12 02                          sta Sprite_Attributes+16,y
0DA26 B9 16 02                          lda Sprite_Attributes+20,y  ;set horizontal flip and palette bits
0DA29 09 41                             ora #%01000001              ;in third row right sprite
0DA2B 99 16 02                          sta Sprite_Attributes+20,y
0DA2E AE 8F 07                          ldx FrenzyEnemyTimer        ;check timer
0DA31 E0 10                             cpx #$10
0DA33 B0 32                             bcs SprObjectOffscrChk      ;branch if timer has not reached a certain range
0DA35 99 0E 02                          sta Sprite_Attributes+12,y  ;otherwise set same for second row right sprite
0DA38 29 81                             and #%10000001
0DA3A 99 0A 02                          sta Sprite_Attributes+8,y   ;preserve vertical flip and palette bits for left sprite
0DA3D 90 28                             bcc SprObjectOffscrChk      ;unconditional branch
0DA3F B9 02 02                  NVFLak: lda Sprite_Attributes,y     ;get first row left sprite attributes
0DA42 29 81                             and #%10000001
0DA44 99 02 02                          sta Sprite_Attributes,y     ;save vertical flip and palette bits
0DA47 B9 06 02                          lda Sprite_Attributes+4,y   ;get first row right sprite attributes
0DA4A 09 41                             ora #%01000001              ;set horizontal flip and palette bits
0DA4C 99 06 02                          sta Sprite_Attributes+4,y   ;note that vertical flip is left as-is
0DA4F                           
0DA4F                           CheckToMirrorJSpring:
0DA4F A5 EF                           lda $ef                     ;check for jumpspring object (any frame)
0DA51 C9 18                           cmp #$18
0DA53 90 12                           bcc SprObjectOffscrChk      ;branch if not jumpspring object at all
0DA55 A9 80                           lda #$80
0DA57 05 04                           ora $04
0DA59 99 0A 02                        sta Sprite_Attributes+8,y   ;set vertical flip and palette bits of 
0DA5C 99 12 02                        sta Sprite_Attributes+16,y  ;second and third row left sprites
0DA5F 09 40                           ora #%01000000
0DA61 99 0E 02                        sta Sprite_Attributes+12,y  ;set, in addition to those, horizontal flip
0DA64 99 16 02                        sta Sprite_Attributes+20,y  ;for second and third row right sprites
0DA67                           
0DA67                           SprObjectOffscrChk:
0DA67 A6 08                              ldx ObjectOffset          ;get enemy buffer offset
0DA69 AD D1 03                           lda Enemy_OffscreenBits   ;check offscreen information
0DA6C 4A                                 lsr
0DA6D 4A                                 lsr                       ;shift three times to the right
0DA6E 4A                                 lsr                       ;which puts d2 into carry
0DA6F 48                                 pha                       ;save to stack
0DA70 90 05                              bcc LcChk                 ;branch if not set
0DA72 A9 04                              lda #$04                  ;set for right column sprites
0DA74 20 C4 DA                           jsr MoveESprColOffscreen  ;and move them offscreen
0DA77 68                        LcChk:   pla                       ;get from stack
0DA78 4A                                 lsr                       ;move d3 to carry
0DA79 48                                 pha                       ;save to stack
0DA7A 90 05                              bcc Row3C                 ;branch if not set
0DA7C A9 00                              lda #$00                  ;set for left column sprites,
0DA7E 20 C4 DA                           jsr MoveESprColOffscreen  ;move them offscreen
0DA81 68                        Row3C:   pla                       ;get from stack again
0DA82 4A                                 lsr                       ;move d5 to carry this time
0DA83 4A                                 lsr
0DA84 48                                 pha                       ;save to stack again
0DA85 90 05                              bcc Row23C                ;branch if carry not set
0DA87 A9 10                              lda #$10                  ;set for third row of sprites
0DA89 20 BA DA                           jsr MoveESprRowOffscreen  ;and move them offscreen
0DA8C 68                        Row23C:  pla                       ;get from stack
0DA8D 4A                                 lsr                       ;move d6 into carry
0DA8E 48                                 pha                       ;save to stack
0DA8F 90 05                              bcc AllRowC
0DA91 A9 08                              lda #$08                  ;set for second and third rows
0DA93 20 BA DA                           jsr MoveESprRowOffscreen  ;move them offscreen
0DA96 68                        AllRowC: pla                       ;get from stack once more
0DA97 4A                                 lsr                       ;move d7 into carry
0DA98 90 12                              bcc ExEGHandler
0DA9A 20 BA DA                           jsr MoveESprRowOffscreen  ;move all sprites offscreen (A should be 0 by now)
0DA9D B5 16                              lda Enemy_ID,x
0DA9F C9 0C                              cmp #Podoboo              ;check enemy identifier for podoboo
0DAA1 F0 09                              beq ExEGHandler           ;skip this part if found, we do not want to erase podoboo!
0DAA3 B5 B6                              lda Enemy_Y_HighPos,x     ;check high byte of vertical position
0DAA5 C9 02                              cmp #$02                  ;if not yet past the bottom of the screen, branch
0DAA7 D0 03                              bne ExEGHandler
0DAA9 20 B1 B7                           jsr EraseEnemyObject      ;what it says
0DAAC                           
0DAAC                           ExEGHandler:
0DAAC 60                              rts
0DAAD                           
0DAAD                           DrawEnemyObjRow:
0DAAD BD FF D5                        lda EnemyGraphicsTable,x    ;load two tiles of enemy graphics
0DAB0 85 00                           sta $00
0DAB2 BD 00 D6                        lda EnemyGraphicsTable+1,x
0DAB5                           
0DAB5                           DrawOneSpriteRow:
0DAB5 85 01                           sta $01
0DAB7 4C 8F E1                        jmp DrawSpriteObject        ;draw them
0DABA                           
0DABA                           MoveESprRowOffscreen:
0DABA 18                              clc                         ;add A to enemy object OAM data offset
0DABB 7D E5 06                        adc Enemy_SprDataOffset,x
0DABE A8                              tay                         ;use as offset
0DABF A9 F8                           lda #$f8
0DAC1 4C 79 D4                        jmp DumpTwoSpr              ;move first row of sprites offscreen
0DAC4                           
0DAC4                           MoveESprColOffscreen:
0DAC4 18                              clc                         ;add A to enemy object OAM data offset
0DAC5 7D E5 06                        adc Enemy_SprDataOffset,x
0DAC8 A8                              tay                         ;use as offset
0DAC9 20 4D DB                        jsr MoveColOffscreen        ;move first and second row sprites in column offscreen
0DACC 99 10 02                        sta Sprite_Data+16,y        ;move third row sprite in column offscreen
0DACF 60                              rts
0DAD0                           
0DAD0                           ;-------------------------------------------------------------------------------------
0DAD0                           ;$00-$01 - tile numbers
0DAD0                           ;$02 - relative Y position
0DAD0                           ;$03 - horizontal flip flag (not used here)
0DAD0                           ;$04 - attributes
0DAD0                           ;$05 - relative X position
0DAD0                           
0DAD0                           DefaultBlockObjTiles:
0DAD0 85 85 86 86                     .db $85, $85, $86, $86             ;brick w/ line (these are sprite tiles, not BG!)
0DAD4                           
0DAD4                           DrawBlock:
0DAD4 AD BC 03                             lda Block_Rel_YPos            ;get relative vertical coordinate of block object
0DAD7 85 02                                sta $02                       ;store here
0DAD9 AD B1 03                             lda Block_Rel_XPos            ;get relative horizontal coordinate of block object
0DADC 85 05                                sta $05                       ;store here
0DADE A9 03                                lda #$03
0DAE0 85 04                                sta $04                       ;set attribute byte here
0DAE2 4A                                   lsr
0DAE3 85 03                                sta $03                       ;set horizontal flip bit here (will not be used)
0DAE5 BC EC 06                             ldy Block_SprDataOffset,x     ;get sprite data offset
0DAE8 A2 00                                ldx #$00                      ;reset X for use as offset to tile data
0DAEA BD D0 DA                  DBlkLoop:  lda DefaultBlockObjTiles,x    ;get left tile number
0DAED 85 00                                sta $00                       ;set here
0DAEF BD D1 DA                             lda DefaultBlockObjTiles+1,x  ;get right tile number
0DAF2 20 B5 DA                             jsr DrawOneSpriteRow          ;do sub to write tile numbers to first row of sprites
0DAF5 E0 04                                cpx #$04                      ;check incremented offset
0DAF7 D0 F1                                bne DBlkLoop                  ;and loop back until all four sprites are done
0DAF9 A6 08                                ldx ObjectOffset              ;get block object offset
0DAFB BC EC 06                             ldy Block_SprDataOffset,x     ;get sprite data offset
0DAFE AD 4E 07                             lda AreaType
0DB01 C9 01                                cmp #$01                      ;check for ground level type area
0DB03 F0 08                                beq ChkRep                    ;if found, branch to next part
0DB05 A9 86                                lda #$86
0DB07 99 01 02                             sta Sprite_Tilenumber,y       ;otherwise remove brick tiles with lines
0DB0A 99 05 02                             sta Sprite_Tilenumber+4,y     ;and replace then with lineless brick tiles
0DB0D BD E8 03                  ChkRep:    lda Block_Metatile,x          ;check replacement metatile
0DB10 C9 C5                                cmp #$c5                      ;if not used block metatile, then
0DB12 D0 24                                bne BlkOffscr                 ;branch ahead to use current graphics
0DB14 A9 87                                lda #$87                      ;set A for used block tile
0DB16 C8                                   iny                           ;increment Y to write to tile bytes
0DB17 20 73 D4                             jsr DumpFourSpr               ;do sub to dump into all four sprites
0DB1A 88                                   dey                           ;return Y to original offset
0DB1B A9 03                                lda #$03                      ;set palette bits
0DB1D AE 4E 07                             ldx AreaType
0DB20 CA                                   dex                           ;check for ground level type area again
0DB21 F0 01                                beq SetBFlip                  ;if found, use current palette bits
0DB23 4A                                   lsr                           ;otherwise set to $01
0DB24 A6 08                     SetBFlip:  ldx ObjectOffset              ;put block object offset back in X
0DB26 99 02 02                             sta Sprite_Attributes,y       ;store attribute byte as-is in first sprite
0DB29 09 40                                ora #%01000000
0DB2B 99 06 02                             sta Sprite_Attributes+4,y     ;set horizontal flip bit for second sprite
0DB2E 09 80                                ora #%10000000
0DB30 99 0E 02                             sta Sprite_Attributes+12,y    ;set both flip bits for fourth sprite
0DB33 29 83                                and #%10000011
0DB35 99 0A 02                             sta Sprite_Attributes+8,y     ;set vertical flip bit for third sprite
0DB38 AD D4 03                  BlkOffscr: lda Block_OffscreenBits       ;get offscreen bits for block object
0DB3B 48                                   pha                           ;save to stack
0DB3C 29 04                                and #%00000100                ;check to see if d2 in offscreen bits are set
0DB3E F0 08                                beq PullOfsB                  ;if not set, branch, otherwise move sprites offscreen
0DB40 A9 F8                                lda #$f8                      ;move offscreen two OAMs
0DB42 99 04 02                             sta Sprite_Y_Position+4,y     ;on the right side
0DB45 99 0C 02                             sta Sprite_Y_Position+12,y
0DB48 68                        PullOfsB:  pla                           ;pull offscreen bits from stack
0DB49 29 08                     ChkLeftCo: and #%00001000                ;check to see if d3 in offscreen bits are set
0DB4B F0 08                                beq ExDBlk                    ;if not set, branch, otherwise move sprites offscreen
0DB4D                           
0DB4D                           MoveColOffscreen:
0DB4D A9 F8                             lda #$f8                   ;move offscreen two OAMs
0DB4F 99 00 02                          sta Sprite_Y_Position,y    ;on the left side (or two rows of enemy on either side
0DB52 99 08 02                          sta Sprite_Y_Position+8,y  ;if branched here from enemy graphics handler)
0DB55 60                        ExDBlk: rts
0DB56                           
0DB56                           ;-------------------------------------------------------------------------------------
0DB56                           ;$00 - used to hold palette bits for attribute byte or relative X position
0DB56                           
0DB56                           DrawBrickChunks:
0DB56 A9 02                              lda #$02                   ;set palette bits here
0DB58 85 00                              sta $00
0DB5A A9 75                              lda #$75                   ;set tile number for ball (something residual, likely)
0DB5C A4 0E                              ldy GameEngineSubroutine
0DB5E C0 05                              cpy #$05                   ;if end-of-level routine running,
0DB60 F0 06                              beq DChunks                ;use palette and tile number assigned
0DB62 A9 03                              lda #$03                   ;otherwise set different palette bits
0DB64 85 00                              sta $00
0DB66 A9 84                              lda #$84                   ;and set tile number for brick chunks
0DB68 BC EC 06                  DChunks: ldy Block_SprDataOffset,x  ;get OAM data offset
0DB6B C8                                 iny                        ;increment to start with tile bytes in OAM
0DB6C 20 73 D4                           jsr DumpFourSpr            ;do sub to dump tile number into all four sprites
0DB6F A5 09                              lda FrameCounter           ;get frame counter
0DB71 0A                                 asl
0DB72 0A                                 asl
0DB73 0A                                 asl                        ;move low nybble to high
0DB74 0A                                 asl
0DB75 29 C0                              and #$c0                   ;get what was originally d3-d2 of low nybble
0DB77 05 00                              ora $00                    ;add palette bits
0DB79 C8                                 iny                        ;increment offset for attribute bytes
0DB7A 20 73 D4                           jsr DumpFourSpr            ;do sub to dump attribute data into all four sprites
0DB7D 88                                 dey
0DB7E 88                                 dey                        ;decrement offset to Y coordinate
0DB7F AD BC 03                           lda Block_Rel_YPos         ;get first block object's relative vertical coordinate
0DB82 20 79 D4                           jsr DumpTwoSpr             ;do sub to dump current Y coordinate into two sprites
0DB85 AD B1 03                           lda Block_Rel_XPos         ;get first block object's relative horizontal coordinate
0DB88 99 03 02                           sta Sprite_X_Position,y    ;save into X coordinate of first sprite
0DB8B BD F1 03                           lda Block_Orig_XPos,x      ;get original horizontal coordinate
0DB8E 38                                 sec
0DB8F ED 1C 07                           sbc ScreenLeft_X_Pos       ;subtract coordinate of left side from original coordinate
0DB92 85 00                              sta $00                    ;store result as relative horizontal coordinate of original
0DB94 38                                 sec
0DB95 ED B1 03                           sbc Block_Rel_XPos         ;get difference of relative positions of original - current
0DB98 65 00                              adc $00                    ;add original relative position to result
0DB9A 69 06                              adc #$06                   ;plus 6 pixels to position second brick chunk correctly
0DB9C 99 07 02                           sta Sprite_X_Position+4,y  ;save into X coordinate of second sprite
0DB9F AD BD 03                           lda Block_Rel_YPos+1       ;get second block object's relative vertical coordinate
0DBA2 99 08 02                           sta Sprite_Y_Position+8,y
0DBA5 99 0C 02                           sta Sprite_Y_Position+12,y ;dump into Y coordinates of third and fourth sprites
0DBA8 AD B2 03                           lda Block_Rel_XPos+1       ;get second block object's relative horizontal coordinate
0DBAB 99 0B 02                           sta Sprite_X_Position+8,y  ;save into X coordinate of third sprite
0DBAE A5 00                              lda $00                    ;use original relative horizontal position
0DBB0 38                                 sec
0DBB1 ED B2 03                           sbc Block_Rel_XPos+1       ;get difference of relative positions of original - current
0DBB4 65 00                              adc $00                    ;add original relative position to result
0DBB6 69 06                              adc #$06                   ;plus 6 pixels to position fourth brick chunk correctly
0DBB8 99 0F 02                           sta Sprite_X_Position+12,y ;save into X coordinate of fourth sprite
0DBBB AD D4 03                           lda Block_OffscreenBits    ;get offscreen bits for block object
0DBBE 20 49 DB                           jsr ChkLeftCo              ;do sub to move left half of sprites offscreen if necessary
0DBC1 AD D4 03                           lda Block_OffscreenBits    ;get offscreen bits again
0DBC4 0A                                 asl                        ;shift d7 into carry
0DBC5 90 05                              bcc ChnkOfs                ;if d7 not set, branch to last part
0DBC7 A9 F8                              lda #$f8
0DBC9 20 79 D4                           jsr DumpTwoSpr             ;otherwise move top sprites offscreen
0DBCC A5 00                     ChnkOfs: lda $00                    ;if relative position on left side of screen,
0DBCE 10 10                              bpl ExBCDr                 ;go ahead and leave
0DBD0 B9 03 02                           lda Sprite_X_Position,y    ;otherwise compare left-side X coordinate
0DBD3 D9 07 02                           cmp Sprite_X_Position+4,y  ;to right-side X coordinate
0DBD6 90 08                              bcc ExBCDr                 ;branch to leave if less
0DBD8 A9 F8                              lda #$f8                   ;otherwise move right half of sprites offscreen
0DBDA 99 04 02                           sta Sprite_Y_Position+4,y
0DBDD 99 0C 02                           sta Sprite_Y_Position+12,y
0DBE0 60                        ExBCDr:  rts                        ;leave
0DBE1                           
0DBE1                           ;-------------------------------------------------------------------------------------
0DBE1                           
0DBE1                           DrawFireball:
0DBE1 BC F1 06                        ldy FBall_SprDataOffset,x  ;get fireball's sprite data offset
0DBE4 AD BA 03                        lda Fireball_Rel_YPos      ;get relative vertical coordinate
0DBE7 99 00 02                        sta Sprite_Y_Position,y    ;store as sprite Y coordinate
0DBEA AD AF 03                        lda Fireball_Rel_XPos      ;get relative horizontal coordinate
0DBED 99 03 02                        sta Sprite_X_Position,y    ;store as sprite X coordinate, then do shared code
0DBF0                           
0DBF0                           DrawFirebar:
0DBF0 A5 09                            lda FrameCounter         ;get frame counter
0DBF2 4A                               lsr                      ;divide by four
0DBF3 4A                               lsr
0DBF4 48                               pha                      ;save result to stack
0DBF5 29 01                            and #$01                 ;mask out all but last bit
0DBF7 49 64                            eor #$64                 ;set either tile $64 or $65 as fireball tile
0DBF9 99 01 02                         sta Sprite_Tilenumber,y  ;thus tile changes every four frames
0DBFC 68                               pla                      ;get from stack
0DBFD 4A                               lsr                      ;divide by four again
0DBFE 4A                               lsr
0DBFF A9 02                            lda #$02                 ;load value $02 to set palette in attrib byte
0DC01 90 02                            bcc FireA                ;if last bit shifted out was not set, skip this
0DC03 09 C0                            ora #%11000000           ;otherwise flip both ways every eight frames
0DC05 99 02 02                  FireA: sta Sprite_Attributes,y  ;store attribute byte and leave
0DC08 60                               rts
0DC09                           
0DC09                           ;-------------------------------------------------------------------------------------
0DC09                           
0DC09                           ExplosionTiles:
0DC09 68 67 66                        .db $68, $67, $66
0DC0C                           
0DC0C                           DrawExplosion_Fireball:
0DC0C BC EC 06                        ldy Alt_SprDataOffset,x  ;get OAM data offset of alternate sort for fireball's explosion
0DC0F B5 24                           lda Fireball_State,x     ;load fireball state
0DC11 F6 24                           inc Fireball_State,x     ;increment state for next frame
0DC13 4A                              lsr                      ;divide by 2
0DC14 29 07                           and #%00000111           ;mask out all but d3-d1
0DC16 C9 03                           cmp #$03                 ;check to see if time to kill fireball
0DC18 B0 4A                           bcs KillFireBall         ;branch if so, otherwise continue to draw explosion
0DC1A                           
0DC1A                           DrawExplosion_Fireworks:
0DC1A AA                              tax                         ;use whatever's in A for offset
0DC1B BD 09 DC                        lda ExplosionTiles,x        ;get tile number using offset
0DC1E C8                              iny                         ;increment Y (contains sprite data offset)
0DC1F 20 73 D4                        jsr DumpFourSpr             ;and dump into tile number part of sprite data
0DC22 88                              dey                         ;decrement Y so we have the proper offset again
0DC23 A6 08                           ldx ObjectOffset            ;return enemy object buffer offset to X
0DC25 AD BA 03                        lda Fireball_Rel_YPos       ;get relative vertical coordinate
0DC28 38                              sec                         ;subtract four pixels vertically
0DC29 E9 04                           sbc #$04                    ;for first and third sprites
0DC2B 99 00 02                        sta Sprite_Y_Position,y
0DC2E 99 08 02                        sta Sprite_Y_Position+8,y
0DC31 18                              clc                         ;add eight pixels vertically
0DC32 69 08                           adc #$08                    ;for second and fourth sprites
0DC34 99 04 02                        sta Sprite_Y_Position+4,y
0DC37 99 0C 02                        sta Sprite_Y_Position+12,y
0DC3A AD AF 03                        lda Fireball_Rel_XPos       ;get relative horizontal coordinate
0DC3D 38                              sec                         ;subtract four pixels horizontally
0DC3E E9 04                           sbc #$04                    ;for first and second sprites
0DC40 99 03 02                        sta Sprite_X_Position,y
0DC43 99 07 02                        sta Sprite_X_Position+4,y
0DC46 18                              clc                         ;add eight pixels horizontally
0DC47 69 08                           adc #$08                    ;for third and fourth sprites
0DC49 99 0B 02                        sta Sprite_X_Position+8,y
0DC4C 99 0F 02                        sta Sprite_X_Position+12,y
0DC4F A9 02                           lda #$02                    ;set palette attributes for all sprites, but
0DC51 99 02 02                        sta Sprite_Attributes,y     ;set no flip at all for first sprite
0DC54 A9 82                           lda #$82
0DC56 99 06 02                        sta Sprite_Attributes+4,y   ;set vertical flip for second sprite
0DC59 A9 42                           lda #$42
0DC5B 99 0A 02                        sta Sprite_Attributes+8,y   ;set horizontal flip for third sprite
0DC5E A9 C2                           lda #$c2
0DC60 99 0E 02                        sta Sprite_Attributes+12,y  ;set both flips for fourth sprite
0DC63 60                              rts                         ;we are done
0DC64                           
0DC64                           KillFireBall:
0DC64 A9 00                           lda #$00                    ;clear fireball state to kill it
0DC66 95 24                           sta Fireball_State,x
0DC68 60                              rts
0DC69                           
0DC69                           ;-------------------------------------------------------------------------------------
0DC69                           
0DC69                           DrawSmallPlatform:
0DC69 BC E5 06                         ldy Enemy_SprDataOffset,x   ;get OAM data offset
0DC6C A9 5B                            lda #$5b                    ;load tile number for small platforms
0DC6E C8                               iny                         ;increment offset for tile numbers
0DC6F 20 6D D4                         jsr DumpSixSpr              ;dump tile number into all six sprites
0DC72 C8                               iny                         ;increment offset for attributes
0DC73 A9 02                            lda #$02                    ;load palette controls
0DC75 20 6D D4                         jsr DumpSixSpr              ;dump attributes into all six sprites
0DC78 88                               dey                         ;decrement for original offset
0DC79 88                               dey
0DC7A AD AE 03                         lda Enemy_Rel_XPos          ;get relative horizontal coordinate
0DC7D 99 03 02                         sta Sprite_X_Position,y
0DC80 99 0F 02                         sta Sprite_X_Position+12,y  ;dump as X coordinate into first and fourth sprites
0DC83 18                               clc
0DC84 69 08                            adc #$08                    ;add eight pixels
0DC86 99 07 02                         sta Sprite_X_Position+4,y   ;dump into second and fifth sprites
0DC89 99 13 02                         sta Sprite_X_Position+16,y
0DC8C 18                               clc
0DC8D 69 08                            adc #$08                    ;add eight more pixels
0DC8F 99 0B 02                         sta Sprite_X_Position+8,y   ;dump into third and sixth sprites
0DC92 99 17 02                         sta Sprite_X_Position+20,y
0DC95 B5 CF                            lda Enemy_Y_Position,x      ;get vertical coordinate
0DC97 AA                               tax
0DC98 48                               pha                         ;save to stack
0DC99 E0 20                            cpx #$20                    ;if vertical coordinate below status bar,
0DC9B B0 02                            bcs TopSP                   ;do not mess with it
0DC9D A9 F8                            lda #$f8                    ;otherwise move first three sprites offscreen
0DC9F 20 76 D4                  TopSP: jsr DumpThreeSpr            ;dump vertical coordinate into Y coordinates
0DCA2 68                               pla                         ;pull from stack
0DCA3 18                               clc
0DCA4 69 80                            adc #$80                    ;add 128 pixels
0DCA6 AA                               tax
0DCA7 E0 20                            cpx #$20                    ;if below status bar (taking wrap into account)
0DCA9 B0 02                            bcs BotSP                   ;then do not change altered coordinate
0DCAB A9 F8                            lda #$f8                    ;otherwise move last three sprites offscreen
0DCAD 99 0C 02                  BotSP: sta Sprite_Y_Position+12,y  ;dump vertical coordinate + 128 pixels
0DCB0 99 10 02                         sta Sprite_Y_Position+16,y  ;into Y coordinates
0DCB3 99 14 02                         sta Sprite_Y_Position+20,y
0DCB6 AD D1 03                         lda Enemy_OffscreenBits     ;get offscreen bits
0DCB9 48                               pha                         ;save to stack
0DCBA 29 08                            and #%00001000              ;check d3
0DCBC F0 08                            beq SOfs
0DCBE A9 F8                            lda #$f8                    ;if d3 was set, move first and
0DCC0 99 00 02                         sta Sprite_Y_Position,y     ;fourth sprites offscreen
0DCC3 99 0C 02                         sta Sprite_Y_Position+12,y
0DCC6 68                        SOfs:  pla                         ;move out and back into stack
0DCC7 48                               pha
0DCC8 29 04                            and #%00000100              ;check d2
0DCCA F0 08                            beq SOfs2
0DCCC A9 F8                            lda #$f8                    ;if d2 was set, move second and
0DCCE 99 04 02                         sta Sprite_Y_Position+4,y   ;fifth sprites offscreen
0DCD1 99 10 02                         sta Sprite_Y_Position+16,y
0DCD4 68                        SOfs2: pla                         ;get from stack
0DCD5 29 02                            and #%00000010              ;check d1
0DCD7 F0 08                            beq ExSPl
0DCD9 A9 F8                            lda #$f8                    ;if d1 was set, move third and
0DCDB 99 08 02                         sta Sprite_Y_Position+8,y   ;sixth sprites offscreen
0DCDE 99 14 02                         sta Sprite_Y_Position+20,y
0DCE1 A6 08                     ExSPl: ldx ObjectOffset            ;get enemy object offset and leave
0DCE3 60                               rts
0DCE4                           
0DCE4                           ;-------------------------------------------------------------------------------------
0DCE4                           
0DCE4                           DrawBubble:
0DCE4 A4 B5                             ldy Player_Y_HighPos        ;if player's vertical high position
0DCE6 88                                dey                         ;not within screen, skip all of this
0DCE7 D0 20                             bne ExDBub
0DCE9 AD D3 03                          lda Bubble_OffscreenBits    ;check air bubble's offscreen bits
0DCEC 29 08                             and #%00001000
0DCEE D0 19                             bne ExDBub                  ;if bit set, branch to leave
0DCF0 BC EE 06                          ldy Bubble_SprDataOffset,x  ;get air bubble's OAM data offset
0DCF3 AD B0 03                          lda Bubble_Rel_XPos         ;get relative horizontal coordinate
0DCF6 99 03 02                          sta Sprite_X_Position,y     ;store as X coordinate here
0DCF9 AD BB 03                          lda Bubble_Rel_YPos         ;get relative vertical coordinate
0DCFC 99 00 02                          sta Sprite_Y_Position,y     ;store as Y coordinate here
0DCFF A9 74                             lda #$74
0DD01 99 01 02                          sta Sprite_Tilenumber,y     ;put air bubble tile into OAM data
0DD04 A9 02                             lda #$02
0DD06 99 02 02                          sta Sprite_Attributes,y     ;set attribute byte
0DD09 60                        ExDBub: rts                         ;leave
0DD0A                           
0DD0A                           ;-------------------------------------------------------------------------------------
0DD0A                           ;$00 - used to store player's vertical offscreen bits
0DD0A                           
0DD0A                           PlayerGfxTblOffsets:
0DD0A 20 28 C8 18 00 40 50 58         .db $20, $28, $c8, $18, $00, $40, $50, $58
0DD12 80 88 B8 78 60 A0 B0 B8         .db $80, $88, $b8, $78, $60, $a0, $b0, $b8
0DD1A                           
0DD1A                           ;tiles arranged in order, 2 tiles per row, top to bottom
0DD1A                           
0DD1A                           PlayerGraphicsTable:
0DD1A                           ;big player table
0DD1A 00 01 02 03 04 05 06 07         .db $00, $01, $02, $03, $04, $05, $06, $07 ;walking frame 1
0DD22 08 09 0A 0B 0C 0D 0E 0F         .db $08, $09, $0a, $0b, $0c, $0d, $0e, $0f ;        frame 2
0DD2A 10 11 12 13 14 15 16 17         .db $10, $11, $12, $13, $14, $15, $16, $17 ;        frame 3
0DD32 18 19 1A 1B 1C 1D 1E 1F         .db $18, $19, $1a, $1b, $1c, $1d, $1e, $1f ;skidding
0DD3A 20 21 22 23 24 25 26 27         .db $20, $21, $22, $23, $24, $25, $26, $27 ;jumping
0DD42 08 09 28 29 2A 2B 2C 2D         .db $08, $09, $28, $29, $2a, $2b, $2c, $2d ;swimming frame 1
0DD4A 08 09 0A 0B 0C 30 2C 2D         .db $08, $09, $0a, $0b, $0c, $30, $2c, $2d ;         frame 2
0DD52 08 09 0A 0B 2E 2F 2C 2D         .db $08, $09, $0a, $0b, $2e, $2f, $2c, $2d ;         frame 3
0DD5A 08 09 28 29 2A 2B 5C 5D         .db $08, $09, $28, $29, $2a, $2b, $5c, $5d ;climbing frame 1
0DD62 08 09 0A 0B 0C 0D 5E 5F         .db $08, $09, $0a, $0b, $0c, $0d, $5e, $5f ;         frame 2
0DD6A FC FC 08 09 58 59 5A 5A         .db $fc, $fc, $08, $09, $58, $59, $5a, $5a ;crouching
0DD72 08 09 28 29 2A 2B 0E 0F         .db $08, $09, $28, $29, $2a, $2b, $0e, $0f ;fireball throwing
0DD7A                           
0DD7A                           ;small player table
0DD7A FC FC FC FC 32 33 34 35         .db $fc, $fc, $fc, $fc, $32, $33, $34, $35 ;walking frame 1
0DD82 FC FC FC FC 36 37 38 39         .db $fc, $fc, $fc, $fc, $36, $37, $38, $39 ;        frame 2
0DD8A FC FC FC FC 3A 37 3B 3C         .db $fc, $fc, $fc, $fc, $3a, $37, $3b, $3c ;        frame 3
0DD92 FC FC FC FC 3D 3E 3F 40         .db $fc, $fc, $fc, $fc, $3d, $3e, $3f, $40 ;skidding
0DD9A FC FC FC FC 32 41 42 43         .db $fc, $fc, $fc, $fc, $32, $41, $42, $43 ;jumping
0DDA2 FC FC FC FC 32 33 44 45         .db $fc, $fc, $fc, $fc, $32, $33, $44, $45 ;swimming frame 1
0DDAA FC FC FC FC 32 33 44 47         .db $fc, $fc, $fc, $fc, $32, $33, $44, $47 ;         frame 2
0DDB2 FC FC FC FC 32 33 48 49         .db $fc, $fc, $fc, $fc, $32, $33, $48, $49 ;         frame 3
0DDBA FC FC FC FC 32 33 90 91         .db $fc, $fc, $fc, $fc, $32, $33, $90, $91 ;climbing frame 1
0DDC2 FC FC FC FC 3A 37 92 93         .db $fc, $fc, $fc, $fc, $3a, $37, $92, $93 ;         frame 2
0DDCA FC FC FC FC 9E 9E 9F 9F         .db $fc, $fc, $fc, $fc, $9e, $9e, $9f, $9f ;killed
0DDD2                           
0DDD2                           ;used by both player sizes
0DDD2 FC FC FC FC 3A 37 4F 4F         .db $fc, $fc, $fc, $fc, $3a, $37, $4f, $4f ;small player standing
0DDDA FC FC 00 01 4C 4D 4E 4E         .db $fc, $fc, $00, $01, $4c, $4d, $4e, $4e ;intermediate grow frame
0DDE2 00 01 4C 4D 4A 4A 4B 4B         .db $00, $01, $4c, $4d, $4a, $4a, $4b, $4b ;big player standing
0DDEA                           
0DDEA                           SwimKickTileNum:
0DDEA 31 46                           .db $31, $46
0DDEC                           
0DDEC                           PlayerGfxHandler:
0DDEC AD 9E 07                          lda InjuryTimer             ;if player's injured invincibility timer
0DDEF F0 05                             beq CntPl                   ;not set, skip checkpoint and continue code
0DDF1 A5 09                             lda FrameCounter
0DDF3 4A                                lsr                         ;otherwise check frame counter and branch
0DDF4 B0 40                             bcs ExPGH                   ;to leave on every other frame (when d0 is set)
0DDF6 A5 0E                     CntPl:  lda GameEngineSubroutine    ;if executing specific game engine routine,
0DDF8 C9 0B                             cmp #$0b                    ;branch ahead to some other part
0DDFA F0 47                             beq PlayerKilled
0DDFC AD 0B 07                          lda PlayerChangeSizeFlag    ;if grow/shrink flag set
0DDFF D0 3C                             bne DoChangeSize            ;then branch to some other code
0DE01 AC 04 07                          ldy SwimmingFlag            ;if swimming flag set, branch to
0DE04 F0 31                             beq FindPlayerAction        ;different part, do not return
0DE06 A5 1D                             lda Player_State
0DE08 C9 00                             cmp #$00                    ;if player status normal,
0DE0A F0 2B                             beq FindPlayerAction        ;branch and do not return
0DE0C 20 37 DE                          jsr FindPlayerAction        ;otherwise jump and return
0DE0F A5 09                             lda FrameCounter
0DE11 29 04                             and #%00000100              ;check frame counter for d2 set (8 frames every
0DE13 D0 21                             bne ExPGH                   ;eighth frame), and branch if set to leave
0DE15 AA                                tax                         ;initialize X to zero
0DE16 AC E4 06                          ldy Player_SprDataOffset    ;get player sprite data offset
0DE19 A5 33                             lda PlayerFacingDir         ;get player's facing direction
0DE1B 4A                                lsr
0DE1C B0 04                             bcs SwimKT                  ;if player facing to the right, use current offset
0DE1E C8                                iny
0DE1F C8                                iny                         ;otherwise move to next OAM data
0DE20 C8                                iny
0DE21 C8                                iny
0DE22 AD 54 07                  SwimKT: lda PlayerSize              ;check player's size
0DE25 F0 09                             beq BigKTS                  ;if big, use first tile
0DE27 B9 19 02                          lda Sprite_Tilenumber+24,y  ;check tile number of seventh/eighth sprite
0DE2A CD B8 DD                          cmp SwimTileRepOffset       ;against tile number in player graphics table
0DE2D F0 07                             beq ExPGH                   ;if spr7/spr8 tile number = value, branch to leave
0DE2F E8                                inx                         ;otherwise increment X for second tile
0DE30 BD EA DD                  BigKTS: lda SwimKickTileNum,x       ;overwrite tile number in sprite 7/8
0DE33 99 19 02                          sta Sprite_Tilenumber+24,y  ;to animate player's feet when swimming
0DE36 60                        ExPGH:  rts                         ;then leave
0DE37                           
0DE37                           FindPlayerAction:
0DE37 20 EF DE                        jsr ProcessPlayerAction       ;find proper offset to graphics table by player's actions
0DE3A 4C 48 DE                        jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
0DE3D                           
0DE3D                           DoChangeSize:
0DE3D 20 BD DF                        jsr HandleChangeSize          ;find proper offset to graphics table for grow/shrink
0DE40 4C 48 DE                        jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
0DE43                           
0DE43                           PlayerKilled:
0DE43 A0 0E                           ldy #$0e                      ;load offset for player killed
0DE45 B9 0A DD                        lda PlayerGfxTblOffsets,y     ;get offset to graphics table
0DE48                           
0DE48                           PlayerGfxProcessing:
0DE48 8D D5 06                         sta PlayerGfxOffset           ;store offset to graphics table here
0DE4B A9 04                            lda #$04
0DE4D 20 C1 DE                         jsr RenderPlayerSub           ;draw player based on offset loaded
0DE50 20 F6 DF                         jsr ChkForPlayerAttrib        ;set horizontal flip bits as necessary
0DE53 AD 11 07                         lda FireballThrowingTimer
0DE56 F0 25                            beq PlayerOffscreenChk        ;if fireball throw timer not set, skip to the end
0DE58 A0 00                            ldy #$00                      ;set value to initialize by default
0DE5A AD 81 07                         lda PlayerAnimTimer           ;get animation frame timer
0DE5D CD 11 07                         cmp FireballThrowingTimer     ;compare to fireball throw timer
0DE60 8C 11 07                         sty FireballThrowingTimer     ;initialize fireball throw timer
0DE63 B0 18                            bcs PlayerOffscreenChk        ;if animation frame timer => fireball throw timer skip to end
0DE65 8D 11 07                         sta FireballThrowingTimer     ;otherwise store animation timer into fireball throw timer
0DE68 A0 07                            ldy #$07                      ;load offset for throwing
0DE6A B9 0A DD                         lda PlayerGfxTblOffsets,y     ;get offset to graphics table
0DE6D 8D D5 06                         sta PlayerGfxOffset           ;store it for use later
0DE70 A0 04                            ldy #$04                      ;set to update four sprite rows by default
0DE72 A5 57                            lda Player_X_Speed
0DE74 05 0C                            ora Left_Right_Buttons        ;check for horizontal speed or left/right button press
0DE76 F0 01                            beq SUpdR                     ;if no speed or button press, branch using set value in Y
0DE78 88                               dey                           ;otherwise set to update only three sprite rows
0DE79 98                        SUpdR: tya                           ;save in A for use
0DE7A 20 C1 DE                         jsr RenderPlayerSub           ;in sub, draw player object again
0DE7D                           
0DE7D                           PlayerOffscreenChk:
0DE7D AD D0 03                             lda Player_OffscreenBits      ;get player's offscreen bits
0DE80 4A                                   lsr
0DE81 4A                                   lsr                           ;move vertical bits to low nybble
0DE82 4A                                   lsr
0DE83 4A                                   lsr
0DE84 85 00                                sta $00                       ;store here
0DE86 A2 03                                ldx #$03                      ;check all four rows of player sprites
0DE88 AD E4 06                             lda Player_SprDataOffset      ;get player's sprite data offset
0DE8B 18                                   clc
0DE8C 69 18                                adc #$18                      ;add 24 bytes to start at bottom row
0DE8E A8                                   tay                           ;set as offset here
0DE8F A9 F8                     PROfsLoop: lda #$f8                      ;load offscreen Y coordinate just in case
0DE91 46 00                                lsr $00                       ;shift bit into carry
0DE93 90 03                                bcc NPROffscr                 ;if bit not set, skip, do not move sprites
0DE95 20 79 D4                             jsr DumpTwoSpr                ;otherwise dump offscreen Y coordinate into sprite data
0DE98 98                        NPROffscr: tya
0DE99 38                                   sec                           ;subtract eight bytes to do
0DE9A E9 08                                sbc #$08                      ;next row up
0DE9C A8                                   tay
0DE9D CA                                   dex                           ;decrement row counter
0DE9E 10 EF                                bpl PROfsLoop                 ;do this until all sprite rows are checked
0DEA0 60                                   rts                           ;then we are done!
0DEA1                           
0DEA1                           IntermediatePlayerData:
0DEA1 58 01 00 60 FF 04                 .db $58, $01, $00, $60, $ff, $04
0DEA7                           
0DEA7                           DrawPlayer_Intermediate:
0DEA7 A2 05                               ldx #$05                       ;store data into zero page memory
0DEA9 BD A1 DE                  PIntLoop: lda IntermediatePlayerData,x   ;load data to display player as he always
0DEAC 95 02                               sta $02,x                      ;appears on world/lives display
0DEAE CA                                  dex
0DEAF 10 F8                               bpl PIntLoop                   ;do this until all data is loaded
0DEB1 A2 B8                               ldx #$b8                       ;load offset for small standing
0DEB3 A0 04                               ldy #$04                       ;load sprite data offset
0DEB5 20 DF DE                            jsr DrawPlayerLoop             ;draw player accordingly
0DEB8 AD 26 02                            lda Sprite_Attributes+36       ;get empty sprite attributes
0DEBB 09 40                               ora #%01000000                 ;set horizontal flip bit for bottom-right sprite
0DEBD 8D 22 02                            sta Sprite_Attributes+32       ;store and leave
0DEC0 60                                  rts
0DEC1                           
0DEC1                           ;-------------------------------------------------------------------------------------
0DEC1                           ;$00-$01 - used to hold tile numbers, $00 also used to hold upper extent of animation frames
0DEC1                           ;$02 - vertical position
0DEC1                           ;$03 - facing direction, used as horizontal flip control
0DEC1                           ;$04 - attributes
0DEC1                           ;$05 - horizontal position
0DEC1                           ;$07 - number of rows to draw
0DEC1                           ;these also used in IntermediatePlayerData
0DEC1                           
0DEC1                           RenderPlayerSub:
0DEC1 85 07                             sta $07                      ;store number of rows of sprites to draw
0DEC3 AD AD 03                          lda Player_Rel_XPos
0DEC6 8D 55 07                          sta Player_Pos_ForScroll     ;store player's relative horizontal position
0DEC9 85 05                             sta $05                      ;store it here also
0DECB AD B8 03                          lda Player_Rel_YPos
0DECE 85 02                             sta $02                      ;store player's vertical position
0DED0 A5 33                             lda PlayerFacingDir
0DED2 85 03                             sta $03                      ;store player's facing direction
0DED4 AD C4 03                          lda Player_SprAttrib
0DED7 85 04                             sta $04                      ;store player's sprite attributes
0DED9 AE D5 06                          ldx PlayerGfxOffset          ;load graphics table offset
0DEDC AC E4 06                          ldy Player_SprDataOffset     ;get player's sprite data offset
0DEDF                           
0DEDF                           DrawPlayerLoop:
0DEDF BD 1A DD                          lda PlayerGraphicsTable,x    ;load player's left side
0DEE2 85 00                             sta $00
0DEE4 BD 1B DD                          lda PlayerGraphicsTable+1,x  ;now load right side
0DEE7 20 B5 DA                          jsr DrawOneSpriteRow
0DEEA C6 07                             dec $07                      ;decrement rows of sprites to draw
0DEEC D0 F1                             bne DrawPlayerLoop           ;do this until all rows are drawn
0DEEE 60                                rts
0DEEF                           
0DEEF                           ProcessPlayerAction:
0DEEF A5 1D                             lda Player_State      ;get player's state
0DEF1 C9 03                             cmp #$03
0DEF3 F0 5C                             beq ActionClimbing    ;if climbing, branch here
0DEF5 C9 02                             cmp #$02
0DEF7 F0 48                             beq ActionFalling     ;if falling, branch here
0DEF9 C9 01                             cmp #$01
0DEFB D0 11                             bne ProcOnGroundActs  ;if not jumping, branch here
0DEFD AD 04 07                          lda SwimmingFlag
0DF00 D0 5B                             bne ActionSwimming    ;if swimming flag set, branch elsewhere
0DF02 A0 06                             ldy #$06              ;load offset for crouching
0DF04 AD 14 07                          lda CrouchingFlag     ;get crouching flag
0DF07 D0 2C                             bne NonAnimatedActs   ;if set, branch to get offset for graphics table
0DF09 A0 00                             ldy #$00              ;otherwise load offset for jumping
0DF0B 4C 35 DF                          jmp NonAnimatedActs   ;go to get offset to graphics table
0DF0E                           
0DF0E                           ProcOnGroundActs:
0DF0E A0 06                              ldy #$06                   ;load offset for crouching
0DF10 AD 14 07                           lda CrouchingFlag          ;get crouching flag
0DF13 D0 20                              bne NonAnimatedActs        ;if set, branch to get offset for graphics table
0DF15 A0 02                              ldy #$02                   ;load offset for standing
0DF17 A5 57                              lda Player_X_Speed         ;check player's horizontal speed
0DF19 05 0C                              ora Left_Right_Buttons     ;and left/right controller bits
0DF1B F0 18                              beq NonAnimatedActs        ;if no speed or buttons pressed, use standing offset
0DF1D AD 00 07                           lda Player_XSpeedAbsolute  ;load walking/running speed
0DF20 C9 09                              cmp #$09
0DF22 90 25                              bcc ActionWalkRun          ;if less than a certain amount, branch, too slow to skid
0DF24 A5 45                              lda Player_MovingDir       ;otherwise check to see if moving direction
0DF26 25 33                              and PlayerFacingDir        ;and facing direction are the same
0DF28 D0 1F                              bne ActionWalkRun          ;if moving direction = facing direction, branch, don't skid
0DF2A A5 0E                              lda GameEngineSubroutine
0DF2C C9 09                              cmp #$09                   ;if running the change size, fire flower, injure
0DF2E B0 04                              bcs NoSkidS                ;or death game engine subroutines, skip this
0DF30 A9 80                              lda #$80                   ;otherwise play skid sound
0DF32 85 FD                              sta NoiseSoundQueue
0DF34 C8                        NoSkidS: iny                        ;increment to skid offset ($03)
0DF35                           
0DF35                           NonAnimatedActs:
0DF35 20 9E DF                          jsr GetGfxOffsetAdder      ;do a sub here to get offset adder for graphics table
0DF38 A9 00                             lda #$00
0DF3A 8D 0D 07                          sta PlayerAnimCtrl         ;initialize animation frame control
0DF3D B9 0A DD                          lda PlayerGfxTblOffsets,y  ;load offset to graphics table using size as offset
0DF40 60                                rts
0DF41                           
0DF41                           ActionFalling:
0DF41 A0 04                             ldy #$04                  ;load offset for walking/running
0DF43 20 9E DF                          jsr GetGfxOffsetAdder     ;get offset to graphics table
0DF46 4C 6F DF                          jmp GetCurrentAnimOffset  ;execute instructions for falling state
0DF49                           
0DF49                           ActionWalkRun:
0DF49 A0 04                             ldy #$04               ;load offset for walking/running
0DF4B 20 9E DF                          jsr GetGfxOffsetAdder  ;get offset to graphics table
0DF4E 4C 75 DF                          jmp FourFrameExtent    ;execute instructions for normal state
0DF51                           
0DF51                           ActionClimbing:
0DF51 A0 05                             ldy #$05               ;load offset for climbing
0DF53 A5 9F                             lda Player_Y_Speed     ;check player's vertical speed
0DF55 F0 DE                             beq NonAnimatedActs    ;if no speed, branch, use offset as-is
0DF57 20 9E DF                          jsr GetGfxOffsetAdder  ;otherwise get offset for graphics table
0DF5A 4C 7A DF                          jmp ThreeFrameExtent   ;then skip ahead to more code
0DF5D                           
0DF5D                           ActionSwimming:
0DF5D A0 01                             ldy #$01               ;load offset for swimming
0DF5F 20 9E DF                          jsr GetGfxOffsetAdder
0DF62 AD 82 07                          lda JumpSwimTimer      ;check jump/swim timer
0DF65 0D 0D 07                          ora PlayerAnimCtrl     ;and animation frame control
0DF68 D0 0B                             bne FourFrameExtent    ;if any one of these set, branch ahead
0DF6A A5 0A                             lda A_B_Buttons
0DF6C 0A                                asl                    ;check for A button pressed
0DF6D B0 06                             bcs FourFrameExtent    ;branch to same place if A button pressed
0DF6F                           
0DF6F                           GetCurrentAnimOffset:
0DF6F AD 0D 07                          lda PlayerAnimCtrl         ;get animation frame control
0DF72 4C DD DF                          jmp GetOffsetFromAnimCtrl  ;jump to get proper offset to graphics table
0DF75                           
0DF75                           FourFrameExtent:
0DF75 A9 03                             lda #$03              ;load upper extent for frame control
0DF77 4C 7C DF                          jmp AnimationControl  ;jump to get offset and animate player object
0DF7A                           
0DF7A                           ThreeFrameExtent:
0DF7A A9 02                             lda #$02              ;load upper extent for frame control for climbing
0DF7C                           
0DF7C                           AnimationControl:
0DF7C 85 00                               sta $00                   ;store upper extent here
0DF7E 20 6F DF                            jsr GetCurrentAnimOffset  ;get proper offset to graphics table
0DF81 48                                  pha                       ;save offset to stack
0DF82 AD 81 07                            lda PlayerAnimTimer       ;load animation frame timer
0DF85 D0 15                               bne ExAnimC               ;branch if not expired
0DF87 AD 0C 07                            lda PlayerAnimTimerSet    ;get animation frame timer amount
0DF8A 8D 81 07                            sta PlayerAnimTimer       ;and set timer accordingly
0DF8D AD 0D 07                            lda PlayerAnimCtrl
0DF90 18                                  clc                       ;add one to animation frame control
0DF91 69 01                               adc #$01
0DF93 C5 00                               cmp $00                   ;compare to upper extent
0DF95 90 02                               bcc SetAnimC              ;if frame control + 1 < upper extent, use as next
0DF97 A9 00                               lda #$00                  ;otherwise initialize frame control
0DF99 8D 0D 07                  SetAnimC: sta PlayerAnimCtrl        ;store as new animation frame control
0DF9C 68                        ExAnimC:  pla                       ;get offset to graphics table from stack and leave
0DF9D 60                                  rts
0DF9E                           
0DF9E                           GetGfxOffsetAdder:
0DF9E AD 54 07                          lda PlayerSize  ;get player's size
0DFA1 F0 05                             beq SzOfs       ;if player big, use current offset as-is
0DFA3 98                                tya             ;for big player
0DFA4 18                                clc             ;otherwise add eight bytes to offset
0DFA5 69 08                             adc #$08        ;for small player
0DFA7 A8                                tay
0DFA8 60                        SzOfs:  rts             ;go back
0DFA9                           
0DFA9                           ChangeSizeOffsetAdder:
0DFA9 00 01 00 01 00 01 02 00..         .db $00, $01, $00, $01, $00, $01, $02, $00, $01, $02
0DFB3 02 00 02 00 02 00 02 00..         .db $02, $00, $02, $00, $02, $00, $02, $00, $02, $00
0DFBD                           
0DFBD                           HandleChangeSize:
0DFBD AC 0D 07                           ldy PlayerAnimCtrl           ;get animation frame control
0DFC0 A5 09                              lda FrameCounter
0DFC2 29 03                              and #%00000011               ;get frame counter and execute this code every
0DFC4 D0 0D                              bne GorSLog                  ;fourth frame, otherwise branch ahead
0DFC6 C8                                 iny                          ;increment frame control
0DFC7 C0 0A                              cpy #$0a                     ;check for preset upper extent
0DFC9 90 05                              bcc CSzNext                  ;if not there yet, skip ahead to use
0DFCB A0 00                              ldy #$00                     ;otherwise initialize both grow/shrink flag
0DFCD 8C 0B 07                           sty PlayerChangeSizeFlag     ;and animation frame control
0DFD0 8C 0D 07                  CSzNext: sty PlayerAnimCtrl           ;store proper frame control
0DFD3 AD 54 07                  GorSLog: lda PlayerSize               ;get player's size
0DFD6 D0 0C                              bne ShrinkPlayer             ;if player small, skip ahead to next part
0DFD8 B9 A9 DF                           lda ChangeSizeOffsetAdder,y  ;get offset adder based on frame control as offset
0DFDB A0 0F                              ldy #$0f                     ;load offset for player growing
0DFDD                           
0DFDD                           GetOffsetFromAnimCtrl:
0DFDD 0A                                asl                        ;multiply animation frame control
0DFDE 0A                                asl                        ;by eight to get proper amount
0DFDF 0A                                asl                        ;to add to our offset
0DFE0 79 0A DD                          adc PlayerGfxTblOffsets,y  ;add to offset to graphics table
0DFE3 60                                rts                        ;and return with result in A
0DFE4                           
0DFE4                           ShrinkPlayer:
0DFE4 98                                tya                          ;add ten bytes to frame control as offset
0DFE5 18                                clc
0DFE6 69 0A                             adc #$0a                     ;this thing apparently uses two of the swimming frames
0DFE8 AA                                tax                          ;to draw the player shrinking
0DFE9 A0 09                             ldy #$09                     ;load offset for small player swimming
0DFEB BD A9 DF                          lda ChangeSizeOffsetAdder,x  ;get what would normally be offset adder
0DFEE D0 02                             bne ShrPlF                   ;and branch to use offset if nonzero
0DFF0 A0 01                             ldy #$01                     ;otherwise load offset for big player swimming
0DFF2 B9 0A DD                  ShrPlF: lda PlayerGfxTblOffsets,y    ;get offset to graphics table based on offset loaded
0DFF5 60                                rts                          ;and leave
0DFF6                           
0DFF6                           ChkForPlayerAttrib:
0DFF6 AC E4 06                             ldy Player_SprDataOffset    ;get sprite data offset
0DFF9 A5 0E                                lda GameEngineSubroutine
0DFFB C9 0B                                cmp #$0b                    ;if executing specific game engine routine,
0DFFD F0 13                                beq KilledAtt               ;branch to change third and fourth row OAM attributes
0DFFF AD D5 06                             lda PlayerGfxOffset         ;get graphics table offset
0E002 C9 50                                cmp #$50
0E004 F0 1E                                beq C_S_IGAtt               ;if crouch offset, either standing offset,
0E006 C9 B8                                cmp #$b8                    ;or intermediate growing offset,
0E008 F0 1A                                beq C_S_IGAtt               ;go ahead and execute code to change 
0E00A C9 C0                                cmp #$c0                    ;fourth row OAM attributes only
0E00C F0 16                                beq C_S_IGAtt
0E00E C9 C8                                cmp #$c8
0E010 D0 24                                bne ExPlyrAt                ;if none of these, branch to leave
0E012 B9 12 02                  KilledAtt: lda Sprite_Attributes+16,y
0E015 29 3F                                and #%00111111              ;mask out horizontal and vertical flip bits
0E017 99 12 02                             sta Sprite_Attributes+16,y  ;for third row sprites and save
0E01A B9 16 02                             lda Sprite_Attributes+20,y
0E01D 29 3F                                and #%00111111  
0E01F 09 40                                ora #%01000000              ;set horizontal flip bit for second
0E021 99 16 02                             sta Sprite_Attributes+20,y  ;sprite in the third row
0E024 B9 1A 02                  C_S_IGAtt: lda Sprite_Attributes+24,y
0E027 29 3F                                and #%00111111              ;mask out horizontal and vertical flip bits
0E029 99 1A 02                             sta Sprite_Attributes+24,y  ;for fourth row sprites and save
0E02C B9 1E 02                             lda Sprite_Attributes+28,y
0E02F 29 3F                                and #%00111111
0E031 09 40                                ora #%01000000              ;set horizontal flip bit for second
0E033 99 1E 02                             sta Sprite_Attributes+28,y  ;sprite in the fourth row
0E036 60                        ExPlyrAt:  rts                         ;leave
0E037                           
0E037                           ;-------------------------------------------------------------------------------------
0E037                           ;$00 - used in adding to get proper offset
0E037                           
0E037                           RelativePlayerPosition:
0E037 A2 00                             ldx #$00      ;set offsets for relative cooordinates
0E039 A0 00                             ldy #$00      ;routine to correspond to player object
0E03B 4C 4F E0                          jmp RelWOfs   ;get the coordinates
0E03E                           
0E03E                           RelativeBubblePosition:
0E03E A0 01                             ldy #$01                ;set for air bubble offsets
0E040 20 B5 E0                          jsr GetProperObjOffset  ;modify X to get proper air bubble offset
0E043 A0 03                             ldy #$03
0E045 4C 4F E0                          jmp RelWOfs             ;get the coordinates
0E048                           
0E048                           RelativeFireballPosition:
0E048 A0 00                              ldy #$00                    ;set for fireball offsets
0E04A 20 B5 E0                           jsr GetProperObjOffset      ;modify X to get proper fireball offset
0E04D A0 02                              ldy #$02
0E04F 20 7E E0                  RelWOfs: jsr GetObjRelativePosition  ;get the coordinates
0E052 A6 08                              ldx ObjectOffset            ;return original offset
0E054 60                                 rts                         ;leave
0E055                           
0E055                           RelativeMiscPosition:
0E055 A0 02                             ldy #$02                ;set for misc object offsets
0E057 20 B5 E0                          jsr GetProperObjOffset  ;modify X to get proper misc object offset
0E05A A0 06                             ldy #$06
0E05C 4C 4F E0                          jmp RelWOfs             ;get the coordinates
0E05F                           
0E05F                           RelativeEnemyPosition:
0E05F A9 01                             lda #$01                     ;get coordinates of enemy object 
0E061 A0 01                             ldy #$01                     ;relative to the screen
0E063 4C 72 E0                          jmp VariableObjOfsRelPos
0E066                           
0E066                           RelativeBlockPosition:
0E066 A9 09                             lda #$09                     ;get coordinates of one block object
0E068 A0 04                             ldy #$04                     ;relative to the screen
0E06A 20 72 E0                          jsr VariableObjOfsRelPos
0E06D E8                                inx                          ;adjust offset for other block object if any
0E06E E8                                inx
0E06F A9 09                             lda #$09
0E071 C8                                iny                          ;adjust other and get coordinates for other one
0E072                           
0E072                           VariableObjOfsRelPos:
0E072 86 00                             stx $00                     ;store value to add to A here
0E074 18                                clc
0E075 65 00                             adc $00                     ;add A to value stored
0E077 AA                                tax                         ;use as enemy offset
0E078 20 7E E0                          jsr GetObjRelativePosition
0E07B A6 08                             ldx ObjectOffset            ;reload old object offset and leave
0E07D 60                                rts
0E07E                           
0E07E                           GetObjRelativePosition:
0E07E B5 CE                             lda SprObject_Y_Position,x  ;load vertical coordinate low
0E080 99 B8 03                          sta SprObject_Rel_YPos,y    ;store here
0E083 B5 86                             lda SprObject_X_Position,x  ;load horizontal coordinate
0E085 38                                sec                         ;subtract left edge coordinate
0E086 ED 1C 07                          sbc ScreenLeft_X_Pos
0E089 99 AD 03                          sta SprObject_Rel_XPos,y    ;store result here
0E08C 60                                rts
0E08D                           
0E08D                           ;-------------------------------------------------------------------------------------
0E08D                           ;$00 - used as temp variable to hold offscreen bits
0E08D                           
0E08D                           GetPlayerOffscreenBits:
0E08D A2 00                             ldx #$00                 ;set offsets for player-specific variables
0E08F A0 00                             ldy #$00                 ;and get offscreen information about player
0E091 4C CD E0                          jmp GetOffScreenBitsSet
0E094                           
0E094                           GetFireballOffscreenBits:
0E094 A0 00                             ldy #$00                 ;set for fireball offsets
0E096 20 B5 E0                          jsr GetProperObjOffset   ;modify X to get proper fireball offset
0E099 A0 02                             ldy #$02                 ;set other offset for fireball's offscreen bits
0E09B 4C CD E0                          jmp GetOffScreenBitsSet  ;and get offscreen information about fireball
0E09E                           
0E09E                           GetBubbleOffscreenBits:
0E09E A0 01                             ldy #$01                 ;set for air bubble offsets
0E0A0 20 B5 E0                          jsr GetProperObjOffset   ;modify X to get proper air bubble offset
0E0A3 A0 03                             ldy #$03                 ;set other offset for airbubble's offscreen bits
0E0A5 4C CD E0                          jmp GetOffScreenBitsSet  ;and get offscreen information about air bubble
0E0A8                           
0E0A8                           GetMiscOffscreenBits:
0E0A8 A0 02                             ldy #$02                 ;set for misc object offsets
0E0AA 20 B5 E0                          jsr GetProperObjOffset   ;modify X to get proper misc object offset
0E0AD A0 06                             ldy #$06                 ;set other offset for misc object's offscreen bits
0E0AF 4C CD E0                          jmp GetOffScreenBitsSet  ;and get offscreen information about misc object
0E0B2                           
0E0B2                           ObjOffsetData:
0E0B2 07 16 0D                          .db $07, $16, $0d
0E0B5                           
0E0B5                           GetProperObjOffset:
0E0B5 8A                                txa                  ;move offset to A
0E0B6 18                                clc
0E0B7 79 B2 E0                          adc ObjOffsetData,y  ;add amount of bytes to offset depending on setting in Y
0E0BA AA                                tax                  ;put back in X and leave
0E0BB 60                                rts
0E0BC                           
0E0BC                           GetEnemyOffscreenBits:
0E0BC A9 01                             lda #$01                 ;set A to add 1 byte in order to get enemy offset
0E0BE A0 01                             ldy #$01                 ;set Y to put offscreen bits in Enemy_OffscreenBits
0E0C0 4C C7 E0                          jmp SetOffscrBitsOffset
0E0C3                           
0E0C3                           GetBlockOffscreenBits:
0E0C3 A9 09                             lda #$09       ;set A to add 9 bytes in order to get block obj offset
0E0C5 A0 04                             ldy #$04       ;set Y to put offscreen bits in Block_OffscreenBits
0E0C7                           
0E0C7                           SetOffscrBitsOffset:
0E0C7 86 00                             stx $00
0E0C9 18                                clc           ;add contents of X to A to get
0E0CA 65 00                             adc $00       ;appropriate offset, then give back to X
0E0CC AA                                tax
0E0CD                           
0E0CD                           GetOffScreenBitsSet:
0E0CD 98                                tya                         ;save offscreen bits offset to stack for now
0E0CE 48                                pha
0E0CF 20 E4 E0                          jsr RunOffscrBitsSubs
0E0D2 0A                                asl                         ;move low nybble to high nybble
0E0D3 0A                                asl
0E0D4 0A                                asl
0E0D5 0A                                asl
0E0D6 05 00                             ora $00                     ;mask together with previously saved low nybble
0E0D8 85 00                             sta $00                     ;store both here
0E0DA 68                                pla                         ;get offscreen bits offset from stack
0E0DB A8                                tay
0E0DC A5 00                             lda $00                     ;get value here and store elsewhere
0E0DE 99 D0 03                          sta SprObject_OffscrBits,y
0E0E1 A6 08                             ldx ObjectOffset
0E0E3 60                                rts
0E0E4                           
0E0E4                           RunOffscrBitsSubs:
0E0E4 20 03 E1                          jsr GetXOffscreenBits  ;do subroutine here
0E0E7 4A                                lsr                    ;move high nybble to low
0E0E8 4A                                lsr
0E0E9 4A                                lsr
0E0EA 4A                                lsr
0E0EB 85 00                             sta $00                ;store here
0E0ED 4C 46 E1                          jmp GetYOffscreenBits
0E0F0                           
0E0F0                           ;--------------------------------
0E0F0                           ;(these apply to these three subsections)
0E0F0                           ;$04 - used to store proper offset
0E0F0                           ;$05 - used as adder in DividePDiff
0E0F0                           ;$06 - used to store preset value used to compare to pixel difference in $07
0E0F0                           ;$07 - used to store difference between coordinates of object and screen edges
0E0F0                           
0E0F0                           XOffscreenBitsData:
0E0F0 7F 3F 1F 0F 07 03 01 00           .db $7f, $3f, $1f, $0f, $07, $03, $01, $00
0E0F8 80 C0 E0 F0 F8 FC FE FF           .db $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
0E100                           
0E100                           DefaultXOnscreenOfs:
0E100 07 0F 07                          .db $07, $0f, $07
0E103                           
0E103                           GetXOffscreenBits:
0E103 86 04                               stx $04                     ;save position in buffer to here
0E105 A0 01                               ldy #$01                    ;start with right side of screen
0E107 B9 1C 07                  XOfsLoop: lda ScreenEdge_X_Pos,y      ;get pixel coordinate of edge
0E10A 38                                  sec                         ;get difference between pixel coordinate of edge
0E10B F5 86                               sbc SprObject_X_Position,x  ;and pixel coordinate of object position
0E10D 85 07                               sta $07                     ;store here
0E10F B9 1A 07                            lda ScreenEdge_PageLoc,y    ;get page location of edge
0E112 F5 6D                               sbc SprObject_PageLoc,x     ;subtract from page location of object position
0E114 BE 00 E1                            ldx DefaultXOnscreenOfs,y   ;load offset value here
0E117 C9 00                               cmp #$00      
0E119 30 10                               bmi XLdBData                ;if beyond right edge or in front of left edge, branch
0E11B BE 01 E1                            ldx DefaultXOnscreenOfs+1,y ;if not, load alternate offset value here
0E11E C9 01                               cmp #$01      
0E120 10 09                               bpl XLdBData                ;if one page or more to the left of either edge, branch
0E122 A9 38                               lda #$38                    ;if no branching, load value here and store
0E124 85 06                               sta $06
0E126 A9 08                               lda #$08                    ;load some other value and execute subroutine
0E128 20 7A E1                            jsr DividePDiff
0E12B BD F0 E0                  XLdBData: lda XOffscreenBitsData,x    ;get bits here
0E12E A6 04                               ldx $04                     ;reobtain position in buffer
0E130 C9 00                               cmp #$00                    ;if bits not zero, branch to leave
0E132 D0 03                               bne ExXOfsBS
0E134 88                                  dey                         ;otherwise, do left side of screen now
0E135 10 D0                               bpl XOfsLoop                ;branch if not already done with left side
0E137 60                        ExXOfsBS: rts
0E138                           
0E138                           ;--------------------------------
0E138                           
0E138                           YOffscreenBitsData:
0E138 0F 07 03 01                       .db $0f, $07, $03, $01
0E13C 00 08 0C 0E                       .db $00, $08, $0c, $0e
0E140 00                                .db $00
0E141                           
0E141                           DefaultYOnscreenOfs:
0E141 04 00 04                          .db $04, $00, $04
0E144                           
0E144                           HighPosUnitData:
0E144 00 FF                             .db $00, $ff
0E146                           
0E146                           GetYOffscreenBits:
0E146 86 04                               stx $04                      ;save position in buffer to here
0E148 A0 01                               ldy #$01                     ;start with bottom of screen
0E14A B9 44 E1                  YOfsLoop: lda HighPosUnitData,y        ;load coordinate for edge of vertical unit
0E14D 38                                  sec
0E14E F5 CE                               sbc SprObject_Y_Position,x   ;subtract from vertical coordinate of object
0E150 85 07                               sta $07                      ;store here
0E152 A9 01                               lda #$01                     ;subtract one from vertical high byte of object
0E154 F5 B5                               sbc SprObject_Y_HighPos,x
0E156 BE 41 E1                            ldx DefaultYOnscreenOfs,y    ;load offset value here
0E159 C9 00                               cmp #$00
0E15B 30 10                               bmi YLdBData                 ;if under top of the screen or beyond bottom, branch
0E15D BE 42 E1                            ldx DefaultYOnscreenOfs+1,y  ;if not, load alternate offset value here
0E160 C9 01                               cmp #$01
0E162 10 09                               bpl YLdBData                 ;if one vertical unit or more above the screen, branch
0E164 A9 20                               lda #$20                     ;if no branching, load value here and store
0E166 85 06                               sta $06
0E168 A9 04                               lda #$04                     ;load some other value and execute subroutine
0E16A 20 7A E1                            jsr DividePDiff
0E16D BD 38 E1                  YLdBData: lda YOffscreenBitsData,x     ;get offscreen data bits using offset
0E170 A6 04                               ldx $04                      ;reobtain position in buffer
0E172 C9 00                               cmp #$00
0E174 D0 03                               bne ExYOfsBS                 ;if bits not zero, branch to leave
0E176 88                                  dey                          ;otherwise, do top of the screen now
0E177 10 D1                               bpl YOfsLoop
0E179 60                        ExYOfsBS: rts
0E17A                           
0E17A                           ;--------------------------------
0E17A                           
0E17A                           DividePDiff:
0E17A 85 05                               sta $05       ;store current value in A here
0E17C A5 07                               lda $07       ;get pixel difference
0E17E C5 06                               cmp $06       ;compare to preset value
0E180 B0 0C                               bcs ExDivPD   ;if pixel difference >= preset value, branch
0E182 4A                                  lsr           ;divide by eight
0E183 4A                                  lsr
0E184 4A                                  lsr
0E185 29 07                               and #$07      ;mask out all but 3 LSB
0E187 C0 01                               cpy #$01      ;right side of the screen or top?
0E189 B0 02                               bcs SetOscrO  ;if so, branch, use difference / 8 as offset
0E18B 65 05                               adc $05       ;if not, add value to difference / 8
0E18D AA                        SetOscrO: tax           ;use as offset
0E18E 60                        ExDivPD:  rts           ;leave
0E18F                           
0E18F                           ;-------------------------------------------------------------------------------------
0E18F                           ;$00-$01 - tile numbers
0E18F                           ;$02 - Y coordinate
0E18F                           ;$03 - flip control
0E18F                           ;$04 - sprite attributes
0E18F                           ;$05 - X coordinate
0E18F                           
0E18F                           DrawSpriteObject:
0E18F A5 03                              lda $03                    ;get saved flip control bits
0E191 4A                                 lsr
0E192 4A                                 lsr                        ;move d1 into carry
0E193 A5 00                              lda $00
0E195 90 0C                              bcc NoHFlip                ;if d1 not set, branch
0E197 99 05 02                           sta Sprite_Tilenumber+4,y  ;store first tile into second sprite
0E19A A5 01                              lda $01                    ;and second into first sprite
0E19C 99 01 02                           sta Sprite_Tilenumber,y
0E19F A9 40                              lda #$40                   ;activate horizontal flip OAM attribute
0E1A1 D0 0A                              bne SetHFAt                ;and unconditionally branch
0E1A3 99 01 02                  NoHFlip: sta Sprite_Tilenumber,y    ;store first tile into first sprite
0E1A6 A5 01                              lda $01                    ;and second into second sprite
0E1A8 99 05 02                           sta Sprite_Tilenumber+4,y
0E1AB A9 00                              lda #$00                   ;clear bit for horizontal flip
0E1AD 05 04                     SetHFAt: ora $04                    ;add other OAM attributes if necessary
0E1AF 99 02 02                           sta Sprite_Attributes,y    ;store sprite attributes
0E1B2 99 06 02                           sta Sprite_Attributes+4,y
0E1B5 A5 02                              lda $02                    ;now the y coordinates
0E1B7 99 00 02                           sta Sprite_Y_Position,y    ;note because they are
0E1BA 99 04 02                           sta Sprite_Y_Position+4,y  ;side by side, they are the same
0E1BD A5 05                              lda $05       
0E1BF 99 03 02                           sta Sprite_X_Position,y    ;store x coordinate, then
0E1C2 18                                 clc                        ;add 8 pixels and store another to
0E1C3 69 08                              adc #$08                   ;put them side by side
0E1C5 99 07 02                           sta Sprite_X_Position+4,y
0E1C8 A5 02                              lda $02                    ;add eight pixels to the next y
0E1CA 18                                 clc                        ;coordinate
0E1CB 69 08                              adc #$08
0E1CD 85 02                              sta $02
0E1CF 98                                 tya                        ;add eight to the offset in Y to
0E1D0 18                                 clc                        ;move to the next two sprites
0E1D1 69 08                              adc #$08
0E1D3 A8                                 tay
0E1D4 E8                                 inx                        ;increment offset to return it to the
0E1D5 E8                                 inx                        ;routine that called this subroutine
0E1D6 60                                 rts
0E1D7                           
0E1D7                           ;-------------------------------------------------------------------------------------
0E1D7                            
0E1D7                           AttractModeSubs:
0E1D7 AD 72 07                        lda OperMode_Task
0E1DA 20 F8 8C                        jsr JumpEngine
0E1DD                           
0E1DD 0F E2                           .dw AttractModeDiskRoutines
0E1DF 68 E4                           .dw InitializeGame
0E1E1 94 84                           .dw ScreenRoutines
0E1E3 8B E4                           .dw PrimaryGameSetup
0E1E5 FF E2                           .dw GameMenuRoutine
0E1E7 E9 E1                           .dw PrepareTheGame
0E1E9                           
0E1E9                           PrepareTheGame:
0E1E9 AD FC 07                        lda DiskIOTask
0E1EC 20 F8 8C                        jsr JumpEngine
0E1EF                           
0E1EF 87 E2                           .dw DiskScreen
0E1F1 F3 E1                           .dw StartTheGame
0E1F3                           
0E1F3                           StartTheGame:
0E1F3 20 AF FE                           jsr RunLoadAreaPointer    ;update area pointer for world 1-1
0E1F6 EE 5D 07                           inc Hidden1UpFlag
0E1F9 EE 57 07                           inc FetchNewGameTimerFlag
0E1FC EE 70 07                           inc OperMode
0E1FF A9 00                              lda #$00
0E201 8D FC 07                           sta DiskIOTask
0E204 8D 72 07                           sta OperMode_Task
0E207 8D A2 07                           sta DemoTimer
0E20A A9 02                              lda #BG_MainBank+2
0E20C 4C 2F FE                           jmp SwitchBG_CHR1         ;replace title screen gfx data
0E20F                           
0E20F                           AttractModeDiskRoutines:
0E20F AD FC 07                        lda DiskIOTask
0E212 20 F8 8C                        jsr JumpEngine
0E215                           
0E215 87 E2                           .dw DiskScreen
0E217 19 E2                           .dw InitWorldPos
0E219                           
0E219                           InitWorldPos:
0E219 A9 00                                lda #$00
0E21B 8D F7 07                             sta FileListNumber    ;reset filelist number
0E21E 8D 5F 07                             sta WorldNumber       ;reset world number
0E221 8D FB 07                             sta HardWorldFlag     ;force player to start at SMB1 levels
0E224 A9 0A                                lda #BG_TitleBank+2   ;load title screen graphics data
0E226 20 2F FE                             jsr SwitchBG_CHR1
0E229 4C 50 E2                             jmp ResetDiskIOTask   ;end disk subroutines
0E22C                           
0E22C                           GameModeDiskRoutines:
0E22C AD FC 07                        lda DiskIOTask
0E22F 20 F8 8C                        jsr JumpEngine
0E232                           
0E232 87 E2                           .dw DiskScreen
0E234 36 E2                           .dw LoadWindWorlds5ThruD
0E236                           
0E236                           LoadWindWorlds5ThruD:
0E236 AD FB 07                        lda HardWorldFlag     ;if in SMB1 levels
0E239 F0 15                           beq ResetDiskIOTask   ;then leave without loading anything
0E23B AD 5F 07                        lda WorldNumber       ;if in 2J worlds 1-4
0E23E C9 04                           cmp #World5           ;then leave without loading anything
0E240 90 0E                           bcc ResetDiskIOTask
0E242 AD F7 07                        lda FileListNumber    ;if we were already in 2J worlds 5-D, leave
0E245 4A                              lsr
0E246 B0 08                           bcs ResetDiskIOTask   ;as there's no need to load anything
0E248 A9 01                           lda #$01
0E24A 8D F7 07                        sta FileListNumber    ;otherwise set filelist number
0E24D 20 5F E7                        jsr InitializeLeaves  ;init leaf positions for wind
0E250                           
0E250                           ResetDiskIOTask:
0E250 A9 00                           lda #$00              ;reset disk-related task number for next time
0E252 8D FC 07                        sta DiskIOTask
0E255                           VMDelay:
0E255 EE 72 07                        inc OperMode_Task     ;move on to next task in the current mode
0E258 60                              rts
0E259                           
0E259                           StartVMDelay:
0E259 A9 10                           lda #$10           ;start world end delay
0E25B 8D A1 07                        sta WorldEndTimer
0E25E D0 F5                           bne VMDelay
0E260                           
0E260                           ContinueVMDelay:
0E260 AD A1 07                        lda WorldEndTimer  ;wait for delay to end, then move on
0E263 F0 F0                           beq VMDelay
0E265 60                              rts
0E266                           
0E266                           VictoryModeDiskRoutines:
0E266 AD FC 07                        lda DiskIOTask
0E269 20 F8 8C                        jsr JumpEngine
0E26C                           
0E26C 87 E2                           .dw DiskScreen
0E26E 70 E2                           .dw LoadEnding
0E270                           
0E270                           LoadEnding:
0E270 A9 0D                             lda #Spr_EndingBank+1
0E272 20 6C FE                          jsr SwitchSPR_CHR1       ;load princess graphics
0E275 20 0D 8D                          jsr InitializeNameTables
0E278 20 50 E2                          jsr ResetDiskIOTask      ;end disk subroutines
0E27B 8D 3C 07                          sta ScreenRoutineTask    ;init screen routine task
0E27E 60                                rts
0E27F                           
0E27F                           DiskScreenPalette:
0E27F 3F 00 04                    .db $3f, $00, $04
0E282 0F 30 30 0F                 .db $0f, $30, $30, $0f
0E286 00                          .db $00
0E287                           
0E287                           DiskScreen:
0E287 A9 00                           lda #$00
0E289                                 ;apparently MMC3 IRQ does not like this :(
0E289                                 ;sta Mirror_PPU_MASK
0E289                                 ;sta PPU_MASK
0E289 8D 22 07                        sta IRQUpdateFlag
0E28C EE 74 07                        inc DisableScreenFlag
0E28F A9 1B                           lda #$1b
0E291 8D 73 07                        sta VRAM_Buffer_AddrCtrl
0E294 EE FC 07                        inc DiskIOTask        ;move on to next subtask involving the disk drive
0E297 60                              rts
0E298                           
0E298                           GameOverCursorData:
0E298 5B 02 48                    .db $5b, $02, $48
0E29B                           
0E29B                           GameOverCursorY:
0E29B 77 8F                       .db $77, $8f
0E29D                           
0E29D                           GameOverMenu:
0E29D A9 00                                 lda #$00
0E29F 8D 74 07                              sta DisableScreenFlag
0E2A2 AD FC 06                              lda SavedJoypadBits          ;if player pressed the start button
0E2A5 29 10                                 and #Start_Button            ;then either continue or start over
0E2A7 D0 2D                                 bne ContinueOrRetry
0E2A9 AD FC 06                              lda SavedJoypadBits
0E2AC 29 20                                 and #Select_Button           ;if player pressed the select button
0E2AE F0 11                                 beq ChgSel                   ;then branch to select "continue" or "retry"
0E2B0 AE 80 07                              ldx SelectTimer              ;if select timer not expired while
0E2B3 D0 0C                                 bne ChgSel                   ;pressing select, skip this
0E2B5 4A                                    lsr
0E2B6 8D 80 07                              sta SelectTimer              ;otherwise set the select timer
0E2B9 AD F8 07                              lda ContinueMenuSelect
0E2BC 49 01                                 eor #$01                     ;and toggle between the two choices
0E2BE 8D F8 07                              sta ContinueMenuSelect
0E2C1 A0 02                     ChgSel:     ldy #$02
0E2C3 B9 98 E2                  ChgSelLoop: lda GameOverCursorData,y     ;set up cursor sprite tile, attribute
0E2C6 99 01 02                              sta Sprite_Data+1,y          ;and X position in sprite OAM data
0E2C9 88                                    dey
0E2CA 10 F7                                 bpl ChgSelLoop
0E2CC AC F8 07                              ldy ContinueMenuSelect
0E2CF B9 9B E2                              lda GameOverCursorY,y        ;set Y position based on the selection
0E2D2 8D 00 02                              sta Sprite_Data
0E2D5 60                                    rts
0E2D6                           
0E2D6                           ContinueOrRetry:
0E2D6 AD F8 07                    lda ContinueMenuSelect       ;if player selected "continue"
0E2D9 F0 08                       beq Continue                 ;then branch to continue
0E2DB A9 00                       lda #$00
0E2DD 8D FA 07                    sta CompletedWorlds          ;otherwise init completed worlds flags
0E2E0 4C 37 91                    jmp TerminateGame            ;and end the game
0E2E3                           
0E2E3                           Continue:
0E2E3 A0 04                             ldy #$04
0E2E5 8C 5A 07                          sty NumberofLives           ;give five lives
0E2E8 8D 5C 07                          sta LevelNumber
0E2EB 8D 60 07                          sta AreaNumber              ;put at x-1 of the current world
0E2EE 8D 5E 07                          sta CoinTally
0E2F1 A0 0B                             ldy #$0b
0E2F3 99 DD 07                  ISCont: sta ScoreAndCoinDisplay,y   ;reset score
0E2F6 88                                dey
0E2F7 10 FA                             bpl ISCont
0E2F9 EE 5D 07                          inc Hidden1UpFlag           ;allow 1-up to be found again
0E2FC 4C 4A 91                          jmp ContinueGame
0E2FF                           
0E2FF                           ;-------------------------------------------------------------------------------------
0E2FF                           
0E2FF                           GameMenuRoutine:
0E2FF AD FC 06                                lda SavedJoypadBits         ;check to see if the player pressed start
0E302 29 10                                   and #Start_Button
0E304 F0 0E                                   beq ChkSelect               ;if not, branch to check other buttons
0E306 A9 00                                   lda #$00
0E308 8D FA 07                                sta CompletedWorlds
0E30B 8D FC 07                                sta DiskIOTask
0E30E 8D FB 07                                sta HardWorldFlag
0E311 4C 6C E3                                jmp StartGame
0E314 AD FC 06                  ChkSelect:    lda SavedJoypadBits
0E317 C9 20                                   cmp #Select_Button          ;branch if pressing select
0E319 F0 0F                                   beq SelectLogic
0E31B AE A2 07                                ldx DemoTimer
0E31E D0 2F                                   bne NullJoypad
0E320 8D 80 07                                sta SelectTimer             ;run demo after a certain period of time
0E323 20 DC E3                                jsr DemoEngine
0E326 B0 35                                   bcs ResetTitle
0E328 90 2A                                   bcc RunDemo
0E32A AD A2 07                  SelectLogic:  lda DemoTimer               ;if select pressed, check demo timer one last time
0E32D F0 2E                                   beq ResetTitle              ;if demo timer expired, branch to reset attract mode
0E32F A9 18                                   lda #$18                    ;otherwise reset demo timer
0E331 8D A2 07                                sta DemoTimer
0E334 A5 09                                   lda FrameCounter            ;erase LSB of frame counter
0E336 29 FE                                   and #$fe
0E338 85 09                                   sta FrameCounter
0E33A AD 80 07                                lda SelectTimer             ;if select timer not expired, skip to slow select down
0E33D D0 10                                   bne NullJoypad
0E33F A9 10                                   lda #$10                    ;reset select button timer
0E341 8D 80 07                                sta SelectTimer
0E344 AD 53 07                                lda SelectedPlayer          ;switch between the two players to select one
0E347 49 01                                   eor #$01
0E349 8D 53 07                                sta SelectedPlayer
0E34C 20 96 E3                                jsr DrawMenuCursor
0E34F A9 00                     NullJoypad:   lda #$00
0E351 8D FC 06                                sta SavedJoypadBits
0E354 20 5A 9B                  RunDemo:      jsr GameCoreRoutine         ;run game engine
0E357 A5 0E                                   lda GameEngineSubroutine    ;check to see if we're running lose life routine
0E359 C9 06                                   cmp #$06
0E35B D0 30                                   bne ExitMenu                ;if not, do not do all the resetting below
0E35D A9 00                     ResetTitle:   lda #$00                    ;reset game modes, disable
0E35F 8D 70 07                                sta OperMode                ;IRQ and screen output 
0E362 8D 72 07                                sta OperMode_Task           ;screen output
0E365 8D 22 07                                sta IRQUpdateFlag
0E368 EE 74 07                                inc DisableScreenFlag
0E36B 60                                      rts
0E36C                           
0E36C                           StartGame:
0E36C AD A2 07                                lda DemoTimer
0E36F F0 EC                                   beq ResetTitle
0E371 EE 72 07                                inc OperMode_Task
0E374 A9 00                                   lda #$00
0E376 8D 5F 07                                sta WorldNumber
0E379 A9 00                                   lda #$00
0E37B 8D 5C 07                                sta LevelNumber
0E37E A9 00                                   lda #$00
0E380 8D 60 07                                sta AreaNumber
0E383 A2 0B                                   ldx #$0b
0E385 A9 00                                   lda #$00
0E387 9D DD 07                  InitScore:    sta ScoreAndCoinDisplay,x   ;clear player score and coin display
0E38A CA                                      dex
0E38B 10 FA                                   bpl InitScore
0E38D 60                        ExitMenu:     rts
0E38E                           
0E38E                           MenuCursorTemplate:
0E38E 06 22 6B 83 CE 24 24 00         .db $06, $22, $6b, $83, $ce, $24, $24, $00
0E396                           
0E396                           DrawMenuCursor:
0E396 A0 07                                   ldy #$07                  ;read eight bytes to be read by transfer routine
0E398                           CursorDataRead:
0E398 B9 8E E3                                lda MenuCursorTemplate,y  ;note that the default position is set for
0E39B 99 00 03                                sta VRAM_Buffer1-1,y      ;mario game
0E39E 88                                      dey
0E39F 10 F7                                   bpl CursorDataRead
0E3A1 AD 53 07                                lda SelectedPlayer        ;check selected player
0E3A4 F0 0A                                   beq ExitCursor            ;if set to mario game, we're done
0E3A6 A9 24                                   lda #$24                  ;otherwise, load blank tile in mario game position
0E3A8 8D 04 03                                sta VRAM_Buffer1+3
0E3AB A9 CE                                   lda #$ce                  ;then load shroom icon tile in luigi game position
0E3AD 8D 06 03                                sta VRAM_Buffer1+5
0E3B0 60                        ExitCursor:   rts
0E3B1                           
0E3B1                           DemoActionData:
0E3B1 01 80 02 81 41 80 01            .db $01, $80, $02, $81, $41, $80, $01
0E3B8 42 C2 02 80 41 C1 41 C1         .db $42, $c2, $02, $80, $41, $c1, $41, $c1
0E3C0 01 C1 01 02 80 00               .db $01, $c1, $01, $02, $80, $00
0E3C6                           
0E3C6                           DemoTimingData:
0E3C6 9B 10 20 09 34 20 24            .db $9b, $10, $20, $09, $34, $20, $24
0E3CD 15 5A 10 20 28 30 20 18         .db $15, $5a, $10, $20, $28, $30, $20, $18
0E3D5 50 20 30 40 03 7F 00            .db $50, $20, $30, $40, $03, $7f, $00
0E3DC                           
0E3DC                           DemoEngine:
0E3DC AE 17 07                            ldx DemoAction         ;load current demo action
0E3DF AD 18 07                            lda DemoActionTimer    ;load current action timer
0E3E2 D0 0D                               bne DoAction           ;if timer still counting down, skip
0E3E4 E8                                  inx
0E3E5 EE 17 07                            inc DemoAction         ;if expired, increment action, X, and
0E3E8 38                                  sec                    ;set carry by default for demo over
0E3E9 BD C5 E3                            lda DemoTimingData-1,x ;get next timer
0E3EC 8D 18 07                            sta DemoActionTimer    ;store as current timer
0E3EF F0 0A                               beq DemoOver           ;if timer already at zero, skip
0E3F1 BD B0 E3                  DoAction: lda DemoActionData-1,x ;get and perform action (current or next)
0E3F4 8D FC 06                            sta SavedJoypad1Bits
0E3F7 CE 18 07                            dec DemoActionTimer    ;decrement action timer
0E3FA 18                                  clc                    ;clear carry if demo still going
0E3FB 60                        DemoOver: rts
0E3FC                           
0E3FC                           ClearBuffersDrawIcon:
0E3FC AD 70 07                               lda OperMode               ;check game mode
0E3FF D0 64                                  bne IncModeTask_B          ;if not attract mode, leave
0E401 A2 00                                  ldx #$00                   ;otherwise, clear buffer space
0E403 9D 00 03                  TScrClear:   sta VRAM_Buffer1-1,x
0E406 9D 00 04                               sta VRAM_Buffer1-1+$100,x
0E409 CA                                     dex
0E40A D0 F7                                  bne TScrClear
0E40C 20 96 E3                               jsr DrawMenuCursor         ;draw player select cursor
0E40F 20 16 E4                               jsr DrawTitleScreenStars
0E412 EE 3C 07                               inc ScreenRoutineTask      ;move onto next task
0E415 60                                     rts
0E416                           
0E416                           ;-------------------------------------------------------------------------------------
0E416                           ;$00 - used to store low byte of VRAM address
0E416                           ;$01 - used to store number of title screen stars drawn per line
0E416                           
0E416                           DrawTitleScreenStars:
0E416 A9 D1                                 lda #$d1                 ;set the VRAM address for the first line of stars
0E418 85 00                                 sta $00
0E41A AD 07 60                              lda GamesBeatenCount     ;have we beaten the game at least once?
0E41D F0 40                                 beq NoStars              ;if not, we don't need to be here
0E41F C9 0A                                 cmp #$0a                 ;do we have more than 9 stars?
0E421 90 15                                 bcc DrawLine             ;if not, draw the first line as-is
0E423 A9 09                                 lda #$09                 ;otherwise, we need 9 stars for the first line
0E425 20 38 E4                              jsr DrawLine
0E428 A9 F1                                 lda #$f1                 ;now set the VRAM address for the second line
0E42A 85 00                                 sta $00
0E42C AD 07 60                              lda GamesBeatenCount     ;get the correct number of stars to draw for the second line
0E42F 38                                    sec
0E430 E9 09                                 sbc #$09
0E432 C9 0A                                 cmp #$0a                 ;do we have somehow have more than 18 stars total?
0E434 90 02                                 bcc DrawLine             ;if not, draw the second line normally
0E436 A9 09                                 lda #$09                 ;if we do, force the second line to only have 9 stars
0E438 09 40                     DrawLine:   ora #%01000000           ;add bit to indicate repeated tile
0E43A 85 01                                 sta $01                  ;and store in temp variable
0E43C AE 00 03                              ldx VRAM_Buffer1_Offset
0E43F A9 20                                 lda #$20                 ;write proper address for title screen stars
0E441 9D 01 03                              sta VRAM_Buffer1,x
0E444 A5 00                                 lda $00
0E446 9D 02 03                              sta VRAM_Buffer1+1,x
0E449 A5 01                                 lda $01                  ;write how many stars to draw for this line
0E44B 9D 03 03                              sta VRAM_Buffer1+2,x
0E44E A9 F1                                 lda #$f1
0E450 9D 04 03                              sta VRAM_Buffer1+3,x
0E453 A9 00                                 lda #$00                 ;put null terminator at the end
0E455 9D 05 03                              sta VRAM_Buffer1+4,x
0E458 8A                                    txa                      ;move the buffer offset up by four bytes
0E459 18                                    clc
0E45A 69 04                                 adc #$04
0E45C 8D 00 03                              sta VRAM_Buffer1_Offset
0E45F 60                        NoStars:    rts                      ;now we're done!
0E460                           
0E460                           ;-------------------------------------------------------------------------------------
0E460                           
0E460                           WriteTopScore:
0E460 A9 FA                                    lda #$fa                    ;run display routine to display top score on title
0E462 20 3F A9                                 jsr WriteDigits
0E465 4C CA 82                  IncModeTask_B: jmp IncModeTask
0E468                           
0E468                           InitializeGame:
0E468 A9 00                                 lda #$00
0E46A 8D FA 07                              sta CompletedWorlds      ;clean slate player's progress (except for games beaten)
0E46D 8D FB 07                              sta HardWorldFlag
0E470 8D 53 07                              sta SelectedPlayer
0E473 A0 6F                                 ldy #$6f                 ;clear all memory as in initialization procedure,
0E475 20 92 8F                              jsr InitializeMemory     ;but this time, clear only as far as $076f
0E478 A0 1F                                 ldy #$1f
0E47A 99 B0 07                  ClrSndLoop: sta SoundMemory,y        ;clear out memory used
0E47D 88                                    dey                      ;by the sound engines
0E47E 10 FA                                 bpl ClrSndLoop
0E480                           
0E480                           DemoReset:
0E480 A9 18                                 lda #$18             ;set demo timer
0E482 8D A2 07                              sta DemoTimer
0E485 20 AF FE                              jsr RunLoadAreaPointer
0E488 4C B2 8E                              jmp InitializeArea
0E48B                           
0E48B                           PrimaryGameSetup:
0E48B A9 01                           lda #$01
0E48D 8D 57 07                        sta FetchNewGameTimerFlag   ;set flag to load game timer from header
0E490 8D 54 07                        sta PlayerSize              ;set player's size to small
0E493 A9 04                           lda #$04
0E495 8D 5A 07                        sta NumberofLives           ;give each player five lives
0E498 4C 43 8F                        jmp SecondaryGameSetup
0E49B                           
0E49B                           ;-------------------------------------------------------------------------------------
0E49B                           
0E49B                           TitleScreenGfxData:
0E49B                                  ;.db $20, $84, $01, $44
0E49B                                  ;.db $20, $85, $57, $48
0E49B                                  ;.db $20, $9c, $01, $49
0E49B                                  ;.db $20, $a4, $c9, $46
0E49B                                  ;.db $20, $a5, $57, $26
0E49B                                  ;.db $20, $bc, $c9, $4a
0E49B                                  ;.db $20, $a5, $0a, $d0, $d1, $d8, $d8, $de, $d1, $d0, $da, $de, $d1
0E49B                                  ;.db $20, $c5, $17, $d2, $d3, $db, $db, $db, $d9, $db, $dc, $db, $df
0E49B                                  ;.db $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26
0E49B                                  ;.db $20, $e5, $17, $d4, $d5, $d4, $d9, $db, $e2, $d4, $da, $db, $e0
0E49B                                  ;.db $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26
0E49B                                  ;.db $21, $05, $57, $26
0E49B                                  ;.db $21, $05, $0a, $d6, $d7, $d6, $d7, $e1, $26, $d6, $dd, $e1, $e1
0E49B                                  ;.db $21, $25, $17, $d0, $e8, $d1, $d0, $d1, $de, $d1, $d8, $d0, $d1
0E49B                                  ;.db $26, $de, $d1, $de, $d1, $d0, $d1, $d0, $d1, $26, $26, $d0, $d1
0E49B                                  ;.db $21, $45, $17, $db, $42, $42, $db, $42, $db, $42, $db, $db, $42
0E49B                                  ;.db $26, $db, $42, $db, $42, $db, $42, $db, $42, $26, $26, $db, $42
0E49B                                  ;.db $21, $65, $46, $db
0E49B                                  ;.db $21, $6b, $11, $df, $db, $db, $db, $26, $db, $df, $db, $df, $db
0E49B                                  ;.db $db, $e4, $e5, $26, $26, $ec, $ed
0E49B                                  ;.db $21, $85, $17, $db, $db, $db, $de, $43, $db, $e0, $db, $db, $db
0E49B                                  ;.db $26, $db, $e3, $db, $e0, $db, $db, $e6, $e3, $26, $26, $ee, $ef
0E49B                                  ;.db $21, $a5, $17, $db, $db, $db, $db, $42, $db, $db, $db, $d4, $d9
0E49B                                  ;.db $26, $db, $d9, $db, $db, $d4, $d9, $d4, $d9, $e7, $26, $de, $da
0E49B                                  ;.db $21, $c4, $19, $5f, $95, $95, $95, $95, $95, $95, $95, $95, $97
0E49B                                  ;.db $98, $78, $95, $96, $95, $95, $97, $98, $97, $98, $95, $78, $95
0E49B                                  ;.db $f0, $7a
0E49B                                  ;.db $21, $ef, $0e, $cf, $01, $09, $08, $06, $24, $17, $12, $17, $1d
0E49B                                  ;.db $0e, $17, $0d, $18
0E49B                                  ;.db $22, $4d, $0a, $16, $0a, $1b, $12, $18, $24, $10, $0a, $16, $0e
0E49B                                  ;.db $22, $8d, $0a, $15, $1e, $12, $10, $12, $24, $10, $0a, $16, $0e
0E49B                                  ;.db $22, $eb, $04, $1d, $18, $19, $28
0E49B                                  ;.db $22, $f5, $01, $00
0E49B                                  ;.db $23, $c9, $47, $55
0E49B                                  ;.db $23, $d1, $47, $55
0E49B                                  ;.db $23, $d9, $47, $55
0E49B                                  ;.db $23, $cc, $43, $f5
0E49B                                  ;.db $23, $d6, $01, $dd
0E49B                                  ;.db $23, $de, $01, $5d
0E49B                                  ;.db $23, $e2, $04, $55, $aa, $aa, $aa
0E49B                                  ;.db $23, $ea, $04, $95, $aa, $aa, $2a
0E49B                                  ;.db $00, $ff, $ff
0E49B                           
0E49B 20 A6 54 26 20 C6 54 26..        .incbin "titlescreen.bin"
0E5FD                           
0E5FD                           ;-------------------------------------------------------------------------------------------------
0E5FD                           ;$06 - used to store vertical length of pipe
0E5FD                           ;$07 - starts with adder from area parser, used to store row offset
0E5FD                           
0E5FD                           UpsideDownPipe_High:
0E5FD A9 01                            lda #$01                     ;start at second row
0E5FF 48                               pha
0E600 D0 0D                            bne UDP
0E602                           UpsideDownPipe_Low:
0E602 AD FB 07                         lda HardWorldFlag            ;playing 2J levels?
0E605 D0 05                            bne UDPJ                     ;if so, use standard position
0E607 A9 03                            lda #$03                     ;otherwise start at fourth row like
0E609 48                               pha                          ;that god-forsaken upside-down pipe
0E60A D0 03                            bne UDP                      ;patch for super mario bros. 1
0E60C A9 04                     UDPJ:  lda #$04                     ;start at fifth row
0E60E 48                               pha
0E60F 20 68 98                  UDP:   jsr GetPipeHeight            ;get pipe height from object byte
0E612 68                               pla
0E613 85 07                            sta $07                      ;save buffer offset temporarily
0E615 98                               tya
0E616 48                               pha                          ;save pipe height temporarily
0E617 BC 30 07                         ldy AreaObjectLength,x       ;if on second column of pipe, skip this
0E61A F0 23                            beq NoUDP
0E61C 20 98 98                         jsr FindEmptyEnemySlot       ;otherwise try to insert upside-down
0E61F B0 1E                            bcs NoUDP                    ;piranha plant, if no empty slots, skip this
0E621 A9 04                            lda #$04
0E623 20 79 98                         jsr SetupPiranhaPlant        ;set up upside-down piranha plant
0E626 A5 06                            lda $06
0E628 0A                               asl
0E629 0A                               asl                          ;multiply height of pipe by 16
0E62A 0A                               asl                          ;and add enemy Y position previously set up
0E62B 0A                               asl                          ;then subtract 10 pixels, save as new Y position
0E62C 18                               clc
0E62D 75 CF                            adc Enemy_Y_Position,x
0E62F 38                               sec
0E630 E9 0A                            sbc #$0a
0E632 95 CF                            sta Enemy_Y_Position,x
0E634 9D 34 04                         sta PiranhaPlantDownYPos,x   ;set as "down" position
0E637 18                               clc                          ;add 24 pixels, save as "up" position
0E638 69 18                            adc #$18                     ;note up and down here are reversed
0E63A 9D 17 04                         sta PiranhaPlantUpYPos,x     
0E63D F6 A0                            inc PiranhaPlant_MoveFlag,x  ;set movement flag
0E63F 68                        NoUDP: pla
0E640 A8                               tay                          ;return tile offset
0E641 48                               pha
0E642 A6 07                            ldx $07
0E644 B9 25 98                         lda VerticalPipeData+2,y
0E647 A4 06                            ldy $06                      ;render the pipe shaft
0E649 88                               dey
0E64A 20 CD 9A                         jsr RenderUnderPart
0E64D 68                               pla
0E64E A8                               tay
0E64F B9 23 98                         lda VerticalPipeData,y       ;and render the pipe end
0E652 9D A1 06                         sta MetatileBuffer,x
0E655 60                               rts
0E656                           
0E656 60                               rts                        ;unused, nothing jumps here
0E657                           
0E657                           MoveUpsideDownPiranhaP:
0E657 B5 1E                           lda Enemy_State,x           ;check enemy state
0E659 D0 39                           bne ExMoveUDPP              ;if set at all, branch to leave
0E65B BD 8A 07                        lda EnemyFrameTimer,x       ;check enemy's timer here
0E65E D0 34                           bne ExMoveUDPP              ;branch to end if not yet expired
0E660 B5 A0                           lda PiranhaPlant_MoveFlag,x ;check movement flag
0E662 D0 0B                           bne SetupToMoveUDPPlant     ;if moving, skip to part ahead
0E664 B5 58                           lda PiranhaPlant_Y_Speed,x  ;get vertical speed
0E666 49 FF                           eor #$ff
0E668 18                              clc                         ;change to two's compliment
0E669 69 01                           adc #$01
0E66B 95 58                           sta PiranhaPlant_Y_Speed,x  ;save as new vertical speed
0E66D F6 A0                           inc PiranhaPlant_MoveFlag,x ;increment to set movement flag
0E66F                           
0E66F                           SetupToMoveUDPPlant:
0E66F BD 17 04                        lda PiranhaPlantUpYPos,x    ;get original vertical coordinate (lowest point)
0E672 B4 58                           ldy PiranhaPlant_Y_Speed,x  ;get vertical speed
0E674 10 03                           bpl RiseFallUDPiranhaPlant  ;branch if moving downwards
0E676 BD 34 04                        lda PiranhaPlantDownYPos,x  ;otherwise get other vertical coordinate (highest point)
0E679                           
0E679                           RiseFallUDPiranhaPlant:
0E679 85 00                            sta $00                     ;save vertical coordinate here
0E67B AD 47 07                         lda TimerControl            ;get master timer control
0E67E D0 14                            bne ExMoveUDPP              ;branch to leave if set (likely not necessary)
0E680 B5 CF                            lda Enemy_Y_Position,x      ;get current vertical coordinate
0E682 18                               clc
0E683 75 58                            adc PiranhaPlant_Y_Speed,x  ;add vertical speed to move up or down
0E685 95 CF                            sta Enemy_Y_Position,x      ;save as new vertical coordinate
0E687 C5 00                            cmp $00                     ;compare against low or high coordinate
0E689 D0 09                            bne ExMoveUDPP              ;branch to leave if not yet reached
0E68B A9 00                            lda #$00
0E68D 95 A0                            sta PiranhaPlant_MoveFlag,x ;otherwise clear movement flag
0E68F A9 20                            lda #$20
0E691 9D 8A 07                         sta EnemyFrameTimer,x       ;set timer to delay piranha plant movement
0E694                           ExMoveUDPP:
0E694 60                               rts
0E695                           
0E695                           ;-------------------------------------------------------------------------------------
0E695                           
0E695                           BlowPlayerAround:
0E695 AD F9 07                          lda WindFlag            ;if wind is turned off, just exit
0E698 F0 28                             beq ExBlow
0E69A AD 4E 07                          lda AreaType            ;don't blow the player around unless
0E69D C9 01                             cmp #$01                ;the area is ground type
0E69F D0 21                             bne ExBlow
0E6A1 A0 01                             ldy #$01
0E6A3 A5 09                             lda FrameCounter        ;branch to set d0 if on an odd frame
0E6A5 0A                                asl
0E6A6 B0 02                             bcs BThr                ;otherwise wind will only blow
0E6A8 A0 03                             ldy #$03                ;one out of every four frames
0E6AA 84 00                     BThr:   sty $00
0E6AC A5 09                             lda FrameCounter        ;throttle wind blowing by using the frame counter
0E6AE 25 00                             and $00                 ;to mask out certain frames
0E6B0 D0 10                             bne ExBlow
0E6B2 A5 86                             lda Player_X_Position   ;move player slightly to the right
0E6B4 18                                clc                     ;to simulate the wind moving the player
0E6B5 69 01                             adc #$01
0E6B7 85 86                             sta Player_X_Position
0E6B9 A5 6D                             lda Player_PageLoc
0E6BB 69 00                             adc #$00
0E6BD 85 6D                             sta Player_PageLoc
0E6BF EE FF 06                          inc Player_X_Scroll     ;add one to movement speed for scroll
0E6C2 60                        ExBlow: rts
0E6C3                           
0E6C3                           ;note the position data values are overwritten in RAM
0E6C3                           LeavesYPos:
0E6C3 30 70 B8 50 98 30                 .db $30, $70, $b8, $50, $98, $30
0E6C9 70 B8 50 98 30 70                 .db $70, $b8, $50, $98, $30, $70
0E6CF                           
0E6CF                           LeavesXPos:
0E6CF 30 30 30 60 60 A0                 .db $30, $30, $30, $60, $60, $a0
0E6D5 A0 A0 D0 D0 D0 60                 .db $a0, $a0, $d0, $d0, $d0, $60
0E6DB                           
0E6DB                           LeavesTile:
0E6DB 7B 7B 7B 7B 7A 7A                 .db $7b, $7b, $7b, $7b, $7a, $7a
0E6E1 7B 7B 7B 7A 7B 7A                 .db $7b, $7b, $7b, $7a, $7b, $7a
0E6E7                           
0E6E7                           SimulateWind:
0E6E7 AD F9 07                            lda WindFlag             ;if no wind, branch to leave
0E6EA F0 33                               beq ExSimW
0E6EC A9 04                               lda #$04                 ;play wind sfx
0E6EE 85 FD                               sta NoiseSoundQueue
0E6F0 20 38 E7                            jsr ModifyLeavesPos      ;modify X and Y position data of leaves
0E6F3 A2 00                               ldx #$00                 ;use mostly unused sprite data offset
0E6F5 AC EB 06                            ldy Alt_SprDataOffset-1  ;for first six leaves
0E6F8 BD 1C 62                  DrawLeaf: lda LeavesYPosCopy,x
0E6FB 99 00 02                            sta Sprite_Y_Position,y  ;set up sprite data in OAM memory
0E6FE BD DB E6                            lda LeavesTile,x
0E701 99 01 02                            sta Sprite_Tilenumber,y
0E704 A9 41                               lda #$41
0E706 99 02 02                            sta Sprite_Attributes,y
0E709 BD 10 62                            lda LeavesXPosCopy,x
0E70C 99 03 02                            sta Sprite_X_Position,y
0E70F C8                                  iny
0E710 C8                                  iny
0E711 C8                                  iny
0E712 C8                                  iny
0E713 E8                                  inx                      ;if still on first six leaves, continue
0E714 E0 06                               cpx #$06                 ;using the first sprite data offset
0E716 D0 03                               bne DLLoop               ;otherwise use the next one instead
0E718 AC EC 06                            ldy Alt_SprDataOffset    ;note the next one is also used by blocks
0E71B E0 0C                     DLLoop:   cpx #$0c                 ;continue until done putting all leaves on the screen
0E71D D0 D9                               bne DrawLeaf
0E71F 60                        ExSimW:   rts
0E720                           
0E720                           LeavesPosAdder:
0E720 57 57 56 56 58 58 56 56..    .db $57, $57, $56, $56, $58, $58, $56, $56, $57, $58, $57, $58
0E72C 59 59 58 58 5A 5A 58 58..    .db $59, $59, $58, $58, $5a, $5a, $58, $58, $59, $5a, $59, $5a
0E738                           
0E738                           ModifyLeavesPos:
0E738 A2 0B                              ldx #$0b
0E73A BD 10 62                  MLPLoop: lda LeavesXPosCopy,x  ;add each adder to each X position twice
0E73D 18                                 clc                   ;and to each Y position once
0E73E 7D 20 E7                           adc LeavesPosAdder,x
0E741 7D 20 E7                           adc LeavesPosAdder,x
0E744 9D 10 62                           sta LeavesXPosCopy,x
0E747 BD 1C 62                           lda LeavesYPosCopy,x
0E74A 18                                 clc
0E74B 7D 20 E7                           adc LeavesPosAdder,x
0E74E 9D 1C 62                           sta LeavesYPosCopy,x
0E751 CA                                 dex
0E752 10 E6                              bpl MLPLoop
0E754 60                                 rts
0E755                           
0E755                           WindOn:
0E755 A9 01                          lda #$01             ;branch to turn the wind on
0E757 D0 02                          bne WOn
0E759                           WindOff:
0E759 A9 00                          lda #$00             ;turn the wind off
0E75B 8D F9 07                  WOn: sta WindFlag
0E75E 60                             rts
0E75F                           
0E75F                           InitializeLeaves:
0E75F A0 0B                           ldy #$0b              ;start counter
0E761 B9 CF E6                  WLp:  lda LeavesXPos,y      ;initialize leaf positions
0E764 99 10 62                        sta LeavesXPosCopy,y
0E767 B9 C3 E6                        lda LeavesYPos,y
0E76A 99 1C 62                        sta LeavesYPosCopy,y
0E76D 88                              dey                   ;decrement counter
0E76E 10 F1                           bpl WLp               ;branch if not done initalizing leaves
0E770 60                              rts                   ;leave
0E771                           
0E771                           ;-------------------------------------------------------------------------------------
0E771                           
0E771                           GoToDemoReset:
0E771 4C 80 E4                         jmp DemoReset
0E774                           
0E774                           DemoResetOrGameOver:
0E774 AD F5 07                         lda GameOverMsgFlag       ;if special game over message flag not set, branch
0E777 F0 F8                            beq GoToDemoReset
0E779 AD 70 07                         lda OperMode              ;if not in game over mode, branch
0E77C C9 03                            cmp #GameOverMode
0E77E D0 F1                            bne GoToDemoReset
0E780 A9 20                            lda #$20
0E782 8D A0 07                         sta ScreenTimer
0E785 A9 1E                            lda #$1e                  ;set VRAM pointer to print special game over message
0E787 8D 73 07                         sta VRAM_Buffer_AddrCtrl
0E78A 4C C5 E7                         jmp NextOperTask          ;move on to next task
0E78D                           
0E78D                           ScreenSubsForFinalRoom:
0E78D AD 3C 07                      lda ScreenRoutineTask
0E790 20 F8 8C                      jsr JumpEngine
0E793                           
0E793 C5 84                         .dw InitScreenPalette
0E795 87 85                         .dw WriteTopStatusLine
0E797 8F 85                         .dw WriteBottomStatusLine
0E799 A1 E7                         .dw DrawFinalRoom
0E79B EE 84                         .dw GetAreaPalette
0E79D 16 85                         .dw GetBackgroundColor
0E79F AF E7                         .dw RevealPrincess
0E7A1                           
0E7A1                           DrawFinalRoom:
0E7A1 A9 1C                         lda #$1c                   ;draw the princess's room
0E7A3 8D 73 07                      sta VRAM_Buffer_AddrCtrl
0E7A6 A9 00                         lda #$00
0E7A8 8D 22 07                      sta IRQUpdateFlag
0E7AB                           NextScreenTask:
0E7AB EE 3C 07                      inc ScreenRoutineTask
0E7AE 60                            rts
0E7AF                           
0E7AF                           RevealPrincess:
0E7AF A9 A2                         lda #$a2                   ;print game timer
0E7B1 20 F4 8D                      jsr PrintStatusBarNumbers
0E7B4 A9 04                         lda #VictoryMusic          ;play victory music
0E7B6 85 FC                         sta EventMusicQueue
0E7B8 A9 00                         lda #$00
0E7BA 85 0C                         sta Left_Right_Buttons     ;not residual, this does something
0E7BC 8D 7A 07                      sta NameTableSelect
0E7BF 8D 22 07                      sta IRQUpdateFlag          ;turn screen back on but without IRQs
0E7C2 8D 74 07                      sta DisableScreenFlag
0E7C5                           NextOperTask:
0E7C5 EE 72 07                      inc OperMode_Task
0E7C8 60                            rts
0E7C9                           
0E7C9                           PrintVictoryMsgsForWorld8:
0E7C9 AD 49 07                           lda MsgFractional          ;if fractional not looped to zero
0E7CC D0 2D                              bne IncVMC                 ;then branch to increment it
0E7CE AC 19 07                           ldy MsgCounter
0E7D1 C0 0A                              cpy #$0a                   ;if message counter gone past a certain
0E7D3 B0 38                              bcs EndVictoryMessages     ;point, branch to set timer and stop printing messages
0E7D5 AD 5F 07                           lda WorldNumber            ;are we on world D?
0E7D8 C9 0C                              cmp #WorldD
0E7DA F0 04                              beq DoVicM                 ;yes, display the two extra lives lines
0E7DC C0 08                              cpy #$08                   ;otherwise we shouldn't display them
0E7DE B0 2D                              bcs EndVictoryMessages
0E7E0 C8                        DoVicM:  iny
0E7E1 C8                                 iny
0E7E2 C8                                 iny                        ;add 3 to message counter to print the messages for world 8
0E7E3 AD 53 07                           lda SelectedPlayer         ;check selected player
0E7E6 F0 0C                              beq PrintVM                ;if mario, use standard message offset
0E7E8 C0 04                              cpy #$04                   ;are we thanking the player?
0E7EA D0 02                              bne HurrahM                ;if not, branch
0E7EC A0 0D                              ldy #$0d                   ;otherwise use alt offset for luigi
0E7EE C0 07                     HurrahM: cpy #$07                   ;are we printing the hurrah message?
0E7F0 D0 02                              bne PrintVM                ;if not, branch
0E7F2 A0 0E                              ldy #$0e                   ;otherwise use alt offset for luigi
0E7F4 98                        PrintVM: tya
0E7F5 18                                 clc
0E7F6 69 0C                              adc #$0c                   ;get appropriate range for victory messages
0E7F8 8D 73 07                           sta VRAM_Buffer_AddrCtrl
0E7FB AD 49 07                  IncVMC:  lda MsgFractional
0E7FE 18                                 clc
0E7FF 69 04                              adc #$04                   ;add four to counter's fractional
0E801 8D 49 07                           sta MsgFractional
0E804 AD 19 07                           lda MsgCounter             ;add carry to the message counter itself
0E807 69 00                              adc #$00
0E809 8D 19 07                           sta MsgCounter
0E80C 60                                 rts
0E80D                           
0E80D                           EndVictoryMessages:
0E80D A9 0C                             lda #$0c                   ;set interval timer, then move onto next task
0E80F 8D A1 07                          sta WorldEndTimer
0E812 EE 72 07                  ExAEL:  inc OperMode_Task
0E815                           
0E815                           EraseEndingCounters:
0E815 A9 00                             lda #$00
0E817 8D 61 07                          sta EndControlCntr
0E81A 8D 62 07                          sta MRetainerOffset
0E81D 8D 63 07                          sta CurrentFlashMRet
0E820 60                        NotYet: rts
0E821                           
0E821                           AwardExtraLives:
0E821 AD A1 07                      lda WorldEndTimer          ;wait until timer expires before running this sub
0E824 D0 FA                         bne NotYet
0E826 AD 5F 07                      lda WorldNumber            ;are we on world D?
0E829 C9 0C                         cmp #WorldD
0E82B F0 03                         beq ExtraLivesPoints       ;if so, award points for extra lives
0E82D 4C F1 E8                      jmp BackToNormal           ;if not, just move on to the next world
0E830                           ExtraLivesPoints:
0E830 AD 5A 07                      lda NumberofLives          ;if counted all extra lives, branch
0E833 30 DD                         bmi ExAEL                  ;to run another task in victory mode
0E835 AD 80 07                      lda SelectTimer
0E838 D0 E6                         bne NotYet                 ;if short delay between each count of extra lives
0E83A A9 30                         lda #$30                   ;not expired, wait, otherwise, reset the timer
0E83C 8D 80 07                      sta SelectTimer
0E83F A9 40                         lda #Sfx_ExtraLife
0E841 85 FE                         sta Square2SoundQueue
0E843 CE 5A 07                      dec NumberofLives          ;count down each extra life
0E846 A9 01                         lda #$01                   ;give 100,000 points to player for each one
0E848 8D 35 01                      sta DigitModifier+1
0E84B 4C 5C C1                      jmp EndAreaPoints
0E84E                           
0E84E                           BlueTransPalette:
0E84E 3F 00 10                      .db $3f, $00, $10
0E851 0F 30 0F 0F 0F 30 10 00..     .db $0f, $30, $0f, $0f, $0f, $30, $10, $00, $0f, $21, $12, $21, $0f, $27, $17, $00
0E861 00                            .db $00
0E862                           
0E862                           BlueTints:
0E862 01 02 11 21                   .db $01, $02, $11, $21
0E866                           
0E866                           TwoBlankRows:
0E866 22 86 55 24                   .db $22, $86, $55, $24
0E86A 22 A6 55 24                   .db $22, $a6, $55, $24
0E86E 00                            .db $00
0E86F                           
0E86F                           FadeToBlue:
0E86F EE 61 07                            inc EndControlCntr   ;increment a counter
0E872 AD 63 07                            lda BlueDelayFlag    ;if it's time to fade to blue, branch
0E875 D0 0D                               bne BlueUpdateTiming
0E877 AD 61 07                            lda EndControlCntr
0E87A 29 FF                               and #$ff             ;otherwise wait until counter wraps
0E87C D0 36                               bne ExFade           ;then set the flag
0E87E EE 63 07                            inc BlueDelayFlag
0E881 4C 8B E8                            jmp BlueUpd          ;skip over next part if the flag was just set
0E884                           
0E884                           BlueUpdateTiming:
0E884 AD 61 07                             lda EndControlCntr
0E887 29 0F                                and #$0f               ;execute the next part only every 16 frames
0E889 D0 29                                bne ExFade
0E88B A2 13                     BlueUpd:   ldx #$13
0E88D BD 4E E8                  BlueULoop: lda BlueTransPalette,x ;write palette to VRAM buffer
0E890 9D 01 03                             sta VRAM_Buffer1,x
0E893 CA                                   dex
0E894 10 F7                                bpl BlueULoop
0E896 A2 0C                                ldx #$0c 
0E898 AC 62 07                             ldy BlueColorOfs       ;get color offset
0E89B B9 62 E8                  NextBlue:  lda BlueTints,y        ;set background color based on color offset
0E89E 9D 04 03                             sta VRAM_Buffer1+3,x
0E8A1 CA                                   dex                    ;be sure to set the same background color
0E8A2 CA                                   dex                    ;in all four palettes (even though only the first
0E8A3 CA                                   dex                    ;one is acknowledged)
0E8A4 CA                                   dex
0E8A5 10 F4                                bpl NextBlue
0E8A7 EE 62 07                             inc BlueColorOfs       ;increment to next color which will show up
0E8AA AD 62 07                             lda BlueColorOfs       ;16 frames later, thus causing a slow color change
0E8AD C9 04                                cmp #$04               ;if not changed to last color, leave
0E8AF D0 03                                bne ExFade
0E8B1 EE 72 07                             inc OperMode_Task      ;otherwise move on to the next task
0E8B4 60                        ExFade:    rts
0E8B5                           
0E8B5                           EraseLivesLines:
0E8B5 A2 08                          ldx #$08                  ;erase bottom two lines
0E8B7 BD 66 E8                  ELL: lda TwoBlankRows,x
0E8BA 9D 01 03                       sta VRAM_Buffer1,x
0E8BD CA                             dex
0E8BE 10 F7                          bpl ELL
0E8C0 EE 72 07                       inc OperMode_Task
0E8C3 20 15 E8                       jsr EraseEndingCounters   ;init ending counters
0E8C6 A9 60                          lda #$60
0E8C8 8D 64 07                       sta MushroomRetDelay      ;wait before flashing each mushroom retainer in next sub
0E8CB 60                             rts
0E8CC                               
0E8CC                           RunMushroomRetainers:
0E8CC 20 43 E9                         jsr MushroomRetainersForW8  ;draw and flash the seven mushroom retainers
0E8CF AD B1 07                         lda EventMusicBuffer        ;if still playing victory music, branch to leave
0E8D2 D0 03                            bne ExRMR
0E8D4 EE 72 07                         inc OperMode_Task           ;move onto the last task
0E8D7 60                        ExRMR: rts
0E8D8                           
0E8D8                           EndingDiskRoutines:
0E8D8 AD FC 07                      lda DiskIOTask
0E8DB 20 F8 8C                      jsr JumpEngine
0E8DE                           
0E8DE 87 E2                         .dw DiskScreen
0E8E0 E2 E8                         .dw UpdateGamesBeaten
0E8E2                           
0E8E2                           UpdateGamesBeaten:
0E8E2 AD 07 60                      lda GamesBeatenCount     ;get the new count of games beaten
0E8E5 18                            clc                      ;note that this code is skipped if not on world D
0E8E6 69 01                         adc #$01                 ;add one to it, to a maximum of 18/$12
0E8E8 C9 13                         cmp #19
0E8EA 90 02                         bcc SetS2S
0E8EC A9 12                         lda #18                  ;sorry, only 18 stars allowed
0E8EE                           SetS2S:
0E8EE 8D 07 60                      sta GamesBeatenCount
0E8F1                           
0E8F1                           BackToNormal:
0E8F1 A9 00                         lda #$00
0E8F3 8D FC 07                      sta DiskIOTask           ;erase task numbers
0E8F6 8D 72 07                      sta OperMode_Task
0E8F9 A9 05                         lda #Spr_MainBank+1
0E8FB 20 6C FE                      jsr SwitchSPR_CHR1       ;overwrite princess graphics with door again
0E8FE AD 5F 07                      lda WorldNumber          ;if in world D, branch to end the game
0E901 C9 0C                         cmp #WorldD
0E903 F0 12                         beq EndTheGame
0E905 AD FA 07                      lda CompletedWorlds      ;if completed all worlds without skipping over any
0E908 C9 FF                         cmp #$ff                 ;then branch elsewhere (note warping backwards may
0E90A F0 03                         beq GoToWorld9           ;allow player to complete skipped worlds)
0E90C EE 5F 07                      inc WorldNumber          ;otherwise skip over world 9
0E90F                           GoToWorld9:
0E90F A9 00                         lda #$00
0E911 8D FA 07                      sta CompletedWorlds      ;init completed worlds flag
0E914 4C 84 83                      jmp NextWorld            ;run the next world
0E917                           EndTheGame:
0E917 A9 00                         lda #$00
0E919 8D FA 07                      sta CompletedWorlds      ;init completed worlds flag
0E91C A9 03                         lda #GameOverMode        ;set game over mode
0E91E 8D 70 07                      sta OperMode
0E921 EE F5 07                      inc GameOverMsgFlag      ;increment flag for special message
0E924 4C 03 91                      jmp GameOverSubs         ;jump to game over mode routines
0E927                           
0E927                           FlashMRSpriteDataOfs:
0E927 50 B0 E0 68 98 C8             .db $50, $b0, $e0, $68, $98, $c8
0E92D                           
0E92D                           MRSpriteDataOfs:
0E92D 80 50 68 80 98 B0 C8          .db $80, $50, $68, $80, $98, $b0, $c8
0E934                           
0E934                           MRetainerYPos:
0E934 E0 B8 90 70 68 70 90          .db $e0, $b8, $90, $70, $68, $70, $90
0E93B                           
0E93B                           MRetainerXPos:
0E93B B8 38 48 60 80 A0 B8 C8       .db $b8, $38, $48, $60, $80, $a0, $b8, $c8
0E943                           
0E943                           MushroomRetainersForW8:
0E943 AD 64 07                      lda MushroomRetDelay        ;wait a bit unless waiting is already done
0E946 F0 04                         beq DrawFlashMRetainers
0E948 CE 64 07                      dec MushroomRetDelay
0E94B 60                            rts
0E94C                           
0E94C                           DrawFlashMRetainers:
0E94C 20 33 82                      jsr MoveSpritesOffscreen   ;init sprites
0E94F AE 62 07                      ldx MRetainerOffset
0E952 E0 07                         cpx #$07                   ;if 7 mushroom retainers added, branch elsewhere
0E954 F0 11                         beq FlashMRetainers
0E956 AD 61 07                      lda EndControlCntr
0E959 29 1F                         and #$1f                   ;execute this part once every 32 frames
0E95B D0 20                         bne DrawMRetainers
0E95D EE 62 07                      inc MRetainerOffset        ;add another mushroom retainer
0E960 A9 01                         lda #Sfx_CoinGrab
0E962 85 FE                         sta Square2SoundQueue      ;play the coin grab sound
0E964 4C 7D E9                      jmp DrawMRetainers
0E967                           
0E967                           FlashMRetainers:
0E967 AD 61 07                      lda EndControlCntr
0E96A 29 1F                         and #$1f                   ;execute this part once every 32 frames also
0E96C D0 0F                         bne DrawMRetainers         ;after the counter reaches a certain point
0E96E EE 63 07                      inc CurrentFlashMRet
0E971 AD 63 07                      lda CurrentFlashMRet       ;increment what's now being used to select a
0E974 C9 0B                         cmp #$0b                   ;mushroom retainer to flash, if not yet at $0b/11
0E976 90 05                         bcc DrawMRetainers         ;then go ahead to next part
0E978 A9 04                         lda #$04
0E97A 8D 63 07                      sta CurrentFlashMRet       ;otherwise reset to 4
0E97D                           DrawMRetainers:
0E97D EE 61 07                      inc EndControlCntr         ;be sure to count frames
0E980 AD 5F 07                      lda WorldNumber
0E983 48                            pha                        ;save world number and initial retainer offset
0E984 AD 62 07                      lda MRetainerOffset
0E987 48                            pha
0E988 AA                            tax                        ;use second counter as offset to one of the spr data offset lists
0E989                           DrawMRetLoop:
0E989 AD 63 07                      lda CurrentFlashMRet       ;if offset not yet at 4 (first time it starts at 0), branch to skip this
0E98C C9 04                         cmp #$04                   ;thus adding a delay between the appearance
0E98E 90 0B                         bcc SetupMRet              ;of mushroom retainers and their "flashing"
0E990 E9 04                         sbc #$04
0E992 A8                            tay                        ;otherwise subtract 4 to get the offset proper
0E993 B9 27 E9                      lda FlashMRSpriteDataOfs,y ;if the sprite obj data offset pointed at by the current flashing retainer
0E996 DD 2D E9                      cmp MRSpriteDataOfs,x      ;matches the one pointed at by the offset of the retainer being checked
0E999 F0 1F                         beq NextMRet               ;then branch to skip, do not draw that mushroom retainer
0E99B                           SetupMRet:
0E99B BC 2D E9                      ldy MRSpriteDataOfs,x      ;get sprite data offset of the current mushroom retainer
0E99E 8C E5 06                      sty Enemy_SprDataOffset
0E9A1 A9 35                         lda #$35
0E9A3 85 16                         sta $16                    ;set mushroom retainer object ID
0E9A5 BD 34 E9                      lda MRetainerYPos,x
0E9A8 85 CF                         sta Enemy_Y_Position       ;use enemy object 0 for mushroom retainer temporarily
0E9AA BD 3B E9                      lda MRetainerXPos,x
0E9AD 8D AE 03                      sta Enemy_Rel_XPos
0E9B0 A2 00                         ldx #$00                   ;set world number and object offset for the graphics handler
0E9B2 8E 5F 07                      stx WorldNumber            ;to prevent graphics handler from drawing princess instead
0E9B5 86 08                         stx ObjectOffset
0E9B7 20 3E D7                      jsr EnemyGfxHandler        ;now draw the mushroom retainer
0E9BA                           NextMRet:
0E9BA CE 62 07                      dec MRetainerOffset        ;move to next mushroom retainer using offset
0E9BD AE 62 07                      ldx MRetainerOffset
0E9C0 D0 C7                         bne DrawMRetLoop           ;if not drawn all retainers yet, loop to do so
0E9C2 68                            pla
0E9C3 8D 62 07                      sta MRetainerOffset        ;reset initial offset
0E9C6 68                            pla
0E9C7 8D 5F 07                      sta WorldNumber            ;return world number to what it was to draw princess
0E9CA A9 30                         lda #$30
0E9CC 8D E5 06                      sta Enemy_SprDataOffset
0E9CF A9 B8                         lda #$b8                   ;return original settings princess uses (note X position
0E9D1 85 CF                         sta Enemy_Y_Position       ;will be returned later in enemy object core)
0E9D3 60                            rts
0E9D4                           
0E9D4                           ;-------------------------------------------------------------------------------------
0E9D4                           
0E9D4                           FinalRoomPalette:
0E9D4 3F 00 10                      .db $3f, $00, $10
0E9D7 0F 0F 0F 0F 0F 30 10 00       .db $0f, $0f, $0f, $0f, $0f, $30, $10, $00
0E9DF 0F 21 12 02 0F 27 17 00       .db $0f, $21, $12, $02, $0f, $27, $17, $00
0E9E7 00                            .db $00
0E9E8                           
0E9E8                           MarioThankYouMsgFinal:
0E9E8 20 E8 10                      .db $20, $e8, $10
0E9EB 1D 11 0A 17 14 24 22 18..     .db $1d, $11, $0a, $17, $14, $24, $22, $18, $1e, $24
0E9F5 16 0A 1B 12 18 2B             .db $16, $0a, $1b, $12, $18, $2b
0E9FB 23 C8 48 05                   .db $23, $c8, $48, $05
0E9FF 00                            .db $00
0EA00                           
0EA00                           LuigiThankYouMsgFinal:
0EA00 20 E8 10                      .db $20, $e8, $10
0EA03 1D 11 0A 17 14 24 22 18..     .db $1d, $11, $0a, $17, $14, $24, $22, $18, $1e, $24
0EA0D 15 1E 12 10 12 2B             .db $15, $1e, $12, $10, $12, $2b
0EA13 23 C8 48 05                   .db $23, $c8, $48, $05
0EA17 00                            .db $00
0EA18                           
0EA18                           PeaceIsPavedMsg:
0EA18 21 09 0E                      .db $21, $09, $0e
0EA1B 19 0E 0A 0C 0E 24 12 1C..     .db $19, $0e, $0a, $0c, $0e, $24, $12, $1c, $24
0EA24 19 0A 1F 0E 0D                .db $19, $0a, $1f, $0e, $0d
0EA29 23 D0 58 AA                   .db $23, $d0, $58, $aa
0EA2D 00                            .db $00
0EA2E                           
0EA2E                           WithKingdomSavedMsg:
0EA2E 21 47 12                      .db $21, $47, $12
0EA31 20 12 1D 11 24 14 12 17..     .db $20, $12, $1d, $11, $24, $14, $12, $17, $10, $0d, $18, $16, $24
0EA3E 1C 0A 1F 0E 0D                .db $1c, $0a, $1f, $0e, $0d
0EA43 00                            .db $00
0EA44                           
0EA44                           MarioHurrahMsg:
0EA44 21 89 0F                      .db $21, $89, $0f
0EA47 11 1E 1B 1B 0A 11 24 1D..     .db $11, $1e, $1b, $1b, $0a, $11, $24, $1d, $18, $24, $16, $0a, $1b
0EA54 12 18                         .db $12, $18
0EA56 00                            .db $00
0EA57                           
0EA57                           LuigiHurrahMsg:
0EA57 21 89 0F                      .db $21, $89, $0f
0EA5A 11 1E 1B 1B 0A 11 24 1D..     .db $11, $1e, $1b, $1b, $0a, $11, $24, $1d, $18, $24, $15, $1e, $12
0EA67 10 12                         .db $10, $12
0EA69 00                            .db $00
0EA6A                           
0EA6A                           OurOnlyHeroMsg:
0EA6A 21 CA 0D                      .db $21, $ca, $0d
0EA6D 18 1E 1B 24 18 17 15 22..     .db $18, $1e, $1b, $24, $18, $17, $15, $22, $24, $11, $0e, $1b, $18
0EA7A 00                            .db $00
0EA7B                           
0EA7B                           ThisEndsYourTripMsg:
0EA7B 22 07 13                      .db $22, $07, $13
0EA7E 1D 11 12 1C 24 0E 17 0D..     .db $1d, $11, $12, $1c, $24, $0e, $17, $0d, $1c, $24, $22, $18, $1e
0EA8B 1B 24 1D 1B 12 19             .db $1b, $24, $1d, $1b, $12, $19
0EA91 00                            .db $00
0EA92                           
0EA92                           OfALongFriendshipMsg:
0EA92 22 46 14                      .db $22, $46, $14
0EA95 18 0F 24 0A 24 15 18 17..     .db $18, $0f, $24, $0a, $24, $15, $18, $17, $10, $24, $0f, $1b, $12
0EAA2 0E 17 0D 1C 11 12 19          .db $0e, $17, $0d, $1c, $11, $12, $19
0EAA9 00                            .db $00
0EAAA                           
0EAAA                           PointsAddedMsg:
0EAAA 22 88 10                      .db $22, $88, $10
0EAAD 01 00 00 00 00 00 24 19..     .db $01, $00, $00, $00, $00, $00, $24, $19, $1d, $1c, $af, $0a, $0d
0EABA 0D 0E 0D                      .db $0d, $0e, $0d
0EABD                           
0EABD 23 E8 48 FF                   .db $23, $e8, $48, $ff
0EAC1 00                            .db $00
0EAC2                               
0EAC2                           ForEachPlayerLeftMsg:
0EAC2 22 A6 15                      .db $22, $a6, $15
0EAC5 0F 18 1B 24 0E 0A 0C 11..     .db $0f, $18, $1b, $24, $0e, $0a, $0c, $11, $24, $19, $15, $0a, $22
0EAD2 0E 1B 24 15 0E 0F 1D AF       .db $0e, $1b, $24, $15, $0e, $0f, $1d, $af
0EADA 00                            .db $00
0EADB                           
0EADB                           PrincessPeachsRoom:
0EADB 20 80 60 5E                   .db $20, $80, $60, $5e
0EADF 20 A0 60 5D                   .db $20, $a0, $60, $5d
0EAE3 23 40 60 5E                   .db $23, $40, $60, $5e
0EAE7 23 60 60 5D                   .db $23, $60, $60, $5d
0EAEB 23 80 60 5E                   .db $23, $80, $60, $5e
0EAEF 23 A0 60 5D                   .db $23, $a0, $60, $5d
0EAF3 23 C0 50 55                   .db $23, $c0, $50, $55
0EAF7 23 F0 50 55                   .db $23, $f0, $50, $55
0EAFB 00                            .db $00
0EAFC                           
0EAFC                           FantasyWorld9Msg:
0EAFC 22 24 18                      .db $22, $24, $18
0EAFF 20 0E 24 19 1B 0E 1C 0E..     .db $20, $0e, $24, $19, $1b, $0e, $1c, $0e, $17, $1d, $24, $0f, $0a
0EB0C 17 1D 0A 1C 22 24 20 18..     .db $17, $1d, $0a, $1c, $22, $24, $20, $18, $1b, $15, $0d
0EB17                           
0EB17 22 66 13                      .db $22, $66, $13
0EB1A 15 0E 1D F2 1C 24 1D 1B..     .db $15, $0e, $1d, $f2, $1c, $24, $1d, $1b, $22, $24, $76, $09, $24
0EB27 20 18 1B 15 0D 75             .db $20, $18, $1b, $15, $0d, $75
0EB2D                           
0EB2D 22 A9 0E                      .db $22, $a9, $0e
0EB30 20 12 1D 11 24 18 17 0E..     .db $20, $12, $1d, $11, $24, $18, $17, $0e, $24, $10, $0a, $16, $0e
0EB3D AF                            .db $af
0EB3E 00                            .db $00
0EB3F                           
0EB3F                           ThanksForPlayingMsg:
0EB3F                               ;clears "CONTINUE" and "RETRY" text
0EB3F 21 E0 60 24                   .db $21, $e0, $60, $24
0EB43 22 40 60 24                   .db $22, $40, $60, $24
0EB47                           
0EB47                               ;"THANKS FOR PLAYING!"
0EB47 21 E6 13                      .db $21, $e6, $13
0EB4A 1D 11 0A 17 14 1C 24 0F..     .db $1d, $11, $0a, $17, $14, $1c, $24, $0f, $18, $1b, $24, $19, $15
0EB57 0A 22 12 17 10 2B             .db $0a, $22, $12, $17, $10, $2b
0EB5D                           
0EB5D                               ;"DEVELOPED BY:"
0EB5D 22 26 0D                      .db $22, $26, $0d
0EB60 0D 0E 1F 0E 15 18 19 0E..     .db $0d, $0e, $1f, $0e, $15, $18, $19, $0e, $0d, $24, $0b, $22, $9a
0EB6D                           
0EB6D                               ;"-SIMPLISTIC6502"
0EB6D 22 69 0F                      .db $22, $69, $0f
0EB70 28 1C 12 16 19 15 12 1C..     .db $28, $1c, $12, $16, $19, $15, $12, $1c, $1d, $12, $0c, $06, $05
0EB7D 00 02                         .db $00, $02
0EB7F                           
0EB7F                               ;"-SERAPHMIII"
0EB7F 22 A9 0B                      .db $22, $a9, $0b
0EB82 28 1C 0E 1B 0A 19 11 16..     .db $28, $1c, $0e, $1b, $0a, $19, $11, $16, $12, $12, $12
0EB8D                           
0EB8D                               ;"SPECIAL THANKS:"
0EB8D 22 E6 0F                      .db $22, $e6, $0f
0EB90 1C 19 0E 0C 12 0A 15 24..     .db $1c, $19, $0e, $0c, $12, $0a, $15, $24, $1d, $11, $0a, $17, $14
0EB9D 1C 9A                         .db $1c, $9a
0EB9F                           
0EB9F                               ;"-THREECREEPIO"
0EB9F 23 29 0D                      .db $23, $29, $0d
0EBA2 28 1D 11 1B 0E 0E 0C 1B..     .db $28, $1d, $11, $1b, $0e, $0e, $0c, $1b, $0e, $0e, $19, $12, $18
0EBAF 00                            .db $00
0EBB0                           
0EBB0                           ;-------------------------------------------------------------------------------------
0EBB0 FF FF FF FF FF FF FF FF.. .pad $fe00,$ff
0FE00                           
0FE00                           SM2Header:
0FE00 53 4D 32 53 41 56 45              .db "SM2SAVE"
0FE07                           
0FE07                           CheckSaveData:
0FE07 A2 00                             ldx #$00                ;init counter
0FE09 BD 00 FE                  SChkLp: lda SM2Header,x         ;check all seven bytes of the save data header
0FE0C DD 00 60                          cmp SaveDataHeader,x    ;and see if it is identical to what it should be
0FE0F D0 06                             bne InitializeSaveData  ;if any byte does not match, wipe existing save data
0FE11 E8                                inx
0FE12 E0 07                             cpx #$07                ;have we gone through all seven bytes?
0FE14 90 F3                             bcc SChkLp              ;if not, loop back
0FE16 60                                rts                     ;otherwise save data is valid, leave
0FE17                           InitializeSaveData:
0FE17 A2 00                             ldx #$00                ;init counter
0FE19 8E 07 60                          stx GamesBeatenCount    ;wipe number of games beaten
0FE1C BD 00 FE                  SaveLp: lda SM2Header,x         ;write save data header
0FE1F 9D 00 60                          sta SaveDataHeader,x
0FE22 E8                                inx
0FE23 E0 07                             cpx #$07                ;have we gone through all seven bytes?
0FE25 90 F5                             bcc SaveLp              ;if not, loop back
0FE27 60                                rts                     ;otherwise we have reset save data, leave
0FE28                           
0FE28                           InitializeBG_CHR:
0FE28 A9 00                           lda #BG_MainBank
0FE2A 20 3A FE                        jsr SwitchBG_CHR0
0FE2D A9 01                           lda #BG_MainBank+1
0FE2F                           SwitchBG_CHR1:
0FE2F 48                        	pha
0FE30 A9 01                     	lda #%00000001
0FE32 8D 00 80                  	sta MMC3_BankSelect
0FE35 68                        	pla
0FE36 8D 01 80                  	sta MMC3_BankData
0FE39 60                        	rts
0FE3A                           SwitchBG_CHR0:
0FE3A 48                        	pha
0FE3B A9 00                     	lda #%00000000
0FE3D 8D 00 80                  	sta MMC3_BankSelect
0FE40 68                        	pla
0FE41 8D 01 80                  	sta MMC3_BankData
0FE44 60                        	rts
0FE45                           
0FE45                           InitializeSPR_CHR:
0FE45 A9 04                           lda #Spr_MainBank
0FE47 20 77 FE                        jsr SwitchSPR_CHR0
0FE4A A9 05                           lda #Spr_MainBank+1
0FE4C 20 6C FE                        jsr SwitchSPR_CHR1
0FE4F A9 06                           lda #Spr_MainBank+2
0FE51 20 61 FE                        jsr SwitchSPR_CHR2
0FE54 A9 07                           lda #Spr_MainBank+3
0FE56                           SwitchSPR_CHR3:
0FE56 48                        	pha
0FE57 A9 05                     	lda #%00000101
0FE59 8D 00 80                  	sta MMC3_BankSelect
0FE5C 68                        	pla
0FE5D 8D 01 80                  	sta MMC3_BankData
0FE60 60                        	rts
0FE61                           SwitchSPR_CHR2:
0FE61 48                        	pha
0FE62 A9 04                     	lda #%00000100
0FE64 8D 00 80                  	sta MMC3_BankSelect
0FE67 68                        	pla
0FE68 8D 01 80                  	sta MMC3_BankData
0FE6B 60                        	rts
0FE6C                           SwitchSPR_CHR1:
0FE6C 48                        	pha
0FE6D A9 03                     	lda #%00000011
0FE6F 8D 00 80                  	sta MMC3_BankSelect
0FE72 68                        	pla
0FE73 8D 01 80                  	sta MMC3_BankData
0FE76 60                        	rts
0FE77                           SwitchSPR_CHR0:
0FE77 48                        	pha
0FE78 A9 02                     	lda #%00000010
0FE7A 8D 00 80                  	sta MMC3_BankSelect
0FE7D 68                        	pla
0FE7E 8D 01 80                  	sta MMC3_BankData
0FE81 60                        	rts
0FE82                           
0FE82                           LoadMainBank:
0FE82 A9 04                     	lda #MainBank        ;load main bank
0FE84 20 94 FE                  	jsr SwitchPRGBank0
0FE87 A9 05                     	lda #MainBank+1        ;load main bank		
0FE89                           SwitchPRGBank1:
0FE89 48                        	pha
0FE8A A9 07                     	lda #%00000111
0FE8C 8D 00 80                  	sta MMC3_BankSelect
0FE8F 68                        	pla
0FE90 8D 01 80                  	sta MMC3_BankData
0FE93 60                        	rts
0FE94                           SwitchPRGBank0:
0FE94 48                        	pha
0FE95 A9 06                     	lda #%00000110
0FE97 8D 00 80                  	sta MMC3_BankSelect
0FE9A 68                        	pla
0FE9B 8D 01 80                  	sta MMC3_BankData
0FE9E 60                        	rts
0FE9F                           
0FE9F                           RunSoundEngine:
0FE9F A9 00                     	lda #SoundBank        ;switch bank
0FEA1 20 94 FE                  	jsr SwitchPRGBank0
0FEA4 A9 01                     	lda #SoundBank+1        ;switch bank again :DDDDDDDD
0FEA6 20 89 FE                  	jsr SwitchPRGBank1
0FEA9 20 00 80                  	jsr SoundEngine       ;run relevant routine
0FEAC 4C 82 FE                  	jmp LoadMainBank      ;and return to main bank
0FEAF                           
0FEAF                           RunLoadAreaPointer:
0FEAF A9 02                     	lda #LevelsBank       ;switch bank
0FEB1 20 94 FE                  	jsr SwitchPRGBank0
0FEB4 A9 03                     	lda #LevelsBank+1       ;switch bank again :DDDDDDDD
0FEB6 20 89 FE                  	jsr SwitchPRGBank1
0FEB9 20 00 80                  	jsr LoadAreaPointer   ;run relevant routine
0FEBC 4C 82 FE                  	jmp LoadMainBank      ;and return to main bank
0FEBF                           
0FEBF                           RunGetAreaDataAddrs:
0FEBF A9 02                     	lda #LevelsBank       ;switch bank
0FEC1 20 94 FE                  	jsr SwitchPRGBank0
0FEC4 A9 03                     	lda #LevelsBank+1       ;switch bank again :DDDDDDDD
0FEC6 20 89 FE                  	jsr SwitchPRGBank1
0FEC9 20 44 80                  	jsr GetAreaDataAddrs  ;run relevant routine
0FECC 4C 82 FE                  	jmp LoadMainBank      ;and return to main bank
0FECF                           
0FECF                           RunGetAreaPointer:
0FECF A9 02                     	lda #LevelsBank       ;switch bank
0FED1 20 94 FE                  	jsr SwitchPRGBank0
0FED4 A9 03                     	lda #LevelsBank+1       ;switch bank again :DDDDDDDD
0FED6 20 89 FE                  	jsr SwitchPRGBank1
0FED9 20 31 80                  	jsr GetAreaPointer    ;run relevant routine
0FEDC 4C 82 FE                  	jmp LoadMainBank      ;and return to main bank
0FEDF                           
0FEDF                           IRQHandler:
0FEDF 78                        	sei
0FEE0 08                        	php                      ;save regs
0FEE1 48                        	pha
0FEE2 8A                        	txa
0FEE3 48                        	pha
0FEE4 98                        	tya
0FEE5 48                        	pha        
0FEE6 A0 06                           ldy #$06                 ;delay for right part of scanline 31
0FEE8 88                        DelS: dey
0FEE9 D0 FD                           bne DelS
0FEEB AD 78 07                  	lda Mirror_PPU_CTRL
0FEEE 29 EF                     	and #$ef                 ;mask out sprite address high reg of ctrl reg mirror
0FEF0 0D 7A 07                  	ora NameTableSelect      ;mask in whatever's set here
0FEF3 8D 78 07                  	sta Mirror_PPU_CTRL      ;update the register and its mirror
0FEF6 8D 00 20                  	sta PPU_CTRL
0FEF9 A9 00                     	lda #$00
0FEFB 8D 00 E0                  	sta MMC3_IRQDisable      ;disable IRQs for the rest of the frame
0FEFE AD 3F 07                  	lda HorizontalScroll
0FF01 8D 05 20                  	sta PPU_SCROLL           ;set scroll regs for the screen under the status bar
0FF04 AD 40 07                  	lda VerticalScroll       ;to achieve the split screen effect
0FF07 8D 05 20                  	sta PPU_SCROLL
0FF0A A9 00                     	lda #$00
0FF0C 8D 7B 07                  	sta IRQAckFlag           ;indicate IRQ was acknowledged
0FF0F 68                        	pla
0FF10 A8                        	tay                      ;return regs, reenable IRQs and leave
0FF11 68                        	pla
0FF12 AA                        	tax
0FF13 68                        	pla
0FF14 28                        	plp
0FF15 58                        	cli
0FF16 40                        	rti
0FF17                           
0FF17                           Reset:
0FF17 78                        	sei                        ;replicate init code present in FDS BIOS
0FF18 A9 10                     	lda #$10
0FF1A 8D 00 20                  	sta PPU_CTRL
0FF1D D8                        	cld
0FF1E A9 06                     	lda #$06
0FF20 8D 01 20                  	sta PPU_MASK
0FF23 A2 02                     	ldx #$02
0FF25                           VBlank:
0FF25 AD 02 20                  	lda PPU_STATUS
0FF28 10 FB                     	bpl VBlank
0FF2A CA                        	dex
0FF2B D0 F8                     	bne VBlank
0FF2D 8E 16 40                  	stx JOYPAD_PORT1
0FF30 8E 10 40                  	stx SND_DELTA_REG
0FF33 A9 C0                     	lda #$c0
0FF35 8D 17 40                  	sta JOYPAD_PORT2
0FF38 A9 0F                     	lda #$0f
0FF3A 8D 15 40                  	sta SND_MASTERCTRL_REG
0FF3D A2 FF                     	ldx #$ff
0FF3F 9A                        	txs
0FF40 A9 00                     	lda #$00
0FF42 8D 00 A0                  	sta MMC3_Mirroring ; vertical mirroring
0FF45 A9 80                     	lda #%10000000
0FF47 8D 01 A0                  	sta MMC3_PRGRAMProtect ; enable PRG-RAM
0FF4A 20 82 FE                  	jsr LoadMainBank            ;switch PRG banks
0FF4D 20 28 FE                  	jsr InitializeBG_CHR        ;init CHR banks
0FF50 20 45 FE                        jsr InitializeSPR_CHR
0FF53 20 07 FE                  	jsr CheckSaveData           ;check validity of save data
0FF56 4C 00 80                  	jmp Start                   ;now start the game!
0FF59                           
0FF59                           ;-------------------------------------------------------------------------------------
0FF59                           ;INTERRUPT VECTORS
0FF59                           
0FF59 FF FF FF FF FF FF FF FF.. .pad $fffa,$ff
0FFFA                           
0FFFA                           ;"VECTORS"
0FFFA 94 80                             .dw NMIHandler
0FFFC 17 FF                             .dw Reset
0FFFE DF FE                             .dw IRQHandler
10000                           
10000                           ;"CHR"
10000 7C FE E7 E7 E7 7F 3E 00..         .incbin "sm2char1_bg.chr"
11000 03 0F 1F 1F 1C 24 26 66..         .incbin "sm2char1_spr.chr"
12000 7C FE E7 E7 E7 7F 3E 00..         .incbin "title_bg.chr"
13000 03 0F 1F 1F 1C 24 26 66..         .incbin "ending_spr.chr"